(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[87],{8888:(e,n,t)=>{Promise.resolve().then(t.bind(t,3899)),Promise.resolve().then(t.bind(t,7260)),Promise.resolve().then(t.bind(t,3713)),Promise.resolve().then(t.bind(t,2703)),Promise.resolve().then(t.bind(t,1128)),Promise.resolve().then(t.t.bind(t,2626,23)),Promise.resolve().then(t.bind(t,2734)),Promise.resolve().then(t.bind(t,5538)),Promise.resolve().then(t.bind(t,807)),Promise.resolve().then(t.bind(t,2719)),Promise.resolve().then(t.bind(t,1485)),Promise.resolve().then(t.bind(t,619)),Promise.resolve().then(t.bind(t,1811)),Promise.resolve().then(t.bind(t,7474)),Promise.resolve().then(t.bind(t,5735)),Promise.resolve().then(t.bind(t,382)),Promise.resolve().then(t.bind(t,7556)),Promise.resolve().then(t.bind(t,763)),Promise.resolve().then(t.bind(t,8373)),Promise.resolve().then(t.bind(t,6335)),Promise.resolve().then(t.bind(t,3390)),Promise.resolve().then(t.bind(t,9890)),Promise.resolve().then(t.bind(t,9978))},3899:(e,n,t)=>{"use strict";t.d(n,{default:()=>o});var s=t(5155),r=t(6046),a=t(8173),i=t.n(a);function o(){let e=(0,r.useParams)(),n=(0,r.useSearchParams)(),t=e.slug,a=n.get("page")||1;return(0,s.jsx)(i(),{href:"/".concat(t,"?page=").concat(a),className:"text-blue-600 hover:underline",children:"Back to List"})}},2761:(e,n,t)=>{"use strict";t.d(n,{A:()=>r});var s=t(5155);function r(e){let{text:n}=e;return(0,s.jsx)("h1",{className:"text-4xl font-bold text-left my-5 text-gray-800",children:n})}},2101:(e,n,t)=>{"use strict";t.d(n,{A:()=>o});var s=t(5155),r=t(2115),a=t(910),i=t.n(a);function o(e){let{codeType:n,codeBlock:t,initOpen:a=!0,tail:o,title:l="코드 보기"}=e,[c,d]=(0,r.useState)(a),[h,p]=(0,r.useState)(0),x=(0,r.useRef)(null);return(0,r.useEffect)(()=>{i().highlightAll()},[c]),(0,r.useEffect)(()=>{x.current&&p(c?x.current.scrollHeight:0)},[c,t]),(0,s.jsxs)("div",{className:"w-full mx-auto mb-3",children:[(0,s.jsxs)("button",{onClick:()=>d(!c),className:"w-full text-left p-2 bg-gray-800 text-white rounded-t-md flex justify-between items-center",children:[(0,s.jsxs)("span",{children:["\uD83D\uDCDC ",l,o]}),(0,s.jsx)("span",{children:c?"▲":"▼"})]}),(0,s.jsx)("div",{ref:x,className:"transition-[max-height] duration-300 ease-in-out overflow-hidden bg-gray-900 rounded-b-md",style:{maxHeight:"".concat(h,"px"),padding:c?"1rem":"0"},children:(0,s.jsx)("pre",{className:"whitespace-pre-wrap ".concat(n),children:(0,s.jsx)("code",{children:t})})})]})}t(8452)},908:(e,n,t)=>{"use strict";t.d(n,{A:()=>r});var s=t(5155);function r(e){let{text:n}=e;return(0,s.jsxs)("div",{className:"flex items-center my-6",children:[(0,s.jsx)("div",{className:"flex-1 border-t border-gray-300"}),n&&(0,s.jsx)("span",{className:"mx-4 text-sm text-gray-600",children:n}),(0,s.jsx)("div",{className:"flex-1 border-t border-gray-300"})]})}},6529:(e,n,t)=>{"use strict";t.d(n,{A:()=>r});var s=t(5155);function r(e){let{text:n}=e;return(0,s.jsx)("h2",{className:"text-2xl mt-12 mb-3 text-gray-700 font-bold",children:n})}},9969:(e,n,t)=>{"use strict";t.d(n,{A:()=>r});var s=t(5155);function r(e){let{text:n,addClass:t}=e;return(0,s.jsxs)("div",{className:"".concat(t," border border-dashed border-gray-400 p-4 bg-gray-50 italic shadow-md text-gray-700"),children:[(0,s.jsx)("strong",{className:"font-semibold",children:"Note:"}),(0,s.jsx)("p",{className:"whitespace-pre-line",children:n})]})}},6167:(e,n,t)=>{"use strict";t.d(n,{A:()=>r});var s=t(5155);function r(e){let{href:n,prefix:t,text:r,title:a}=e;return(0,s.jsxs)("div",{children:[(0,s.jsxs)("span",{className:"text-gray-600",children:[a||"출처"," : "]}),t?(0,s.jsxs)("strong",{className:"text-gray-600",children:["[ ",t," ] "]}):null,(0,s.jsx)("a",{href:n,target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:r})]})}},5483:(e,n,t)=>{"use strict";t.d(n,{A:()=>a});var s=t(5155),r=t(2115);function a(e){let{children:n,initOpen:t=!1,tail:a,title:i="원문 보기"}=e,[o,l]=(0,r.useState)(t),c=(0,r.useRef)(null),[d,h]=(0,r.useState)("0px");return(0,r.useEffect)(()=>{c.current&&h(o?"".concat(c.current.scrollHeight,"px"):"0px")},[o]),(0,s.jsxs)("div",{className:"w-full mx-auto mb-3",children:[(0,s.jsxs)("button",{onClick:()=>l(!o),className:"w-full text-left p-2 bg-gray-700 text-white rounded-t-md flex justify-between items-center hover:bg-gray-600 transition-colors",children:[(0,s.jsxs)("span",{children:["\uD83D\uDCDC ",i,a]}),(0,s.jsx)("span",{children:o?"▲":"▼"})]}),(0,s.jsx)("div",{ref:c,className:"duration-300 ease-in-out overflow-hidden bg-gray-800 text-gray-200 rounded-b-md",style:{maxHeight:d,transition:"max-height 0.3s ease-in-out"},children:(0,s.jsx)("div",{className:"p-4",children:n})})]})}},2139:(e,n,t)=>{"use strict";t.d(n,{A:()=>r});var s=t(5155);function r(e){let{text:n,type:t="h1"}=e,r=["h1","h2","h3","p","div"].includes(t)?t:"h2",a="mt-6 mb-2 font-bold text-gray-700 "+("h1"===t?"text-3xl":"h2"===t?"text-2xl":"h3"===t?"text-xl":"text-base");return(0,s.jsx)(r,{className:a,children:n})}},7260:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>p});var s=t(5155),r=t(910),a=t.n(r);t(8452);var i=t(2115),o=t(2761),l=t(6167),c=t(908),d=t(2626),h=t.n(d);function p(){return(0,i.useEffect)(()=>{a().highlightAll()},[]),(0,s.jsxs)("div",{className:h().container,children:[(0,s.jsx)(o.A,{text:"The Anatomy of a Good Decision"}),(0,s.jsx)(l.A,{href:"https://shrime.medium.com/the-anatomy-of-a-good-decision-bc3f590a0d76",prefix:"Medium",text:"https://shrime.medium.com/the-anatomy-of-a-good-decision-bc3f590a0d76"}),(0,s.jsx)(c.A,{text:"2024.01.27"}),(0,s.jsxs)("section",{className:h().paragraph,children:[(0,s.jsx)("div",{children:"좋은 결정의 해부학. 자세한 설명은 링크를 참조."}),(0,s.jsx)("div",{children:"간단한 해석을 그림 하단에 넣었다가, 위로 올렸습니다."}),(0,s.jsx)("div",{children:"왜냐면, 저는 7단계에서 맥이 빠졌기 때문입니다."})]}),(0,s.jsx)(c.A,{}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"Step1: 오너쉽 체크 - 결정할 권한이 있습니까? 결정권이 없다고 하기 전에 혹시 스스로 회피하고 있는지도 생각해 보세요. 도식은 두려움에 회피하지 않는데도 도움이 될겁니다."}),(0,s.jsx)("li",{children:"Step2: 가치 분석 - 세가지 중요한 것을 꼽습니다. 중요도에 대해 1-10 척도를 적용해 두세요.(예, 급여 10, 근무지 2, 근로시간 8)"}),(0,s.jsx)("li",{children:'Step3: 선택지 설정 - 어떤 선택을 할지를 나열해 둡니다. 예를들어, 결혼생활을 고민한다면 "떠난다"와 "남는다" 두가지 선택지가 있을 수 있습니다.'}),(0,s.jsx)("li",{children:"Step4: The dealbreakers(걸림돌) - 절대 받아 들일 수 없는 조건이 있는지 확인합니다."}),(0,s.jsx)("li",{children:"Step5: 각 옵션 평가 - 1~10점 척도로 각 옵션(Step2 가치)에 대해 점수를 주세요. (예, 급여: 8, 근무지 위치: 10, 근로시간: 7)"}),(0,s.jsx)("li",{children:"Step6: 수학은 마법과 같아요 - 5단계 점수와 2단계 가중치를 곱하고, 곱한 값들을 합산하면 됩니다. (예, 직장1 = 급여 10*8 + 근무지 2*10 + 근로시간 8*7)"}),(0,s.jsx)("li",{children:"Step7: 불확실성 - 비록, 이성적으로 결정을 내렸지만 아직입니다. 5일동안 그 결정을 내렸다고 생각하고 살아보세요. 그 후에, 기분이 어떤가요? 만약 계속해서 좋다면, 끝입니다."})]})}),(0,s.jsx)(c.A,{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"마지막 7단계에서 살짝 어이가 없어졌다."}),(0,s.jsx)("div",{children:"무언가 명료한듯 하다가 슬그머니 내빼는 느낌이랄까."}),(0,s.jsx)("div",{children:"저만 이런기분인 걸까요. 암튼, 간단한 수식이지만 결정을 구체화 하는 방안으로 고려해볼 수는 있겠다."}),(0,s.jsx)("div",{children:"팀별 시너지를 계산하는 것도, 기회가 되면 정리해 보겠습니다. GPT와 질의 응답을 통해 만든 수식이지만, 이 글보다 오히려 신뢰도가 있을것 같아요. 기분이를 넣지는 않았거든요."})]}),(0,s.jsx)("br",{}),(0,s.jsx)(l.A,{href:"https://www.markshrime.com/anatomy-pdf",prefix:"markshrime.com",text:"https://www.markshrime.com/anatomy-pdf"}),(0,s.jsx)("img",{className:"mt-3",src:"/image/slug/decisionMaking.jpg"}),(0,s.jsx)(c.A,{text:"저기요... 주의사항이 뒤에 적혀있어요. 아, 안돼..."}),(0,s.jsx)("img",{className:"mt-3",src:"/image/slug/keselius.png"})]})}},3713:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>d});var s=t(5155),r=t(2761),a=t(6167),i=t(908),o=t(2626),l=t.n(o),c=t(9969);function d(){return(0,s.jsxs)("div",{className:l().container,children:[(0,s.jsx)(r.A,{text:"Being a “learn-it-all” will get you way further than being a “know-it-all”"}),(0,s.jsx)(a.A,{href:"https://blog.medium.com/being-a-learn-it-all-will-get-you-way-further-than-being-a-know-it-all-49b63b7cae51",prefix:"Medium",text:"https://blog.medium.com/being-a-learn-it-all-will-get-you-way-further-than-being-a-know-it-all-49b63b7cae51"}),(0,s.jsx)(i.A,{text:"2024.02.04"}),(0,s.jsx)("section",{className:l().paragraph,children:(0,s.jsx)("div",{children:"번역이 틀릴 수 있습니다."})}),(0,s.jsx)(i.A,{}),(0,s.jsx)(r.A,{text:"모든 걸 알고 있다고 하는 것보다, 계속 배우려는 태도를 가지는 것이 훨씬 발전할 수 있다."}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"Y Combinator의 창립자 폴 그래햄은 2007년,"}),(0,s.jsx)("div",{children:"구글의 웹 애플리케이션(주로 Gmail)과 애플이 부상하자 윈도우를 향해 '할머니들이나 쓰는 쓸모없는 도구'로 만들어 버렸다고 말했습니다."})]}),(0,s.jsxs)("section",{className:"mb-5",children:[(0,s.jsx)("div",{children:'그래햄은 "마이크로소프트의 최대 약점"은 그들이 얼마나 형편없는지 모른다는 것이라 했습니다. 다시말해 그들이 안일하다는 겁니다. - 그리고 그래햄의 말이 틀린것도 아니었습니다.'}),(0,s.jsx)(c.A,{text:"complacent - 안일한"})]}),(0,s.jsxs)("section",{className:"mb-5",children:[(0,s.jsx)("div",{children:"마이크로 소프트 엔지니어인 오바산조는 이렇게 회상합니다."}),(0,s.jsx)("div",{children:"수많은 실패에도 불구하고,"}),(0,s.jsx)("div",{children:"많은 이들이 우리가 윈도우와 오피스를 보유했다는 이유로 마치 우리가 엄청난 것처럼 행동 했습니다."}),(0,s.jsx)("div",{children:"그 두 가지는 역사상 가장 성공적인 소프트웨어이긴 했죠."}),(0,s.jsx)(c.A,{text:"best thing since sliced bread - 1928년 미국에서 처음 상업적으로 판매된 식빵. 미리 잘려서 나와서 당시엔 혁신이었다고."}),(0,s.jsx)(c.A,{text:"대단한 것처럼 행동하는 주체가 외부인이 아니라 MS 내부, 자신들을 말하는 것 같습니다."})]}),(0,s.jsxs)("section",{className:"mb-5",children:[(0,s.jsx)("div",{children:"교훈: 성공에 안주하지 않는 것이 때로는 실패를 딛고 다시 일어서는 것보다 더 어렵다."}),(0,s.jsx)("div",{children:"실수를 감수할 용기,"}),(0,s.jsx)("div",{children:"남과 다르게 행동할 용기,"}),(0,s.jsx)("div",{children:"새로운 것에 서툴러도 배우려는 용기"}),(0,s.jsx)("div",{children:"— 이런 것들을 갖추는 것은, 윈도우 처럼 전설적인 제품을 만든 이들이라도 결코 쉬운 일이 아니다."}),(0,s.jsx)(c.A,{text:"find the will - 맘먹고 해내려는 것."}),(0,s.jsx)(c.A,{text:"weird - 기이한."}),(0,s.jsx)(c.A,{text:"from scratch - 완전 새출발. 경주에서 출발선을 긁고(scratch) 거기부터 라는데서 기원. 출발선은 모두에게 공평한 시작점이자, 아무것도 없는 새출발로 의미가 확장 되었다고."})]}),(0,s.jsxs)("section",{className:"mb-5",children:[(0,s.jsx)("div",{children:'나델라는 안일함을 극복하기 위해, "성장 마인드셋", "비판에서 배울것"을 화이트보드에 적어두었습니다.'}),(0,s.jsx)("div",{children:"마이크로 소프트는 마침내 Azure 같은 소프트웨어를 개발했고, 현재 Apple과 나란히 할 만큼 성장했습니다."}),(0,s.jsx)("div",{children:"몇가지 전략적 투자(GitHub, LinkedIn, OpenAI)를 통해 다시 중요한 기업으로 자리했습니다."}),(0,s.jsx)(c.A,{text:"Satya Nadella - MS 최고경영자. MS에 돈과 인재가 가득하다고 해서, 혁신이 뚝딱 하고 쉽게 달성된게 아니었던듯."})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{className:"font-bold",children:'필립 콜라도는 리더에게 가장 중요한 것은 겸손과 긍적적인 태도로 사람들이 "현실을 직시"하게 돕는것이라 했습니다.'}),(0,s.jsx)("div",{children:"오바산조가 마이크로소프트에서 일하며 얻은 교훈은 일과 생활 모두에 적용 가능할 것 같습니다."}),(0,s.jsx)("div",{className:"mt-5",children:"끊임없이 배우려는 사람(learn-it-all)이 되는것이,"}),(0,s.jsx)("div",{children:"모든 것을 안다고 하는 사람(know-it-all)보다 멀리 나아가게 할 거라는 거죠."}),(0,s.jsx)(c.A,{text:"primary takeaway - 가장 큰 교훈"})]})]})}},2703:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>j});var s=t(5155),r=t(2115);let a=JSON.parse('{"비견":"자기주장이 강하고 독립적인 성향을 가짐. 형제, 동업자 등을 의미할 수도 있음.","겁재":"경쟁자, 형제, 동료 등과의 관계를 나타내며, 재물이나 기회를 나눠야 하는 상황을 의미.","식신":"창의력과 표현력이 뛰어나며, 안정적이고 여유로운 삶을 추구하는 성향을 가짐.","상관":"자유롭고 독립적인 사고방식을 지니며, 전통적 권위와 대립하는 경향이 있음.","편재":"도전적인 삶을 좋아하고, 사업적 감각이 뛰어나며 변동성이 큰 재물운을 가짐.","정재":"성실하고 신뢰를 바탕으로 한 재물운을 가짐. 안정적인 수입을 중시함.","편관":"도전적이고 강인한 성격을 가지며, 리더십과 결단력이 뛰어남.","정관":"규율과 도덕을 중시하며, 조직 내에서의 명예와 책임감을 중요하게 여김.","편인":"지혜롭고 분석력이 뛰어나며, 신비로운 것에 관심이 많음. 때때로 고독한 성향이 나타남.","정인":"온화하고 배려심이 깊으며, 학문과 교육에 관심이 많음."}'),i=["갑","을","병","정","무","기","경","신","임","계"],o=["자","축","인","묘","진","사","오","미","신","유","술","해"],l={갑:"목",을:"목",병:"화",정:"화",무:"토",기:"토",경:"금",신:"금",임:"수",계:"수"},c={비견:[0,5],겁재:[1,6],식신:[2,7],상관:[3,8],편재:[4,9],정재:[5,0],편관:[6,1],정관:[7,2],편인:[8,3],정인:[9,4]};function d(e,n){let t=i.indexOf(e);return n.map(e=>{let n=i.indexOf(e);return Object.keys(c).find(e=>c[e].includes((n-t+10)%10))})}var h=t(4519),p=t.n(h),x=t(908),u=t(2626),m=t.n(u);function j(){let[e,n]=(0,r.useState)(""),[t,c]=(0,r.useState)(""),[h,u]=(0,r.useState)(""),[j,g]=(0,r.useState)("12"),[b,v]=(0,r.useState)("male"),[f,y]=(0,r.useState)("solar"),[w,S]=(0,r.useState)(null),[N,A]=(0,r.useState)(null),[k,T]=(0,r.useState)(""),M=()=>{let n=Number(e),s=Number(t),r=Number(h),a=Number(j);if(!e||!t||!h)return T("출생 연도, 월, 일은 필수 입력값입니다."),!1;if(s<1||s>12)return T("월은 1에서 12 사이의 값만 입력할 수 있습니다."),!1;let i=new Date(n,s,0).getDate();return r<1||r>i?(T("선택한 월(".concat(s,"월)에 맞는 1~").concat(i,"일을 입력하세요.")),!1):a<0||a>23?(T("시간은 0에서 23 사이의 값만 입력할 수 있습니다."),!1):(T(""),!0)},C=s=>{if(s===f)return;let r=null;if(!(r="lunar"===s?p().solar2lunar(Number(e),Number(t),Number(h)):p().lunar2solar(Number(e),Number(t),Number(h),!1))||!r.lYear||!r.lMonth||!r.lDay){T("⚠️ 날짜 변환 실패: 입력값을 확인하세요.");return}"lunar"===s?(n(r.lYear.toString()),c(r.lMonth.toString()),u(r.lDay.toString())):(n(r.cYear.toString()),c(r.cMonth.toString()),u(r.cDay.toString())),y(s),T("")},I=async()=>{if(!M())return;T("");let n=Number(e),s=Number(t),r=Number(h);if("solar"===f){let e=p().solar2lunar(n,s,r);if(!e){T("음력 변환에 실패했습니다. 날짜를 확인하세요.");return}n=e.lYear,s=e.lMonth,r=e.lDay}A(n),S(function(e,n,t,s,r){let c=function(e){let n=i[(e-4)%10],t=o[(e-4)%12];return"".concat(n).concat(t)}(e),h="".concat(i[((e-4)%10*2+n)%10]).concat(o[(n+1)%12]),p=function(e,n,t){let s=new Date(1900,0,31),r=Math.floor((new Date(e,n-1,t)-s)/864e5),a=i[(r+9)%10],l=o[(r+1)%12];return"".concat(a).concat(l)}(e,n,t),x=function(e,n){let t=(2*i.indexOf(e)+Math.floor(n/2))%10,s=Math.floor(n/2)%12;return"".concat(i[t]).concat(["자","축","인","묘","진","사","오","미","신","유","술","해"][s])}(p[0],s),u=d(p[0],[c[0],h[0],p[0],x[0]]),m=function(e){let n={목:0,화:0,토:0,금:0,수:0};return e.forEach(e=>{l[e]&&(n[l[e]]+=1)}),n}([c[0],h[0],p[0],x[0]]);return{yearPillar:c,monthPillar:h,dayPillar:p,hourPillar:x,fortune:function(e,n,t){let s=10-(e%2==0?e+1:e)%10,r=[],a=(e-4)%10;for(let e=0;e<8;e++){let n=s+10*e,t=i[(a+e)%10],o=l[t],c=d(void 0,[t])[0],h={비견:"경쟁 증가, 독립심 강화",겁재:"경쟁심 강화, 동료와의 갈등 가능",식신:"창의력 상승, 여유로움 증가",상관:"자유로운 변화, 제약 감소",편재:"재물운 상승, 사업 기회 증가",정재:"성실한 재물운, 안정적인 수익",편관:"책임 증가, 리더십 기회",정관:"권위 상승, 사회적 신뢰 증가",편인:"직관력 상승, 학문적 성취",정인:"학습, 지식 탐구, 성장의 시기"};r.push({age:n,description:"".concat(o,"의 운 (").concat(t," - ").concat(o,") → ").concat(c," (").concat(h[c],")")})}return"male"===n?r:r.reverse()}(e,r),sajuTerms:a,tenGods:u,fiveElements:Object.entries(m).map(e=>{let[n,t]=e;return"".concat(n,"(").concat(t,")")}).join(" "),fiveElementsPerPillar:[l[c[0]],l[h[0]],l[p[0]],l[x[0]]]}}(n,s,r,Number(j),b))};return(0,s.jsxs)("div",{className:"".concat(m().container," w-full max-w-screen-lg px-4 lg:px-8"),children:[(0,s.jsx)(x.A,{text:"2024.03.04"}),(0,s.jsxs)("section",{className:m().paragraph,children:["지인과 사주관련 대화를 하고 나서. 재미로. ",(0,s.jsx)("br",{}),"연,월,일,시를 입력하고 계산버튼을 클릭. ",(0,s.jsx)("br",{}),"Git블로그의 매력은 이렇게 직접 입력하는 화면을 만들 수 있다는게 아닐까."]}),(0,s.jsx)(x.A,{}),(0,s.jsxs)("section",{className:"bg-white shadow-lg rounded-lg p-6 w-full",children:[(0,s.jsx)("h1",{className:"text-2xl font-bold text-center mb-4",children:"사주 계산기"}),k&&(0,s.jsx)("p",{className:"text-red-600 font-bold text-center mb-4",children:k}),(0,s.jsxs)("div",{className:"grid grid-cols-2 lg:grid-cols-4 gap-4",children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("label",{className:"text-lg font-bold",children:"출생 연도"}),(0,s.jsx)("input",{type:"number",className:"border p-2 rounded-md w-full",value:e,onChange:e=>n(e.target.value)})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("label",{className:"text-lg font-bold",children:"월"}),(0,s.jsx)("input",{type:"number",className:"border p-2 rounded-md w-full",value:t,onChange:e=>c(e.target.value)})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("label",{className:"text-lg font-bold",children:"일"}),(0,s.jsx)("input",{type:"number",className:"border p-2 rounded-md w-full",value:h,onChange:e=>u(e.target.value)})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("label",{className:"text-lg font-bold",children:"시간 (0~23)"}),(0,s.jsx)("input",{type:"number",className:"border p-2 rounded-md w-full",value:j,onChange:e=>g(e.target.value)})]})]}),(0,s.jsxs)("div",{className:"flex items-center gap-2 mt-3",children:[(0,s.jsxs)("div",{className:"flex gap-1",children:[(0,s.jsx)("button",{className:"px-4 py-2 rounded-md border ".concat("solar"===f?"bg-blue-500 text-white":"bg-gray-200"),onClick:()=>C("solar"),children:"양력"}),(0,s.jsx)("button",{className:"px-4 py-2 rounded-md border ".concat("lunar"===f?"bg-blue-500 text-white":"bg-gray-200"),onClick:()=>C("lunar"),children:"음력"})]}),(0,s.jsxs)("select",{className:"border p-2 rounded-md",value:b,onChange:e=>v(e.target.value),children:[(0,s.jsx)("option",{value:"male",children:"남성"}),(0,s.jsx)("option",{value:"female",children:"여성"})]})]}),(0,s.jsx)("button",{onClick:I,className:"w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md mt-4",children:"사주 계산"})]}),(0,s.jsx)("section",{className:"mt-5",children:w&&(0,s.jsxs)("div",{className:"bg-white shadow-lg rounded-lg p-6 w-full max-w-screen-lg",children:[(0,s.jsx)("h2",{className:"text-xl font-bold border-b pb-2 mb-4",children:"결과"}),(0,s.jsx)("div",{className:"grid grid-cols-2 lg:grid-cols-4 gap-4 text-gray-800",children:["yearPillar","monthPillar","dayPillar","hourPillar"].map((e,n)=>{var t,r;return(0,s.jsxs)("div",{children:[(0,s.jsx)("p",{className:"text-lg font-bold",children:["연주","월주","일주","시주"][n]}),(0,s.jsxs)("p",{className:"border p-2 rounded-md bg-gray-100",children:[w[e]," ",(null===(t=w.tenGods)||void 0===t?void 0:t[n])&&"(".concat(w.tenGods[n],")")," ",(null===(r=w.fiveElementsPerPillar)||void 0===r?void 0:r[n])&&"[".concat(w.fiveElementsPerPillar[n],"]")]})]},e)})}),(0,s.jsx)("h2",{className:"text-xl font-bold border-b pb-2 mt-4",children:"오행 분석"}),(0,s.jsx)("div",{className:"flex flex-wrap gap-2 mt-2",children:w.fiveElements.split(" ").map((e,n)=>{let[t,r]=e.match(/(\D+)\((\d+)\)/).slice(1);return(0,s.jsxs)("span",{className:"px-3 py-1 border rounded-lg font-semibold ".concat({목:"bg-green-100 text-green-700 border-green-400",화:"bg-red-100 text-red-700 border-red-400",토:"bg-yellow-100 text-yellow-700 border-yellow-400",금:"bg-gray-100 text-gray-700 border-gray-400",수:"bg-blue-100 text-blue-700 border-blue-400"}[t]),children:[t," (",r,")"]},n)})}),(0,s.jsx)("h2",{className:"text-xl font-bold border-b pb-2 mt-4",children:"대운"}),(0,s.jsx)("p",{className:"text-gray-600 text-sm mt-1",children:"대운이란 10년 주기로 변하는 운세의 흐름을 의미합니다."}),(0,s.jsx)("div",{className:"grid grid-cols-1 sm:grid-cols-2 gap-3 mt-2",children:w.fortune.map((e,n)=>{let t=N?N+e.age:"N/A";return(0,s.jsxs)("div",{className:"p-3 border rounded-lg bg-gray-50 shadow-sm",children:[(0,s.jsxs)("p",{className:"font-semibold text-lg",children:[e.age,"세"," ",(0,s.jsxs)("span",{className:"text-gray-500",children:["(",t,"년)"]})]}),(0,s.jsx)("p",{className:"text-gray-700",children:e.description})]},n)})}),(0,s.jsx)("h2",{className:"text-xl font-bold border-b pb-2 mt-4",children:"사주 설명"}),(0,s.jsxs)("ul",{className:"mt-2 space-y-1 text-gray-700",children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"연주:"})," 출생 시점의 사회적 배경 및 조상운"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"월주:"})," 부모와의 관계, 직업적 성향"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"일주:"})," 개인 성격 및 배우자 운"]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"시주:"})," 말년운, 자식운, 생각의 방향"]})]}),(0,s.jsx)("h2",{className:"text-xl font-bold border-b pb-2 mt-4",children:"오행 설명"}),(0,s.jsxs)("ul",{className:"mt-2 space-y-1 text-gray-700",children:[(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"목(木):"})," 성장을 의미하며, 창의성과 인내력이 강한 특성을 가짐."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"화(火):"})," 활발하고 열정적이며, 추진력과 변화를 상징."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"토(土):"})," 균형과 안정, 신뢰감을 나타내며, 중재자의 역할을 함."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"금(金):"})," 결단력이 강하고 강한 의지를 지니며, 금전운과 관련됨."]}),(0,s.jsxs)("li",{children:[(0,s.jsx)("strong",{children:"수(水):"})," 지혜와 감성, 사고의 깊이를 의미하며, 유연한 성격을 가짐."]})]}),(0,s.jsx)("h2",{className:"text-xl font-bold border-b pb-2 mt-4",children:"사주 용어"}),(0,s.jsx)("ul",{className:"mt-2 space-y-1",children:Object.entries(w.sajuTerms).map(e=>{let[n,t]=e;return(0,s.jsxs)("li",{className:"text-gray-700",children:[(0,s.jsxs)("strong",{children:[n,":"]})," ",t]},n)})})]})})]})}},1128:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>d});var s=t(5155),r=t(2761),a=t(6167),i=t(2139),o=t(908),l=t(2626),c=t.n(l);function d(){return(0,s.jsxs)("div",{className:c().container,children:[(0,s.jsx)(r.A,{text:"The 5-Second Conversation Hack That Makes People Instantly Like You"}),(0,s.jsx)(a.A,{href:"https://medium.com/hello-love/the-5-second-conversation-hack-that-makes-people-instantly-like-you-6591c9a06690",prefix:"Medium",text:"https://medium.com/hello-love/the-5-second-conversation-hack-that-makes-people-instantly-like-you-6591c9a06690"}),(0,s.jsx)(o.A,{text:"2025.04.09"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"번역이 틀릴 수 있습니다."}),(0,s.jsx)("div",{children:"남들이 즉시 좋아하거나 동일한 일에도 호의적으로 대하는건 아무리 봐도, 그냥 예쁘고 잘생기면... 퍽퍽."}),(0,s.jsx)("div",{children:"요즘 일하고 있는 유비케어 프로젝트는 야근이 많습니다. 힘들면 자연스레 사람들의 스트레스가 쌓이고 그러면 말이나 태도도 거칠어지게 마련이죠. 그럴땐 한번 쯤 떠올려 보는것도."})]}),(0,s.jsx)(o.A,{}),(0,s.jsx)(r.A,{text:"당신을 즉시 좋아하게 만드는 5초 대화 비법"}),(0,s.jsx)(i.A,{type:"h2",text:"사회심리학자들의 쉽게 소통하는 비밀"}),(0,s.jsx)(i.A,{type:"h3",text:"5초만에 그들의 감정에 닻을 내린다."}),(0,s.jsxs)("section",{children:["What It Is: ",(0,s.jsx)("br",{}),"Use a micro-observation + light vulnerability to spark instant rapport."," ",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"어떤 것인가:",(0,s.jsx)("br",{}),"가벼운 관계에 불꽃을 튀게 하기 위해, 미시적인 관찰과 작은 취약성을 사용하기",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Why It Works:",(0,s.jsx)("br",{}),"1. Dale Carnegie Principle: People crave feeling interesting, not impressed.",(0,s.jsx)("br",{}),"2. Neuroscience: Vulnerability triggers oxytocin (the “bonding hormone”) in both parties.",(0,s.jsx)("br",{}),"3. Speed: First impressions form in 7 seconds — this hack front-loads connection.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"왜 되는거:",(0,s.jsx)("br",{}),"1. 데일카네기 원칙: 사람들은 감동적인 것 보다 흥미로운 것을 갈망한다.",(0,s.jsx)("br",{}),"2. 인지신경학: 취약성은 양 당사자의 옥시토신(관계 호르몬)을 분비시킨다.",(0,s.jsx)("br",{}),"3. 스피드: 7초 이내의 첫인상 - 첫 관계형성의 핵심.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Formula:",(0,s.jsx)("br",{}),"“[Specific observation about them/context] + [Playful self-disclosure]”",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"원칙:",(0,s.jsx)("br",{}),"그들/환경에 대한 구체적 관찰 + 장난스러운 자기 소개",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Real-Life Examples",(0,s.jsx)("br",{}),"실생활의 예시",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"1. At a Work Event",(0,s.jsx)("br",{}),"Them: Standing alone, checking their phone.",(0,s.jsx)("br",{}),"You: “I’ve been staring at the snack table for 10 minutes — debating if pineapple belongs on pizza.",(0,s.jsx)("br",{}),"What’s your controversial food take?”",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"1. 일터에서",(0,s.jsx)("br",{}),"그들: 혼자있고, 휴대폰을 보고있다.",(0,s.jsx)("br",{}),"당신: 10분간 스낵테이블을 봤다. - 피자에 파인애플을 올리는데 대한 토론.",(0,s.jsx)("br",{}),"당신에게 논란인 음식은 뭐죠?",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Why it works:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Observation: Notices their isolation (without judgment).",(0,s.jsx)("br",{}),"Vulnerability: Admits awkwardness.",(0,s.jsx)("br",{}),"Invites play: Sparks a low-stakes debate.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"이게 왜 됨:",(0,s.jsx)("br",{}),"관찰: 그들이 고립되어있다. (판단하지 않기)",(0,s.jsx)("br",{}),"취약성: 어색함을 인정한다.",(0,s.jsx)("br",{}),"놀이에 초대: 낮은 수준의 논쟁을 불러일으키기.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"2. On a First Date",(0,s.jsx)("br",{}),"Them: Wearing a band T-shirt.",(0,s.jsx)("br",{}),"You: “I see your [band name] shirt — I saw them live once and cried during the ballad. No shame.”",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"2. 첫 데이트",(0,s.jsx)("br",{}),"상대: 밴드의 티쳐츠를 입었다.",(0,s.jsx)("br",{}),"당신: 당신의 oo셔츠 알아요 - 난 그들의 라이브를 본적이 있어요. 발라드를 부를때 울었어요. 부끄럽지 않았습니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Why it works:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Shows attention: Proves you noticed details.",(0,s.jsx)("br",{}),"Shared humanity: Embarrassing stories = instant relatability.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"왜 됨:",(0,s.jsx)("br",{}),"집중하고 있음을 보여줌: 당신이 세세한 것을 알아차렸음을 증명함.",(0,s.jsx)("br",{}),"인간적임을 공유: 난처했던 이야기 = 즉각적인 관계.",(0,s.jsx)("br",{}),"MY NOTE - 깊지 않은 약점을 보여주라는 의미 같음.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"3. With a Stranger",(0,s.jsx)("br",{}),"Them: Waiting in line, sighing impatiently.",(0,s.jsx)("br",{}),"You: “If this line takes longer, I might start singing show tunes. Fair warning.”",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"3. 낮선사람과",(0,s.jsx)("br",{}),"상대: 줄을 서서 기다리며, 지루함에 한숨.",(0,s.jsx)("br",{}),"당신: 만약에 더 기다리게 되면, 노래를 시작해야할 때. 공정한 경고죠.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Why it works:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Mirrors their emotion (frustration) → validation.",(0,s.jsx)("br",{}),"Humor disarms: Signals you’re safe to engage with.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"왜 됨:",(0,s.jsx)("br",{}),"그들의 감정을 복사한다 (좌절) -> 인정.",(0,s.jsx)("br",{}),"무장해제 유머: 당신이 함께하고 있다는 신호를 보낸다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"지금까지의 요약.",(0,s.jsx)("br",{}),"적절한 타이밍에, 낮은 수준의 논쟁을 함께 한다.",(0,s.jsx)("br",{}),"사소한것도 알아차린다는 점을 통해 간접적으로 관심이 있음을 드러내고,",(0,s.jsx)("br",{}),"낮은 수준의 약점을 보여줘라.",(0,s.jsx)("br",{}),"상대와 감정을 공유해주고, 당신이 함께라는 신호를 유머있게 전달해라.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"The Science of Speed-Connection",(0,s.jsx)("br",{}),"The “Halo Effect”: A positive first impression makes people overlook later flaws.",(0,s.jsx)("br",{}),"Nonverbal Syncing: Matching their tone/energy in 5 seconds builds subconscious trust.",(0,s.jsx)("br",{}),"The 55–38–7 Rule: 55% of likability comes from body language, 38% from tone, and 7% from words.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"빠른 관계의 과학",(0,s.jsx)("br",{}),'"헬로 효과": 긍정적인 첫인상은 나중의 흠을 넘어가게 해준다.',(0,s.jsx)("br",{}),"비 언어적 동기화: 그들의 톤과 에너지에 5초간 맞춰주면 잠재의식에 신뢰가 생긴다.",(0,s.jsx)("br",{}),"55-38-7법칙: 호감의 55%는 바디랭기지에서 38%는 톤에서 7%는 말에서 온다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Pro Tip: Pair your verbal hack with:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Open posture (uncrossed arms)",(0,s.jsx)("br",{}),"Warm vocal tone (slightly lower pitch)",(0,s.jsx)("br",{}),"Micro-smile (eyes crinkle, not just lips)",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"프로의 조언: 당신의 말에 이것들을 곁들여라:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"열린 자세 (팔짱 끼지마세요)",(0,s.jsx)("br",{}),"따듯한 말투 (흥분하지 않은)",(0,s.jsx)("br",{}),"작은 미소 (눈으로, 입 말고)",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"When to Use It (and When to Avoid)",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Best For:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Networking events, dates, and meetings with strangers.",(0,s.jsx)("br",{}),"Breaking tension in awkward silences.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Avoid:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Crises (e.g., someone’s upset).",(0,s.jsx)("br",{}),"Formal settings require strict professionalism.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"언제 활용 할까 (언제 피해야 할까)",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"가장 좋은때:",(0,s.jsx)("br",{}),"소통의 이벤트때, 데이트, 낯선이와의 회의.",(0,s.jsx)("br",{}),"어색한 침묵을 깰때.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"피해야 할 때:",(0,s.jsx)("br",{}),"위기때 (예, 누군가 화남)",(0,s.jsx)("br",{}),"엄격한 전문성이 느껴지는 격식이 있어야 할 자리.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Your 24-Hr Challenge",(0,s.jsx)("br",{}),"Pick 3 interactions today (barista, coworker, friend).",(0,s.jsx)("br",{}),"Use the formula: Observation + light vulnerability.",(0,s.jsx)("br",{}),"Note their reaction: Did they smile longer? Engage more?",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"24시간 도전",(0,s.jsx)("br",{}),"바리스타, 동료, 친구에게 3번 해보세요.",(0,s.jsx)("br",{}),"원칙을 사용해요: 관찰 + 작은 취약성.",(0,s.jsx)("br",{}),"반응을 기억하세요: 얼마나 웃었는지? 더 좋아졌는지?",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"“But I’m introverted!” → Start with low-risk people",(0,s.jsx)("br",{}),"(e.g., grocery cashier: “I’ve bought so much ice cream, you’re my witness now.”).",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"하지만 난 내향인이라고! -> 위험이 적은 사람들로 시작하세요.",(0,s.jsx)("br",{}),"(예, 식료품점 캐셔: 아이스크림을 많이 샀었죠, 당신이 증인입니다.)",(0,s.jsx)("br",{})]})]})}},2734:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>m});var s=t(5155),r=t(910),a=t.n(r);t(8452);var i=t(2115),o=t(2761),l=t(6529),c=t(2139),d=t(6167),h=t(908),p=t(9969),x=t(2626),u=t.n(x);function m(){return(0,i.useEffect)(()=>{a().highlightAll()},[]),(0,s.jsxs)("div",{className:u().container,children:[(0,s.jsx)(o.A,{text:"Say Goodbye to JavaScript’s Date. Meet the Powerful New Temporal API"}),(0,s.jsx)(d.A,{href:"https://medium.com/javascript-in-plain-english/say-goodbye-to-javascripts-date-woes-meet-the-powerful-new-temporal-api-73f99c8823e0",prefix:"Medium",text:"Say Goodbye to JavaScript’s Date. Meet the Powerful New Temporal API"}),(0,s.jsx)(h.A,{text:"2024.12.31"}),(0,s.jsx)("section",{className:u().paragraph,children:(0,s.jsxs)("div",{children:["원문을 읽고 요약한 글입니다. 당연히, ",(0,s.jsx)("strong",{children:"번역, 주석 등에 오류가 있을 확률 57,000%."}),(0,s.jsx)("br",{}),"반박시 무조건 제가 틀렸습니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Temporal은 현재 ECMAScript 사양의 Stage 3 단계로, 최종적으로 Stage 4에 도달하면 JavaScript의 표준으로 채택됩니다. Stage 3은 대부분의 기능이 안정화되었고, 구체적인 구현 세부사항을 다듬는 단계입니다."]})}),(0,s.jsx)(h.A,{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{className:"text-gray-500 text-2xl font-bold",children:"변덕쟁이 Date 객체와 싸우는데 지치셨죠?"}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"Date는 초기부터 있었습니다. 시간대 처리, 서머타임 조정, 특이한 API 설계로 수많은 개발자들을 좌절하게 했습니다."}),(0,s.jsx)("div",{children:"이제 대안이 생겼습니다."})]}),(0,s.jsx)(l.A,{text:"왜 Temporal? Date의 한계를 알아보기"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"Time Zone Troubles : 다양한 시간대를 처리해야 할때 거지같음."}),(0,s.jsx)("li",{children:"Mutability Issues: Date가 가변적이라서 코드의 조그만 변경에도 사이드 이팩트가 날 수 있음."}),(0,s.jsx)("li",{children:"Quirky Month Indexing: 월이 0부터 시작해서 자주 함정에 빠뜨림."}),(0,s.jsx)("li",{children:"Limited Precision: 정밀하지 않음. 번거롭고 오류가 발생하기 쉬움."})]})}),(0,s.jsx)(l.A,{text:"The Temporal Basics: 끝내주는 녀석들"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"Temporal.PlainDate"}),(0,s.jsx)("li",{children:"Temporal.PlainTime"}),(0,s.jsx)("li",{children:"Temporal.PlainDateTime"}),(0,s.jsx)("li",{children:"Temporal.ZonedDateTime"}),(0,s.jsx)("li",{children:"Temporal.Duration"})]})}),(0,s.jsx)(h.A,{}),(0,s.jsx)(l.A,{text:"써봅시다."}),(0,s.jsx)(c.A,{text:"날짜 생성"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"const date = Temporal.PlainDate.from('2024-10-11');\nconsole.log(date.toString()); // Output: 2024-10-11"})}),(0,s.jsx)(c.A,{text:"날짜 추가"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"const today = Temporal.PlainDate.from('2024-10-11');\nconst tomorrow = today.add({ days: 1 });\nconsole.log(tomorrow.toString()); // Output: 2024-10-12"})}),(0,s.jsx)(c.A,{text:"타임존"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"const zonedDateTime = Temporal.ZonedDateTime.from({\n  timeZone: 'America/New_York',\n  year: 2024,\n  month: 10,\n  day: 11,\n  hour: 12,\n});\nconsole.log(zonedDateTime.toString()); // Output includes the time zone"})}),(0,s.jsx)(c.A,{text:"쉬운 날짜 계산"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"const start = Temporal.PlainDateTime.from('2024-10-11T12:00');\nconst end = Temporal.PlainDateTime.from('2024-10-11T15:30');\nconst duration = end.since(start);\nconsole.log(duration.toString()); // Output: PT3H30M (3 hours, 30 minutes)"})}),(0,s.jsx)(l.A,{text:"실제 활용 예시"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-disc ml-5",children:[(0,s.jsx)("li",{children:"국제적 앱 - 유저별 시간대 관리 용이"}),(0,s.jsx)("li",{children:"스케쥴 관리 - 예약자별 시간대 관리도 용이"}),(0,s.jsx)("li",{children:"보고서 같은데서 시간 계산 좋음."})]})}),(0,s.jsx)(h.A,{}),(0,s.jsx)(l.A,{text:"Temporal API가 지원되는 플랫폼과 브라우저"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"아직 공식은 아닙니다. 하지만 곧 옵니다."}),(0,s.jsxs)("ul",{className:"list-disc ml-5",children:[(0,s.jsx)("li",{children:"브라우저: 크롬과 파이어폭스 최신 버전은 실험적 지원을 제공합니다."}),(0,s.jsx)("li",{children:"Node.js: 향후 제공할 것으로 예상됩니다."}),(0,s.jsx)("li",{children:"폴리필 사용: 지원하지 않는 환경을 위해 폴리필을 제공하고 있습니다. 즉, 사용해 볼 수 있어요."})]})]}),(0,s.jsx)("br",{}),(0,s.jsx)(p.A,{text:"Polyfill - 기존 기능을 사용하여 아직 지원하지 않는 기능을 구현하도록 하는 코드. 즉, 하위 호환을 위한 도구."}),(0,s.jsx)("br",{}),(0,s.jsx)(l.A,{text:"향후, Javascript가 날짜와 시간을 다루는 법."}),(0,s.jsx)("section",{children:"Temporal은 유연함과 신뢰성을 제공합니다. Temporal인거죠!"})]})}},5538:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>u});var s=t(5155),r=t(910),a=t.n(r);t(8452);var i=t(2115),o=t(2761),l=t(6529),c=t(2139),d=t(6167),h=t(908),p=t(2626),x=t.n(p);function u(){return(0,i.useEffect)(()=>{a().highlightAll()},[]),(0,s.jsxs)("div",{className:x().container,children:[(0,s.jsx)(o.A,{text:"This new JavaScript operator is an absolute game changer"}),(0,s.jsx)(d.A,{href:"https://medium.com/coding-beauty/new-javascript-operator-1e60dea05654",prefix:"Medium",text:"This new JavaScript operator is an absolute game changer"}),(0,s.jsx)(h.A,{text:"2024.12.31"}),(0,s.jsxs)("section",{className:x().paragraph,children:[(0,s.jsxs)("div",{children:["원문을 읽고 요약한 글이며, 당연히, ",(0,s.jsx)("strong",{children:"번역에 오류가 있을 수 있습니다."})," 반박시 당신이 옳습니다."]}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:'?=은 "안전 할당 연산자"라고 하는데, 아직 공식 사양에 포함되지 않았습니다.'}),(0,s.jsx)(d.A,{href:"https://github.com/arthurfiorette/proposal-safe-assignment-operator",prefix:"GitHub",title:"참조",text:"ECMAScript Safe Assignment Operator Proposal"})]}),(0,s.jsx)(h.A,{}),(0,s.jsx)(l.A,{text:"No more try-catch"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"\nasync function name(params) {\n  const [err, res] ?= await fetch('https://codingbeatydev.com');\n  if (err) return console.error(err);\n\n  const [parseError, data] ?= await res.json();\n  if (parseError) return console.log(parseError);\n\n  return data;\n}"})}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"우리는, 이제 깊은 중첩에서 벗어날 수 있다."}),(0,s.jsx)("div",{children:"에러에게 이제 닥치라 하고, 선택하는 것이 가능해졌다."})]}),(0,s.jsx)(c.A,{text:"성공 실패의 상태값이 재할당 되는것이 필요할 때, const를 사용하지 못했지만 이제 그것도 안녕이다."}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"\nfunction writeTransactionToFile(transactions) {\n  const [err, res] ?= fs.writeFileSync('sample.com.txt', transactions);\n  const writeStatus = err ? 'error' : 'success';\n}"})}),(0,s.jsx)(c.A,{text:"어떻게 동작하나?"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"?= 연산자는 내부적으로 Symbol.result를 사용한다."}),(0,s.jsx)("div",{children:"심볼은 어떤 값이 되돌아 오든 일단 작동시킬 수 있다."}),(0,s.jsx)("div",{children:"타입스크립트에서도 사용이 가능하다."})]})]})}},807:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>x});var s=t(5155);t(8452);var r=t(2115),a=t(2761),i=t(6529),o=t(6167),l=t(2101),c=t(908),d=t(9969),h=t(2626),p=t.n(h);function x(){return(0,r.useEffect)(()=>{if(!customElements.get("notification-badge")){class e extends HTMLElement{static get observedAttributes(){return["count"]}attributeChangedCallback(e,n,t){"count"===e&&this.badge&&(this.badge.textContent=t)}connectedCallback(){this.addEventListener("increment",()=>{let e=parseInt(this.getAttribute("count")||"0")+1;this.setAttribute("count",e.toString())}),this.addEventListener("decrement",()=>{let e=Math.max(0,parseInt(this.getAttribute("count")||"0")-1);this.setAttribute("count",e.toString())})}constructor(){super(),this.attachShadow({mode:"open"}),this.badge=document.createElement("span"),this.badge.classList.add("badge"),this.badge.textContent=this.getAttribute("count")||"0";let e=document.createElement("style");e.textContent="\n          .badge {\n            background: red;\n            color: white;\n            padding: 5px 10px;\n            border-radius: 12px;\n            font-size: 12px;\n            display: inline-block;\n          }\n        ",this.shadowRoot.appendChild(e),this.shadowRoot.appendChild(this.badge)}}customElements.define("notification-badge",e)}},[]),(0,s.jsxs)("div",{className:p().container,children:[(0,s.jsx)(a.A,{text:"Web Components Will Kill JavaScript Frameworks (Eventually)"}),(0,s.jsx)(o.A,{href:"https://javascript.plainenglish.io/web-components-will-kill-javascript-frameworks-eventually-c8ea56222e7b",prefix:"Medium",text:"Web Components Will Kill JavaScript Frameworks (Eventually)"}),(0,s.jsx)(c.A,{text:"2024.12.31"}),(0,s.jsx)("section",{className:p().paragraph,children:(0,s.jsxs)("div",{children:["원문을 읽고 요약한 글이며, 당연히,"," ",(0,s.jsx)("strong",{children:"번역, 주석 등에 오류가 있을 확률 58,000%."}),(0,s.jsx)("br",{}),"반박시 무조건 당신이 옳습니다."]})}),(0,s.jsx)(c.A,{}),(0,s.jsxs)("section",{children:[(0,s.jsxs)("div",{children:["2025년, 새 웹 앱을 만들려고 할 때, 거의 무의식적으로 프레임웤을 선택하려고 할 겁니다.",(0,s.jsx)("br",{})," - React, Vue, Angular, Svelte."]}),(0,s.jsx)("br",{}),(0,s.jsxs)("div",{children:["하지만, 수 천 줄의 다른 사람 코드를 끌어오지 않고,"," ",(0,s.jsx)("strong",{children:"순수 자바스크립트"}),"와 ",(0,s.jsx)("strong",{children:"웹 콤포넌트"}),"로 원하는걸 다할 수 있다면요?"," "]}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"의존성도, 락인(lock-in)도 없고, 가상 DOM의 오버헤드도 없는 - 완전 순수, 브라우저 본연의 힘으로."}),(0,s.jsx)("div",{children:"그런데, 이게 허황된 꿈이 아니면요?!"}),(0,s.jsx)("br",{}),(0,s.jsx)(d.A,{text:"lock-in: 개발 결과물이 프레임웤, 라이브러리, 생태계 등에 종속성이 커지고 나아가 만들어진 앱이 브라우저에 대한 비호환성이 증가하는 현상."})]}),(0,s.jsx)(i.A,{text:"Frameworks: 양날의 검"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"물론 장점들이 많지만, 단점이 없는게 아닙니다."}),(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"프레임웤 락인: React를 Vue로 바꾸고 싶어요? 처음 부터 다 다시 만드세요."}),(0,s.jsx)("li",{children:"성능 오버헤드: 추상화는 앱이 작을때 문제 없지만, 규모가 커진다면? 그 차이가 쌓여 성능에 영향을 줄겁니다."}),(0,s.jsx)("li",{children:"의존성 증가: 프레임웤 업데이트는 앱을 망가뜨릴 위험을 내재하고 있습니다. 프레임웤 유지보수자들이 호환이 잘 되도록 해주기만을 바래야 할거고요."}),(0,s.jsx)("li",{children:"러닝커브: 개발자들에게 종종 프레임웤의 특징에 시간을 쓰게 만들고, JavaScript의 기본을 소흘히 하게 합니다."})]})]}),(0,s.jsx)(i.A,{text:"Pure JavaScript and Web Components"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"순수 스크립트는 사랑이죠. 아니면, 사랑과 증오거나."}),(0,s.jsx)("div",{children:"웹 컴포넌트와 짝을 이루면, 더 빠르고 재사용 가능하고, 비종속적인 그러니까 프레임웤에 종속되지 않는 컴포넌트가 됩니다."})]}),(0,s.jsx)(l.A,{codeType:"language-javascript",codeBlock:'const MyComponentProto = Object.create(HTMLElement.prototype);\n\n  MyComponentProto.connectedCallback = function () {\n    this.innerHTML = "<div>Hello, Web Components!</div>";\n  };\n\n  // 순수스크립트로 프레임웤에 비종속적인 컴포넌트를 만듬.\n  customElements.define("my-component", MyComponentProto.constructor);\n'}),(0,s.jsx)(i.A,{text:"Web Components가 뭔데?"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"사용자 정의 HTML 요소 입니다."}),(0,s.jsx)("div",{children:"브라우저가 지원하는 기본 기술로 스타일, 동작 등을 캡슐화하여 재사용 가능하게 만든 것입니다."}),(0,s.jsx)("br",{}),(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"Custom Elements"}),(0,s.jsx)("li",{children:"Shadow DOM: 스타일과 로직을 캡슐화 하여, 스크립트와 CSS의 누수를 방지합니다."}),(0,s.jsx)("li",{children:"HTML Templates: 재사용 가능하며 동적인 컨텐츠를 만들기도 좋습니다."})]}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"이것들을 통해, 현대적이고 모듈화된 UI를 프레임웤 없이 만들 수 있습니다."})]}),(0,s.jsx)("br",{}),(0,s.jsx)(d.A,{text:"CSS leakage: 특정 요소에 적용한 CSS가 다른 요소 까지 영향을 줌."}),(0,s.jsx)("br",{}),(0,s.jsx)(i.A,{text:"이들이 왜 게임체인저인가?"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"이 둘이 왜 판을 흔들수 있는가."}),(0,s.jsx)("br",{}),(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"Freedom from Frameworks: 이렇게 만든 컴포넌트들은 React환경이든 Vue, Angular 어디든 꼽으면 잘됩니다."}),(0,s.jsx)("li",{children:"Performance Boost: 버츄얼돔이 없으면 더 빠릅니다. 모바일 퍼스트라면 더더욱."}),(0,s.jsx)("li",{children:"Simpler Maintenance: 프레임웤의 버전과 같은 트렌드를 타지도 않을 것이고 시간이 지나도 바닐라 스크립트는 매우 견고한 코드로 남을것입니다."}),(0,s.jsx)("li",{children:"Focus on Fundamentals(기본에 충실하라): 스크립트 자체에 충실하면, 더 강하고 능숙한 개발자가 될 수 있습니다. 이건 현장에서 사용하는 프레임웤이 무엇이든 강력한 개발자로 존재할 수 있게 만듭니다."})]})]}),(0,s.jsx)("br",{}),(0,s.jsx)(i.A,{text:"그럼 Frameworks은 사라지나?"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:(0,s.jsx)("strong",{children:"아니요."})}),(0,s.jsx)("div",{children:"대규모 프로젝트 에서도, 프레임웤은 상태관리(state), 라우팅, 데이터 불러오기 등에서 강력한 기능을 제공합니다."}),(0,s.jsx)("div",{children:"하지만, 작은 규모에서 부터 몇몇 큰 프로젝트에서도 순수 스크립트는 새 애인감으로 곁눈질 하게 만들겁니다."})]}),(0,s.jsx)("br",{}),(0,s.jsx)(i.A,{text:"실제 예제"}),(0,s.jsx)(l.A,{codeType:"language-javascript",codeBlock:"class NotificationBadge extends HTMLElement {\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    // Create the badge\n    const badge = document.createElement('span');\n    badge.setAttribute('class', 'badge');\n    badge.textContent = this.getAttribute('count') || '0';\n\n    // Add styles\n    const style = document.createElement('style');\n    style.textContent = `\n      .badge {\n        background: red;\n        color: white;\n        padding: 5px 10px;\n        border-radius: 12px;\n        font-size: 12px;\n        display: inline-block;\n      }\n    `;\n\n    shadow.appendChild(style);\n    shadow.appendChild(badge);\n  }\n}\n\ncustomElements.define('notification-badge', NotificationBadge);\n"}),(0,s.jsxs)("section",{children:[(0,s.jsxs)("div",{children:["이제 ",'<notification-badge count="5"></notification-badge>',"는 앱 어디서든 쓸 수 있습니다."]}),(0,s.jsx)("div",{children:"count 변경이요? 네, 다이나믹 합니다."})]}),(0,s.jsx)("br",{}),(0,s.jsx)(d.A,{text:"개인적으로 class는 javaScript답지 못하며, class 기반 언어에서 건너온 개발자들에게 잘보이려고 속옷을 벗어다 바친, js 진영의 흑역사라 생각함."}),(0,s.jsx)("br",{}),(0,s.jsx)("notification-badge",{count:"5"}),(0,s.jsx)("button",{className:"bg-blue-500 text-white px-4 py-2 rounded-md shadow-md hover:bg-blue-600 active:bg-blue-700 ml-2 mb-2",onClick:()=>{document.querySelector("notification-badge").dispatchEvent(new Event("increment"))},children:"증가 click!! (+)"}),(0,s.jsx)(l.A,{codeType:"language-javascript",codeBlock:'useEffect(() => {\n    if (!customElements.get("notification-badge")) {\n      class NotificationBadge extends HTMLElement {\n        constructor() {\n          super();\n          this.attachShadow({ mode: "open" });\n\n          // Create the badge\n          this.badge = document.createElement("span");\n          this.badge.classList.add("badge");\n          this.badge.textContent = this.getAttribute("count") || "0";\n\n          // Add styles\n          const style = document.createElement("style");\n          style.textContent = `\n            .badge {\n              background: red;\n              color: white;\n              padding: 5px 10px;\n              border-radius: 12px;\n              font-size: 12px;\n              display: inline-block;\n            }\n          `;\n\n          this.shadowRoot.appendChild(style);\n          this.shadowRoot.appendChild(this.badge);\n        }\n\n        static get observedAttributes() {\n          // 속성이 바뀌면 감지 (브라우저에서 제공하는 Custom Elements API의 일부)\n          return ["count"];\n        }\n\n        attributeChangedCallback(name, oldValue, newValue) {\n          // 속성이 변경될 때 실행\n          if (name === "count" && this.badge) {\n            this.badge.textContent = newValue;\n          }\n        }\n\n        connectedCallback() {\n          // 컴포넌트가 DOM에 추가되었을 때 실행\n          this.addEventListener("increment", () => {\n            // 이게 싫어서. 양방향 변경이 좋아서, vue, react 쓰는거 아닙니꽈? 어뜨게 하라는 거야...\n            const newCount = parseInt(this.getAttribute("count") || "0") + 1;\n            this.setAttribute("count", newCount.toString());\n          });\n\n          this.addEventListener("decrement", () => {\n            const newCount = Math.max(\n              0,\n              parseInt(this.getAttribute("count") || "0") - 1\n            );\n            this.setAttribute("count", newCount.toString());\n          });\n        }\n      }\n\n      customElements.define("notification-badge", NotificationBadge);\n    }\n  }, []);',initOpen:!1,tail:" - 실제, 화면에 붙여본 코드.(클릭하여 오픈) 되게 하기 싫어집니다. 아..."}),(0,s.jsx)(l.A,{codeType:"language-html",codeBlock:'<notification-badge count="5"></notification-badge>\n  // 슈밥 코드 하이라이팅도 이상함돠. 아마 인라인에 스크립트 들어있어서? 흑흑 이 롸이브롸리 짜증나요.\n  <button\n    onClick={() => {\n      document\n        .querySelector("notification-badge")\n        .dispatchEvent(new Event("increment"));\n    }}\n  >\n    증가 click!! (+)\n  </button>\n\n  ',initOpen:!1,tail:" - 태그"}),(0,s.jsx)(i.A,{text:"프레임웤이 줄어든 미래의 개발환경"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"웹은 차츰 상호 운용성과 경량화를 향해가고 있습니다."}),(0,s.jsx)("div",{children:"순수 스크립트와 웹 콤포넌트는 이런 경향을 선도하고 있고, 더 빠르고 유지보수 성이 높으며 프레임웤에 의존적이지 않습니다."}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"프레임웤 버리자는게 아닙니다."}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"이제 프레임웤을 사용할 때, 생각을 좀 해보자는 겁니다."}),(0,s.jsxs)("div",{children:[(0,s.jsx)("span",{className:"italic",children:'"혹시, 이거 바닐라랑 웹 콤넌트로 가능할까?"'}),"스스로 대답을 해보면, 아마 놀라실 겁니다."]}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"미래의 웹은 점점 트렌드가 아니라 더 표준을 따르는 쪽으로 가고 있습니다."}),(0,s.jsx)("div",{children:"그리고 그 방향에서 순수 자바스크립트와 웹 콤포넌트를 사용하면, 그 가능성이 무한합니다."})]})]})}},2719:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>x});var s=t(5155),r=t(910),a=t.n(r);t(8452);var i=t(2115),o=t(2761),l=t(2139),c=t(6167),d=t(908),h=t(2626),p=t.n(h);function x(){return(0,i.useEffect)(()=>{a().highlightAll()},[]),(0,s.jsxs)("div",{className:p().container,children:[(0,s.jsx)(o.A,{text:"Day 3: Can You Spot the Bug in This JavaScript Function?"}),(0,s.jsx)(c.A,{href:"https://medium.com/javascript-in-plain-english/day-3-can-you-spot-the-bug-in-this-javascript-function-f3c95eaf1ccf",prefix:"Medium",text:"Day 3: Can You Spot the Bug in This JavaScript Function?"}),(0,s.jsx)(d.A,{text:"2024.12.31"}),(0,s.jsx)("section",{className:p().paragraph,children:(0,s.jsxs)("div",{children:["원문을 읽고 요약한 글입니다. 당연히, ",(0,s.jsx)("strong",{children:"번역, 주석 등에 오류가 있을 확률 59,000%."})]})}),(0,s.jsx)(d.A,{}),(0,s.jsx)(l.A,{text:"도전문제"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"function createCounters() {\n  let counters = [];\n  for (var i = 0; i < 3; i++) {\n    counters.push(function() {\n      return i;\n    });\n  }\n  return counters;\n}\n\nconst counters = createCounters();\nconsole.log(counters[0]());\nconsole.log(counters[1]());\nconsole.log(counters[2]());\n"})}),(0,s.jsx)("br",{}),(0,s.jsx)(l.A,{text:"질문"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"어떻게 동작 할까요?"}),(0,s.jsx)("div",{children:"어떻게 하면 해결 할 수 있을까요?"})]}),(0,s.jsx)("br",{}),(0,s.jsx)(l.A,{text:"해설"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"반복문에서 변수 i에 var를 사용하고 있습니다."}),(0,s.jsx)("div",{children:"JavaScript에서 var는 함수 스코프를 가지므로, 반복문의 모든 반복이 동일한 변수를 공유합니다."}),(0,s.jsx)("div",{children:"해결하려면, 각 반복문에서 별도의 스코프를 생성하면 됩니다."})]}),(0,s.jsx)("br",{}),(0,s.jsx)(l.A,{text:"고치려면"}),(0,s.jsx)("section",{children:(0,s.jsx)("div",{children:"반복문에서 루프별로 스코프를 다르게 만드는 것입니다."})}),(0,s.jsx)("br",{}),(0,s.jsx)(l.A,{text:"1. let을 사용."}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"\nfunction createCounters() {\n  let counters = [];\n  for (let i = 0; i < 3; i++) {\n    counters.push(function() {\n      return i;\n    });\n  }\n  return counters;\n}\n"})}),(0,s.jsx)("br",{}),(0,s.jsx)(l.A,{text:"2. 즉시실행 함수 사용. IIFE(Immediately Invoked Function Expression)"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"\nfunction createCounters() {\n  let counters = [];\n  for (var i = 0; i < 3; i++) {\n    (function(i) {\n      counters.push(function() {\n        return i;\n      });\n    })(i);\n  }\n  return counters;\n}\n"})}),(0,s.jsx)(d.A,{}),(0,s.jsx)(l.A,{text:"이 문제의 의미?"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"var와 let의, 차이점. 그리고 클로저가 변수와 상호작용하는 방식을 상기시켜주는 좋은 예시입니다."}),(0,s.jsx)("div",{children:"스코핑의 동작을 이해하는 것은 반복문이나 비동기 코드를 작성할 때, 버그를 피할 수 있습니다."})]})]})}},1485:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>h});var s=t(5155),r=t(2761),a=t(2139),i=t(2101),o=t(9969),l=t(908),c=t(2626),d=t.n(c);function h(){return(0,s.jsxs)("div",{className:d().container,children:[(0,s.jsx)(r.A,{text:"Content Security Policy, CSP"}),(0,s.jsx)(l.A,{text:"2025.1.31"}),(0,s.jsxs)("section",{className:d().paragraph,children:[(0,s.jsx)(a.A,{text:"브라우저 환경에서 window와 Object.prototype 조작을 방지하는 방법"}),(0,s.jsx)("div",{children:"- chatGpt에게 prototype에 대해 묻다, 문득 브라우저에서 너무 쉽게 prototype 조작이 가능한게 아닌가했다. 대화가 삼천포로 갔지만, 정리해두는게 좋을것 같다."}),(0,s.jsxs)("ul",{className:"list-decimal ml-5 mt-5",children:[(0,s.jsx)("li",{children:"Strict Mode"}),(0,s.jsx)("li",{children:"Object.defineProperty() : use strict와 상충된다."}),(0,s.jsx)("li",{children:"Object.freeze(), Object.seal()"}),(0,s.jsx)("li",{className:"font-bold",children:"CSP(Content Security Policy) 설정: script-src 'self'."}),(0,s.jsx)("li",{children:"React/Vue에서 쓸 수 있는 빠른 훅 - useLayoutEffect()/beforeCreate()"})]})]}),(0,s.jsx)(l.A,{}),(0,s.jsx)(a.A,{text:"1. Strict Mode"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:'단순하다, js 파일 상단에 "use strict"를 추가한다. 효과는 아래와 같다. 1번이 이번 주제 관련이다.'}),(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{className:"font-bold",children:"읽기 전용 속성 변경 방지- 근데, 이러면 Object.defineProperty를 이용해 writable을 false로 바꿀 수 없다."}),(0,s.jsx)("li",{children:"암묵적 전역변수 방지 - x = 10; 과 같이, 대뜸 선언도 없이 쓸 수 없게 된다."}),(0,s.jsxs)("li",{children:["객체의 속성 중복 선언 방지 - ","{namn: 'Jone', name: 'Doe'}"," 이런거 안된다."]}),(0,s.jsx)("li",{children:"this 제한 - this가 undefined 혹은 null일 때 자동으로 글로벌 this(window)를 참조하지 않고 undefined가 된다."}),(0,s.jsx)("li",{children:"delete 제한 강화 - 변수, 함수의 delete 사용이 금지된다."}),(0,s.jsx)("li",{children:"예약어 사용 제한 - implements, interface, let, package, private, protected, public, static, yield 등을 변수나 함수명으로 못쓴다."})]}),(0,s.jsx)(o.A,{addClass:"mt-2",text:"use strict는 조금 느슨하지만 전체적으로 일괄적인 제한을 하는데   유용하고, Object.defineProperty는 특정 속성을 매우 정교하게 제어할 수   있는 차이가 있겠다."})]}),(0,s.jsx)("br",{}),(0,s.jsx)(a.A,{text:"2. Object.defineProperty()"}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:'const config = {};\n\nObject.defineProperty(config, "API_KEY", {\n    value: "1234-5678-ABCD",\n    writable: false,\n    configurable: false\n});\n\nconfig.API_KEY = "HACKED"; // ❌ 변경 불가능\nconsole.log(config.API_KEY); // "1234-5678-ABCD"\n'}),(0,s.jsx)("br",{}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:'const originalAlert = window.alert;\n\nObject.defineProperty(window, "alert", {\n    get: function () {\n        return originalAlert;\n    },\n    set: function () {\n        console.warn("\uD83D\uDEA8 alert 함수 변경이 차단되었습니다!");\n    },\n    configurable: false\n});\n\n'}),(0,s.jsx)("div",{children:"이런 식으로, 특정 프로토타입 값을 변경하지 못하게 만들어 버리는 것. 유저가 핸들링 하는것 보다 먼저 걸어 두어야 하므로, 빠른 훅이 필요하다."}),(0,s.jsx)("br",{}),(0,s.jsx)(a.A,{text:"3. Object.feeze(), Object.seal()"}),(0,s.jsx)("section",{children:(0,s.jsx)("div",{children:"Object.freeze(window)를 하게되면, window 객채의 오버라이드 등 window의 모든 기존 속성을 수정하지 못한다. Object.seal(window)는 기존 속성은 변경 가능하지만, 새로운 속성 추가는 불가능해진다."})}),(0,s.jsx)("br",{}),(0,s.jsx)(a.A,{text:"4. CSP(Content Security Policy) 설정"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"현재 페이지와 동일한 출처(origin)에서 실행되는 스크립트만 허용한다. 상당히 좋다."}),(0,s.jsx)(i.A,{codeType:"language-html",codeBlock:'<!DOCTYPE html>\n<html lang="ko">\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="Content-Security-Policy" content="script-src \'self\'">\n    <title>CSP 적용 예제</title>\n</head>\n<body>\n    <script>\n        console.log("✅ 안전한 스크립트 실행!");\n    <\/script>\n    \n    \x3c!-- 외부 스크립트 주입 시도 --\x3e\n    <script src="https://evil-hacker.com/hack.js"><\/script> \n</body>\n</html>\n',initOpen:!1}),(0,s.jsx)("div",{className:"mt-5",children:"하지만, 이러면, CDN으로 jqeury등을 가져와도 실행되지 않는다. 아래와 같이 허용하려는 사이트를 적어서 우회는 가능하다. 복수의 사이트도 적을 수 있다."}),(0,s.jsx)(i.A,{codeType:"language-html",codeBlock:'<meta http-equiv="Content-Security-Policy" content="script-src \'self\' https://code.jquery.com https://www.googletagmanager.com;">'})]}),(0,s.jsxs)("section",{className:"mt-5",children:["nonce(난수) 기반 실행 - 각 페이지 로드 시 난수(nonce) 값을 생성하여 특정 스크립트 허용.",(0,s.jsx)("div",{children:" 1단계. CSP 설정"}),(0,s.jsx)(i.A,{codeType:"language-html",codeBlock:"<meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self' 'nonce-random123'\">\n"}),(0,s.jsx)("div",{children:" 2단계. 실행 스크립트"}),(0,s.jsx)(i.A,{codeType:"language-html",codeBlock:'<script nonce="random123"> alert("이 특정 인라인 스크립트는 허용됨!"); <\/script>'})]}),(0,s.jsxs)("section",{className:"mt-5",children:[(0,s.jsx)("div",{children:"HTTP 응답 헤더를 통해 서버에서 설정할 수도있다."}),(0,s.jsx)(i.A,{codeType:"language-text",codeBlock:"// Apach 서버\n  Header set Content-Security-Policy \"script-src 'self'\"\n  "}),(0,s.jsx)(i.A,{codeType:"language-text",codeBlock:"// Nginx 서버\n  add_header Content-Security-Policy \"script-src 'self'\";"}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:"// Node.js (Express, helmet)\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Content Security Policy 적용\napp.use(\n    helmet.contentSecurityPolicy({\n        directives: {\n            defaultSrc: [\"'self'\"],\n            scriptSrc: [\"'self'\"]\n        }\n    })\n);\n\napp.get(\"/\", (req, res) => {\n    res.send(\"<script>alert('✅ 안전한 페이지!');<\/script>\");\n});\n\napp.listen(3000, () => {\n    console.log(\"\uD83D\uDE80 서버 실행: http://localhost:3000\");\n});\n  ",initOpen:!1,tail:" - Node.js"})]})]})}},619:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>u});var s=t(5155),r=t(910),a=t.n(r);t(8452);var i=t(2115),o=t(2761),l=t(6529),c=t(6167),d=t(908),h=t(9969),p=t(2626),x=t.n(p);function u(){return(0,i.useEffect)(()=>{a().highlightAll()},[]),(0,s.jsxs)("div",{className:x().container,children:[(0,s.jsx)(o.A,{text:"JavaScript에서 ev.currentTarget과 ev.target의 Event Handling을 이해하기"}),(0,s.jsx)(c.A,{href:"https://jagathishsaravanan.medium.com/understanding-ev-currenttarget-and-ev-target-in-javascript-event-handling-5f6bdc2c0e2a",prefix:"Medium",text:"https://jagathishsaravanan.medium.com/understanding-ev-currenttarget-and-ev-target-in-javascript-event-handling-5f6bdc2c0e2a"}),(0,s.jsx)(d.A,{text:"2025.1.21"}),(0,s.jsx)("section",{children:(0,s.jsx)("div",{children:"이벤트 커런트타겟(ev.currentTarget)과 이벤트 타겟(ev.target)의 차이에 대해 이해해보자."})}),(0,s.jsx)(d.A,{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"ev.currentTarget과 ev.target에 대해 알아보기 전에, 자바스크립트가 이벤트를 어떻게 처리하는지 보자."}),(0,s.jsx)("div",{children:"버튼을 클릭하거나 마우스를 올리거나 등, 이벤트가 발생하면 오브젝트가 생성됩니다."}),(0,s.jsx)("div",{children:"이 오브젝트는 이벤트 정보들을 담고 있습니다. 어떤 엘리먼트에서 발동했는지, 어떤 이벤트였는지 등등의 정보죠."}),(0,s.jsx)("div",{children:"이벤트리스너들은, 특정한 이벤트가 일어났을때 발동하도록 되어있는 함수입니다."}),(0,s.jsx)("div",{children:"아래는 이벤트 리스너의 예입니다."})]}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"document.querySelector('button').addEventListener('click', function(ev) {\n    console.log(ev.target);\n  })"})}),(0,s.jsx)(l.A,{text:"What is ev.target?"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"ev.target property는 이벤트가 트리거된 엘리먼트를 참조합니다."}),(0,s.jsx)("div",{children:"이것은, 이벤트가 시작된 DOM의 가장 구체적인 element를 가리킵니다."}),(0,s.jsx)("div",{children:"정확히 어떤 element와 상호작용했는지를 알고싶을때 특히, 유용합니다."})]}),(0,s.jsx)(h.A,{text:"여기서 '구체적인 element'는 DOM트리의 부모, 자식, 형제 등 여러 엘리먼트 중에 실제 이벤트가 트리거된 엘리먼트를 강조한다 이해했습니다."}),(0,s.jsx)(l.A,{text:"What is ev.currentTarget?"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"한편, ev.currentTarget property는 이벤트 핸들러가 연결된 엘리먼트를 참조합니다."}),(0,s.jsx)("div",{children:"이것은, 어떤 엘리먼트에서 이벤트가 기원 했는지와 상관없이 이벤트 리스너가 연결된 엘리먼트를 가리킵니다."}),(0,s.jsx)("div",{children:"다음을 보시죠."})]}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"document.getElementById('parent').addEventListener('click', function(ev) {\n    console.log('ev.currentTarget:', ev.currentTarget);\n});"})}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"#child 버튼이 클릭되더라도 ev.currentTarget은 #parent div를 참조할겁니다. 왜냐하면, 리스너가 거기에 붙어있기 때문이죠."}),(0,s.jsx)("div",{children:"즉, 아래와 같이 나올겁니다."})]}),(0,s.jsx)("pre",{className:"language-html",children:(0,s.jsx)("code",{children:'ev.currentTarget: <div id="parent">...</div>'})}),(0,s.jsx)(l.A,{text:"Key Differences Between ev.target and ev.currentTarget"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"이벤트의 기원 - ev.target은 실제 이벤트가 시작된 엘리먼트를, ev.currentTarget은 이벤트 핸들러가 연결된 엘리먼트를 가리킵니다."}),(0,s.jsx)("li",{children:"Event Propagation(전파) - 만약 DOM에서 이벤트가 bubbles up(위로 올라감. 버블링.)하면, ev.target은 이벤트가 발생한 원래의 엘리먼트에 남아있습니다. 반면, ev.currentTarget은 엘리먼트의 이벤트 리스너가 실행 되었는지에 따라 달라질 수 있습니다."}),(0,s.jsx)("li",{children:"활용 - ev.target은 이벤트가 발생한 구체적인 엘리먼트를 알고싶을때. ev.currentTarget은 이벤트 리스너가 연결된 엘리먼트를 확인하는게 더 중요할 때."})]})}),(0,s.jsx)(h.A,{text:"Event Propagation - 이벤트 전파, 그러니까 버블링(bubbling)과 캡처링(capturing) 모두를 의미."}),(0,s.jsx)(h.A,{text:"이벤트 단계간 순위 - 1.캡처링, 2.타깃 단계, 3.버블링 순서로 실행됩니다."}),(0,s.jsx)(h.A,{text:"Capturing Phase- 이벤트 루트에서 타겟으로 내려감."}),(0,s.jsx)(h.A,{text:"Target Phase - 타겟 일레먼트에서 실행되는 단계."}),(0,s.jsx)(h.A,{text:"Bubbling Phase- 이벤트가 타겟에서 루트를 향해 올라감."}),(0,s.jsx)(d.A,{text:"잠시 번역을 멈추고, 여기서 저의 의문과 실험입니다."}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"만약, 어떤 엘리먼트의 리스너가 루트와 클릭된 엘리먼트 중간에 있다면 currentTarget은 캡처링과 버블링 이 두번에 걸쳐 실행될 것인가?"}),(0,s.jsx)("pre",{className:"language-html",children:(0,s.jsx)("code",{children:'<div id="root">\n  <div id="middle">\n    <button id="target">Click me</button>\n  </div>\n</div>'})}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:'const root = document.getElementById("root");\nconst middle = document.getElementById("middle");\nconst target = document.getElementById("target");\n\nfunction logEvent(ev) {\n  console.log(\n    `Phase: ${ev.eventPhase}, currentTarget: ${ev.currentTarget.id}, target: ${ev.target.id}`\n  );\n}\nmiddle.addEventListener("click", logEvent, true); // 캡처링 - 3번째 인자를 true로 함.\nmiddle.addEventListener("click", logEvent); // 버블링 - 3번째 인자는 default가 false, 버블링에서 실행함. 항상 써오던게 사실은 버블링만 실행.'})}),(0,s.jsx)("div",{children:"네, meddle 엘리먼트 리스너는 두번 실행 됩니다."}),(0,s.jsx)("div",{children:"실험을 하고보니 멍청한 의문 같습니다."}),(0,s.jsx)("div",{children:"중간 뿐 아니라 타겟도 캡처링과 버블링 두단계에 걸쳐 리스너가 실행 될 수 있습니다."}),(0,s.jsx)("div",{children:"엄밀하게 말하면 두개의 리스너를 붙여놓는 것이지요. 세번째 인자에 true, false 두 종류로요."}),(0,s.jsx)("br",{}),(0,s.jsxs)("div",{children:[(0,s.jsx)("p",{children:"* 여기서 추가 정리."}),(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"stopPropagation - 이벤트 전파를 멈춤. 캡처링에서 멈춘다면 버블링 단계로 넘어가지 않음. 특히, 다른 리스너는 실행됨."}),(0,s.jsx)("li",{children:"stopImmediatePropagation - 완전 멈춤. 같은 엘리먼트에 등록된 다른 리스너도 실행되지 않음."}),(0,s.jsx)("li",{children:"preventDefault - 이벤트 기본동작을 멈춤. 기본동작은 이벤트가 자동 수행되도록 되어있는 동작을 의미. 예로 a태그는 링크로의 이동, button은 폼 전송과 같은 것. 브라우저가 특별히 정의한 기본 동작이 없다면, 아무런 효과가 없음."})]})]}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:'document.addEventListener("contextmenu", (event) => {\n    event.preventDefault(); // 오른쪽 클릭 메뉴 막기\n    console.log("컨텍스트 메뉴를 막았습니다.");\n});'})})]}),(0,s.jsx)(d.A,{text:"나루호도, 다시 본문 번역을 이어갑니다."}),(0,s.jsx)(l.A,{text:"이벤트 핸들링의 위임"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"이벤트 위임은, 부모에게 하나의 이벤트 리스너를 연결해서 여러 자손 엘리먼트의 이벤트를 핸들링하는 일반적인 패턴입니다. 이때, ev.target은 어떤 자손이 트리거 되었는지 알고자 할 때, 유용할 겁니다."}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"document.getElementById('parent').addEventListener('click', function(ev) {\n    if (ev.target.tagName === 'BUTTON') {\n        console.log('Button clicked:', ev.target.id);\n    }\n});"})}),(0,s.jsx)("div",{children:"위에서 우리는 부모에게 이벤트 리스너를 붙였습니다. 클릭 이벤트 리스너가 target element가 button인지 체크합니다. 상황에 따라 이벤트를 핸들링 하면 되겠죠."})]}),(0,s.jsx)(h.A,{text:"이벤트 Delegated(위임)을 하는 이유 - 성능 최적화, 코드 간소화, 동적으로 생성되는 엘리먼트의 처리."})]})}},1811:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>p});var s=t(5155),r=t(910),a=t.n(r);t(8452);var i=t(2115),o=t(2761),l=t(2139),c=t(908),d=t(2626),h=t.n(d);function p(){return(0,i.useEffect)(()=>{a().highlightAll()},[]),(0,s.jsxs)("div",{className:h().container,children:[(0,s.jsx)(o.A,{text:"HTTP/1.1과 HTTP/2의 차이"}),(0,s.jsx)(c.A,{text:"2024.01.26"}),(0,s.jsx)(l.A,{text:"프로토콜 차이:"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"HTTP/1.1 : 요청 - 응답 기반. 하나의 연결에 하나의 요청만 처리."}),(0,s.jsxs)("li",{children:["HTTP/2: 하나의 요청에서 여러 요청을 병렬로 처리. 예, 하나의 연결상태에서 독립적인 스트림을 여러개 만듬. HTML, CSS, JS스트림 등."," "]})]})}),(0,s.jsx)(l.A,{text:"헤더 압축:"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"HTTP/1.1 : 요청마다 헤더 전체를 반복해서 전송."}),(0,s.jsx)("li",{children:"HTTP/2: 이전에 전송한 헤더와 차이점만 전송. 헤더를 압축 전송량 줄임."})]})}),(0,s.jsx)(l.A,{text:"서버 푸시:"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"HTTP/1.1 : 클라이언트가 요청한 자원만 응답."}),(0,s.jsx)("li",{children:"HTTP/2: 클라이언트가 필요로 할 자원을 미리 전송 가능. 예, HTML을 요청하면 관련 CSS와 JS를 푸시할 수 있음. 서버 개발자가 해당 요청에 대해 별도 코딩 필요."})]})}),(0,s.jsx)(l.A,{text:"연결유지:"}),(0,s.jsx)("section",{children:(0,s.jsx)("ul",{className:"list-decimal ml-5",children:(0,s.jsx)("li",{children:"HTTP/2: 1보다 리소스를 절약."})})}),(0,s.jsx)(l.A,{text:"Node.js와 HTTP/2:"}),(0,s.jsx)("section",{children:"http2 모듈을 지원하며, Node.js 18부터는 Fetch API도 기본 내장되어 있음."}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"const http2 = require('http2');\n\nconst server = http2.createServer((req, res) => {\n  res.end('Hello, HTTP/2!');\n});\n\nserver.listen(3000);"})}),(0,s.jsx)(l.A,{text:"Deno와 Bun:"}),(0,s.jsx)("section",{children:"Deno는 Fetch API 기본 지원, Bun은 아직 Fetch 지원하지 않음."}),(0,s.jsx)(l.A,{text:"Node.js HTTP/2 서버푸시 스캐폴딩:"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  // http2에서는 https가 권장.\n  key: fs.readFileSync('server-key.pem'),\n  cert: fs.readFileSync('server-cert.pem')\n});\n\n// http2에서 클라이어트 요청을 받을 때마다, stream 이벤트가 발생함. 매 요청의 고유 stream.\nserver.on('stream', (stream, headers) => { // stream, headers 객체를 인자로 받음.\n  const path = headers[':path']; // 요청경로. http1.1에서 GET /index.html과 같이 받던 것이 http2에서는 :path에 저장됨. (:method, :path, :scheme, :authority 등)\n\n  // HTML 요청\n  if (path === '/index.html') {\n\n    // 서버 푸시로 CSS 전송\n    stream.pushStream({ ':path': '/style.css' }, (err, pushStream) => {\n      if (!err) {\n        pushStream.respondWithFile('style.css', { 'content-type': 'text/css' });\n      }\n    });\n\n    // 서버 푸시로 JS 전송\n    stream.pushStream({ ':path': '/script.js' }, (err, pushStream) => {\n      if (!err) {\n        pushStream.respondWithFile('script.js', { 'content-type': 'application/javascript' });\n      }\n    });\n\n    // ** 푸시된 리소스(CSS, JS)가 클라이언트의 캐시에 이미 존재하면 네트워크 자원이 낭비될 수 있습니다. **\n\n    // respondWithFile - 클라이언트가 명시적으로 요청한 리소스에 대한 응답.\n    stream.respondWithFile('index.html', { 'content-type': 'text/html' });\n  }\n\n  // CSS 요청 처리\n  else if (path === '/style.css') {\n    stream.respondWithFile('style.css', { 'content-type': 'text/css' });\n  }\n\n  // JS 요청 처리\n  else if (path === '/script.js') {\n    stream.respondWithFile('script.js', { 'content-type': 'application/javascript' });\n  }\n\n  // 기타 요청 처리\n  else {\n    stream.respond({ ':status': 404 });\n  }\n});\n\n// 서버 시작\nserver.listen(3000, () => {\n  console.log('HTTP/2 Server is ready on port 3000.');\n});"})})]})}},7474:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>u});var s=t(5155),r=t(910),a=t.n(r);t(8452);var i=t(2115),o=t(2761),l=t(6529),c=t(2139),d=t(6167),h=t(908),p=t(2626),x=t.n(p);function u(){return(0,i.useEffect)(()=>{a().highlightAll()},[]),(0,s.jsxs)("div",{className:x().container,children:[(0,s.jsx)(o.A,{text:"Debouncing in JavaScript: How to delay a function execution"}),(0,s.jsx)(d.A,{href:"https://codedamn.com/news/javascript/debouncing-in-javascript",prefix:"codedamn",text:"Debouncing in JavaScript: How to delay a function execution"}),(0,s.jsx)(h.A,{text:"2024.12.31"}),(0,s.jsxs)("section",{className:x().paragraph,children:[(0,s.jsxs)("div",{children:["원문을 읽고 요약한 글입니다."," ",(0,s.jsx)("strong",{children:"번역, 주석 등에 오류가 있을 확률은 57,328%"})," 입니다."]}),(0,s.jsx)("div",{children:"디바운싱(Debouncing)은 이벤트가 짧은 간격으로 여러 번 실행되지 않도록 일정 시간 후에 실행되도록 하고, 브라우저나 서버의 부하를 줄이려는 의도로 사용. 주로 검색창."}),(0,s.jsx)("div",{children:"반면, 스로틀링(Throttling)은 일정시간 간격으로 일어나게 하여, 스크롤에 적합함."})]}),(0,s.jsx)(h.A,{}),(0,s.jsx)(l.A,{text:"JavaScript에서 디바운싱(Debouncing)이란 무엇인가?"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"웹사이트에서 버튼을 클릭했을때 콘텐츠가 조금 느리게 로딩된다고 느낀 적이 있나요?"}),(0,s.jsx)("div",{children:"검색 필드에 입력한 후 결과가 표시되기까지 약간의 지연이 있을 때는요?"}),(0,s.jsx)("div",{children:"개발자들은, 디바운스를 사용하여 이런 딜레이를 만들고 서버에 불필요한 요청을 보내지 않도록 합니다."})]}),(0,s.jsx)(l.A,{text:"디바운싱(Debouncing)은 어떻게 동작하나?"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"디바운싱은 코드를 실행하기 전에 지연 타이머를 시작합니다."}),(0,s.jsx)("div",{children:"어떤 이유로 동작이 반복되면, 큐에 두번째 이벤트를 쌓는 대신 이전 프로세스를 중단시키고 현재 이벤트에만 집중하게 합니다."})]}),(0,s.jsx)(l.A,{text:"JavaScript 디바운싱(Debouncing) 함수"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"function debounce(callback, timer) {\n  let timeoutId;\n\n  return (...args) => {\n    // save the current context (this)\n    const context = this;\n\n    // clear the existing timeout\n    clearTimeout(timeoutId);\n\n    // create a new timeout\n    timeoutId = setTimeout(() => {\n      callback.apply(context, args);\n    }, timer);\n  };\n}\n"})}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"다음과 같이 동작합니다."}),(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"기존 타이머 초기화"}),(0,s.jsx)("li",{children:"새 타이머 설정"}),(0,s.jsx)("li",{children:"apply()를 통해 콜백 실행. 해당 함수의 매개변수(args)와 컨텍스트(this)를 전달 합니다."})]}),(0,s.jsx)("div",{children:"타이머는 생성된 특정 타임아웃에 대한 참조 ID를 반환합니다."}),(0,s.jsx)("div",{children:"이 아이디를 통해 기존 타임아웃을 취소시킵니다."}),(0,s.jsx)("div",{children:"타이머 스케쥴링과 취소의 비용은 매우 적은 편이기 때문에 비용에 대해 크게 걱정하지 않아도 됩니다."})]}),(0,s.jsx)(l.A,{text:"사용례"}),(0,s.jsx)(c.A,{text:"검색창"}),(0,s.jsx)("pre",{className:"language-html",children:(0,s.jsx)("code",{children:'<input type="text" id="input">'})}),(0,s.jsx)("br",{}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"const input = document.getElementById('input');\n\ninput.addEventListener('input', callAPI);\n\nfunction callAPI() {\n    // Time consuming API call\n    console.log('API called!');\n}\n"})}),(0,s.jsx)("section",{children:(0,s.jsx)("div",{children:"위 코드는 API called가 입력이 들어올 때마다 계속 발생합니다. 반면 아래는 다릅니다."})}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"const debouncedCallAPI = debounce(callAPI, 500);\n\ninput.addEventListener('input', debouncedCallAPI);\n"})}),(0,s.jsx)(c.A,{text:"마우스 이벤트"}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"window.addEventListener('mousemove', mouseMove);\n\nfunction mouseMove(e) {\n    let x = e.clientX;\n    let y = e.clientY;\n    console.log('Mouse moved to: ', x, y);\n}\n"})}),(0,s.jsx)("br",{}),(0,s.jsx)("pre",{className:"language-javascript",children:(0,s.jsx)("code",{children:"const debouncedMouseMove = debounce(mouseMove, 500);\n\nwindow.addEventListener('mousemove', debouncedMouseMove);\n"})}),(0,s.jsx)("br",{}),(0,s.jsx)("section",{children:(0,s.jsx)("div",{children:"마찬가지로 디바운스를 사용하면 더 효율적입니다."})})]})}},5735:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>m});var s=t(5155),r=t(910),a=t.n(r);t(8452);var i=t(2115),o=t(2761),l=t(6529),c=t(6167),d=t(908),h=t(8173),p=t.n(h),x=t(2626),u=t.n(x);function m(){return(0,i.useEffect)(()=>{a().highlightAll()},[]),(0,s.jsxs)("div",{className:u().container,children:[(0,s.jsx)(o.A,{text:"2024 JavaScript Rising Stars"}),(0,s.jsx)(c.A,{href:"https://risingstars.js.org/2024/en#section-framework",prefix:"risingstars",text:"https://risingstars.js.org/2024/en#section-framework"}),(0,s.jsx)(d.A,{text:"2025.1.13"}),(0,s.jsx)("section",{className:u().paragraph,children:"상기 링크가 그래프로 표시되어 있어 훨씬 보기 좋습니다."}),(0,s.jsx)(d.A,{}),(0,s.jsx)(l.A,{text:"Front-end Frameworks"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsxs)("li",{children:["htmx +16.8k :",(0,s.jsx)(p(),{href:"https://htmx.org/essays/is-htmx-another-javascript-framework/",className:"text-blue-600 hover:underline",children:"https://htmx.org/essays/is-htmx-another-javascript-framework/"})]}),(0,s.jsx)("li",{children:"React +14.2k"}),(0,s.jsx)("li",{children:"Svelte +6.1k"}),(0,s.jsx)("li",{children:"Vue +5.9k"}),(0,s.jsx)("li",{children:"Angular +3.5k"})]})}),(0,s.jsx)(l.A,{text:"React Ecosystem"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsxs)("li",{children:["shadcn/ui +38.0k :",(0,s.jsx)(p(),{href:"https://ui.shadcn.com/",className:"text-blue-600 hover:underline",children:"https://ui.shadcn.com/"})]}),(0,s.jsx)("li",{children:"Excalidraw +27.0k"}),(0,s.jsx)("li",{children:"Magic UI +13.2k"}),(0,s.jsx)("li",{children:"Next.js +12.1k"}),(0,s.jsx)("li",{children:"Refine +11.7k"})]})}),(0,s.jsx)(l.A,{text:"Vue Ecosystem"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"Nuxt +6.2k"}),(0,s.jsx)("li",{children:"PrimeVue +5.4k"}),(0,s.jsx)("li",{children:"Slidev +4.7k"}),(0,s.jsx)("li",{children:"shadcn-vue +4.1k"}),(0,s.jsx)("li",{children:"VitePress +3.7k"})]})}),(0,s.jsx)(l.A,{text:"Back-end/Full-stack"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"Next.js +12.1k"}),(0,s.jsx)("li",{children:"Hono +11.5k"}),(0,s.jsx)("li",{children:"Astro +9.8k"}),(0,s.jsx)("li",{children:"Nest +6.8k"}),(0,s.jsx)("li",{children:"Strapi +6.3k"})]})}),(0,s.jsx)(l.A,{text:"Styling / CSS in JS"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"Tailwind CSS +9.4k"}),(0,s.jsx)("li",{children:"DaisyUI +6.6k"}),(0,s.jsx)("li",{children:"Bootstrap +4.8k"}),(0,s.jsx)("li",{children:"Pico.css +3.1k"}),(0,s.jsx)("li",{children:"Tamagui +3.0k"})]})}),(0,s.jsx)(l.A,{text:"Component Libraries"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsx)("li",{children:"shadcn/ui +38.0k"}),(0,s.jsx)("li",{children:"Magic UI +13.2k"}),(0,s.jsx)("li",{children:"PrimeVue +5.4k"}),(0,s.jsx)("li",{children:"NextUI +4.9k"}),(0,s.jsx)("li",{children:"Mantine +4.5k"})]})}),(0,s.jsx)(l.A,{text:"Testing"}),(0,s.jsx)("section",{children:(0,s.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,s.jsxs)("li",{children:["Playwright +10.4k :",(0,s.jsx)(p(),{href:"https://playwright.dev/",className:"text-blue-600 hover:underline",children:"https://playwright.dev/"})]}),(0,s.jsx)("li",{children:"Puppeteer +3.8k"}),(0,s.jsx)("li",{children:"Storybook +3.7k"}),(0,s.jsx)("li",{children:"Micro Agent +3.1k"}),(0,s.jsx)("li",{children:"Stagehand +2.8k"})]})})]})}},382:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>p});var s=t(5155),r=t(2761),a=t(2139),i=t(2101),o=t(9969),l=t(908),c=t(2626),d=t.n(c),h=t(6167);function p(){return(0,s.jsxs)("div",{className:d().container,children:[(0,s.jsx)(r.A,{text:"The JS Bifrost — JavaScript의 상속 — Prototype 과 class 상속"}),(0,s.jsx)(h.A,{href:"https://medium.com/globant/the-js-bifrost-inheritance-in-js-prototype-and-class-inheritance-84ec4c60b1a2",prefix:"Medium",text:"https://medium.com/globant/the-js-bifrost-inheritance-in-js-prototype-and-class-inheritance-84ec4c60b1a2"}),(0,s.jsx)(l.A,{text:"2025.2.7"}),(0,s.jsx)("section",{className:d().paragraph,children:"번역에 오류가 있을 겁니다. 개인적으로 이해한 부분을 추가 하였는데, 이 역시 잘못된 부분이 있을 수 있습니다."}),(0,s.jsx)(l.A,{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"Welcome to The JS Bifrost, your pathway to a rock-solid foundation for God-level JavaScript. This is the next article in the series, which talks about Inheritance in JavaScript."}),(0,s.jsx)("div",{children:"갓 레벨 자바스크립트를 향한 단단한 길, JS 비프로스트에 온 걸 환영합니다. 이 글은 시리즈의 다음글 입니다, 자바스크립트의 상속에 대해 이야기하겠습니다."}),(0,s.jsx)(o.A,{text:'Inheritance - 라틴어 "hereditare" (상속받다)에서 유래했고, 이는 "heres" (상속인, 상속자)에서 파생된 단어.\n          "in-" (안으로) + "herit" (상속) + "-ance" (명사형) → "물려받음"\n          프로그래밍에서는 부모의 속성과 메소드를 물려받지만, 사실상 기존 객체의 기능을 확장하면서 계승/발전하는 의미도 있음.\n          '})]}),(0,s.jsxs)("section",{className:"mt-2",children:[(0,s.jsx)("div",{children:"Unlike all other object-oriented programming languages, JavaScript chose prototypes for its way of handling inheritance, but with the release of ES2015, classes were introduced to the language’s syntax."}),(0,s.jsx)("div",{children:"OOP 언어들과 달리, JavaScript는 프로토타입을 상속을 위한 도구로 선택했습니다, 하지만 ES2015에서, class가 문법으로 추가되었습니다."})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{className:"mt-2",children:[(0,s.jsx)("div",{children:"Let me put light on thought:"}),(0,s.jsx)("div",{children:"한번 생각해보죠 :"})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{className:"font-bold",children:[(0,s.jsx)("div",{children:"Classes are just syntactic sugar, JavaScript remains prototype based."}),(0,s.jsx)("div",{children:"Class는 그냥 문법적 설탕(편의적 기능)일 뿐, JavaScript는 여전히 프로토타입에 기반하고 있습니다."}),(0,s.jsx)("div",{children:"They are not a new object-oriented inheritance model."}),(0,s.jsx)("div",{children:"이 Class(JavaScript가 도입한 클래스)는 새로운 객체지향적 상속 모델이 아닙니다."})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{className:"mt-2",children:[(0,s.jsx)("div",{children:"Let’s understand the Prototype first !!!!"}),(0,s.jsx)("div",{children:"프로토타입을 이해해 봅시다!!!!"})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"In general, a prototype is nothing but a first or preliminary version of a device or vehicle from which other forms are developed. In Javascript also, it follows the prototype mechanism to inherit properties and methods."}),(0,s.jsx)("div",{children:"일반적으로, 프로토타입이란 최초 혹은 이미 개발된 장비나 장치에서 비롯된 예비 버전 같은 겁니다. JavaScript에서도, 속성과 메소드를 상속하기 위해서 프로토타입의 메카니즘을 따라 했습니다."})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsxs)("div",{children:["All objects in Javascript have a ",(0,s.jsx)("strong",{children:"prototype property, "})]}),(0,s.jsx)("div",{className:"mb-2",children:"Javascript에서 모든 객체는 프로토타입 속성을 가집니다."}),(0,s.jsx)("div",{children:"which acts as a model that inherits methods and properties from another object."}),(0,s.jsx)("div",{className:"mb-2",children:"오브젝트 속 프로토타입 속성은 다른 오브젝트의 메소드와 속성을 상속한 모델 역할을 합니다."}),(0,s.jsx)("div",{children:"It’s an object that stands on its own and we could use it by itself if we wanted to."}),(0,s.jsx)("div",{className:"mb-2",children:"프로토타입은 독립적이며 우리가 원한다면 그대로 사용 할 수도 있습니다."}),(0,s.jsxs)("div",{children:["The object property that we called",(0,s.jsx)("strong",{children:" proto "}),"that’s its prototype."]}),(0,s.jsxs)("div",{className:"mb-2",children:["객체(object)에서 우리가 proto라고 부르는 속성이 바로 그 객체의 프로토타입입니다.",(0,s.jsx)("br",{}),"(proto가 prototype 자체는 아니고 참조임. 아래에 이어짐.)"]}),(0,s.jsx)("div",{children:"That’s the object that is going to grab and will be able to get its properties and methods as well."}),(0,s.jsx)("div",{children:"이 속성(__proto__)을 통해 객체는 속성과 메소드들을 가져오고 또 사용할 수 있습니다."})]}),(0,s.jsx)(l.A,{text:"번역을 잠시 멈추고 개인적으로 정리해 봅니다. 엄밀히 말하면, 원문이 조금 이상하게 이야기를 한 것 같습니다."}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"일반 객체에는 prototype 속성이 없습니다."}),(0,s.jsx)("div",{className:"mb-2",children:"함수를 만들면 prototype 속성이 존재함."}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:"var Foo = {}\nconsole.dir(Foo);\nconsole.dir(Foo.__proto__)\n\nfunction Bar() {}\nconsole.dir(Bar);\n"}),(0,s.jsxs)("div",{children:["객체는 생성될 때, JavaScript가 글로벌 Object의 prototype속성",(0,s.jsx)("strong",{children:" Object.prototype"}),"을 프로토타입으로써 참조하도록 하고, 객체용 새 그릇(저장공간)을 만듭니다. 앞서 말했듯 .prototype 속성은 객체에는 있지도 않고, 함수에만 있습니다."]}),(0,s.jsx)("div",{className:"mt-5 font-bold",children:"말하고자 하는, 프로토타입은 다른 객체가 참조하고 있는 실체를 의미합니다."}),(0,s.jsx)("div",{className:"mb-5 font-bold",children:"이제부터는 참조되어야 할 실체적 객체를 [[Prototype]]이라고 하겠습니다."}),(0,s.jsxs)("div",{children:["만일 어떤 객체를 최초로 만든다면, JavaScript는",(0,s.jsx)("strong",{children:" Object.prototype"}),"을 [[Prototype]]으로써 참조할 수 있게 하고, 새 객체를 위한 공간을 만듭니다."]}),(0,s.jsxs)("div",{className:"mb-2",children:["JavaScript에서 글로벌 Object는 함수(생성자함수)입니다. 앞서 말했듯, 함수이므로 ",(0,s.jsx)("strong",{children:".prototype "}),"속성을 가지고 있습니다."]}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:"console.dir(Object); // JavaScript Object는 함수 입니다."}),(0,s.jsxs)("div",{children:[(0,s.jsx)("div",{children:"Foo.name을 하게되면,"}),(0,s.jsxs)("ul",{className:"list-decimal ml-10 mb-2",children:[(0,s.jsx)("li",{children:"Foo라는 그릇에서 찾고"}),(0,s.jsxs)("li",{children:["Foo의 [[Prototype]]에서 찾습니다. 여기서는 함수인 Object의 속성, Object.prototype입니다.",(0,s.jsx)("strong",{children:"(**생성자 함수 Object의 [[Prototype]]은 Function.prototype이며 이 함수의 속성인 Object.prototype과 다릅니다.**)"})]}),(0,s.jsx)("li",{children:"Object.prototype에서 찾습니다. 찾지 못하면,"}),(0,s.jsx)("li",{children:"Object.prototype의 [[Prototype]]에서 찾습니다. 이건 null 입니다."})]}),(0,s.jsx)("div",{className:"mb-2",children:"객체를 상속하여 새 객체를 만들어도 기본적으로 흐름은 같습니다."}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:'const parent = { name: "parent" };\nconst child = Object.create(parent);\n\nconsole.log(child.name);  // "parent" (프로토타입에서 상속됨)\nconsole.log(child.__proto__ === parent);  // true',tail:" - 객체의 상속. Extends 따위 필요 없습니다."})]}),(0,s.jsx)("div",{children:"여기서, __proto__를 짚고가 봅니다."}),(0,s.jsx)("div",{className:"font-bold",children:"Foo.__proto__를 호출하면 __proto__속성을 찾기위해 프로토타입체인이 일어날 것 같지만,"}),(0,s.jsx)("div",{children:"Foo 객체의 [[Prototype]]인 Object.prototype을 직접 반환합니다."}),(0,s.jsx)("div",{className:"mb-2",children:"Object.prototype객체에 있는 __proto__를 만나서, 그 값인 null을 반환하지 않습니다."}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:"var Foo = {}\nconsole.dir(Object.prototype)\nconsole.dir(Foo);\nconsole.log(Foo.__proto__);  // ✅ Object.prototype\nconsole.log(Object.getPrototypeOf(Foo));  // ✅ Object.prototype\n",tail:"- __proto__를 찾아서."}),(0,s.jsxs)("div",{children:[(0,s.jsx)("strong",{children:"Foo는 일반 객체"}),"를 만든 것이고, 객체를 만들때 글로벌 생성자",(0,s.jsx)("strong",{children:' "함수"인 "Object"'}),"의",(0,s.jsx)("strong",{children:" Object.prototype을 [[Prototype]]"}),"으로 했을 겁니다."]}),(0,s.jsx)("div",{children:"그리고 프로토타입체인은 자기 그릇에서 찾지 못하면 참조중인 [[Prototype]]을 찾아서 계속 이동하겠죠."}),(0,s.jsx)("br",{}),(0,s.jsxs)("div",{children:["그러니 Foo.__proto__도",(0,s.jsx)("strong",{children:" 이 메커니즘을 따른다면,"}),(0,s.jsx)("br",{}),"1. Foo에서 못찾음",(0,s.jsx)("br",{}),"2. [[Prototype]]인 Object.prototype에서 __proto__를 만나",(0,s.jsx)("strong",{children:" null을 줘야 할 것 같지만 "}),(0,s.jsx)("br",{}),"__proto__는 JavaScript가 [[Prototype]]을 주기로 한 약속으로써 Foo의 [[Prototype]]인 Object.prototype 객체를 줘버립니다."]}),(0,s.jsxs)("div",{className:"font-bold mt-5 mb-5",children:[(0,s.jsx)("div",{children:"단순하게 얘기해서, __proto__는 JavaScript엔진이 직접 제공하는 기능으로,"}),(0,s.jsx)("div",{children:"JavaScript가 객체의 [[Prototype]]을 반환하도록 되어있는 접근자(getter/setter) 입니다."})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("div",{className:"mb-5",children:"젠장, 그럼 Object.prototype.__proto__는 왜 있는 걸까요?"}),(0,s.jsx)("div",{children:"__proto__는 JavaScript 초창기 비표준 기능입니다."}),(0,s.jsx)("div",{children:"이것은 레거시코드 호환을 위해 존치되었고, 지금은 [[Prototype]]을 반환하는 동작을 하도록 되어있습니다."}),(0,s.jsx)("div",{children:"ECMAScript 표준화 과정에서 기존의 __proto__를 대신하여 [[Prototype]] 개념을 도입했고,"}),(0,s.jsx)("div",{children:"기존 코드와의 호환성을 유지하기 위해 __proto__를 남겨두었으나 결국 [[Prototype]]을 참조하는 형태입니다."}),(0,s.jsx)("div",{className:"mb-2",children:"최신 코드에서는 __proto__ 대신 Object.getPrototypeOf()를 사용하는 것이 권장됩니다."}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:"const obj = {};\nconsole.log(Object.getPrototypeOf(obj));  // Object.prototype\nconsole.log(obj.__proto__);  // 같은 값이지만 레거시 기능\n"})]})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{alt:"함수 [[ProtoType]]",children:[(0,s.jsx)("div",{children:"이제 함수입니다."}),(0,s.jsx)("div",{children:"앞서, 글로벌 Object는 함수였습니다."}),(0,s.jsx)("div",{children:"함수는 생성될 때, JavaScript가 [[Prototype]]으로 Function.prototype을 참조하게 하고 새 함수의 그릇을 만듭니다."}),(0,s.jsx)("div",{className:"mb-2",children:"그리고 Function.Prototype 객체는 [[Prototype]]으로 Object.prototype을 참조하고 있습니다."}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:"function Bar() {}\nconsole.dir(Bar);\nconsole.dir(Bar.name);"}),(0,s.jsx)("div",{children:"위와 같이, 함수인 Bar의 name을 찾게 되면,"}),(0,s.jsxs)("ul",{className:"list-decimal ml-10 mb-2",children:[(0,s.jsx)("li",{children:"Bar라는 그릇에서 name을 찾습니다."}),(0,s.jsxs)("li",{children:["Bar의 [[Prototype]]인",(0,s.jsx)("strong",{children:" Function.prototype"}),"에서 찾습니다."]}),(0,s.jsxs)("li",{children:["Function.prototype의 [[Prototype]]인 글로벌 Object의",(0,s.jsx)("strong",{children:" Object.prototype"}),"에서 찾습니다."]}),(0,s.jsxs)("li",{children:["생성자함수 Object.prototype의",(0,s.jsx)("strong",{children:" [[Prototype]]"}),"에서 찾습니다. null 입니다."]})]}),(0,s.jsxs)("div",{children:[(0,s.jsx)("div",{className:"font-bold",children:"최초 언급했듯 함수에는 prototype 속성이 있습니다."}),(0,s.jsxs)("div",{children:["** Bar.prototype.name을 하게되면, 함수가 생성되면서 만들어진",(0,s.jsx)("strong",{className:"pl-2",children:"Bar의 prototype 속성이 가리키는 객체에 name이 추가될 것입니다."})]}),(0,s.jsx)("div",{className:"font-bold mt-5 mb-5",children:"이것은, Function.prototype과 구별되어야 합니다."}),(0,s.jsx)("div",{className:"",children:"반면 객체인 Foo에 Foo.prototype.name을 한다면,"}),(0,s.jsx)("div",{children:"Foo 자체에 prototype이라는 속성이 없고 프로토타입체인으로 [[Prototype]]을 따라가 보아도 Object.prototype 내부에도 .prototype이 없기 때문에 오류가 날겁니다."})]})]}),(0,s.jsx)(l.A,{text:"다시 번역으로 돌아갑니다."}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"Here, we have an object as obj and it has a property called prop1. We can access this property by simply writing obj.prop1. As we know every object has a property called prototype(__proto__)is also an object. Say we have another property associated with proto as prop2. To access this property we don’t have to write obj.__proto__.prop2, we can simply say obj.prop2, and the JavaScript engine does the work of searching the prototype chain for those properties. Similarly for obj.prop3. This mechanism is nothing but the prototype chain."}),(0,s.jsx)("div",{className:"mt-2 mb-2",children:"객체 obj에 속성으로 prop1이 있습니다. 우리는 그냥 obj.prop1을 하면 접근이 됩니다. 모든 객체는 __proto__라고 불리는 속성을 가지며, 이 역시 객체입니다. __proto__에 prop2라는 다른 속성이 추가되어 있다고 해 봅시다. 이 속성에 접근하려고 obj.__proto__.prop2처럼 쓸 필요가 없습니다. 그냥 obj.prop2 하면 되죠. 자바스크립트 엔진은 프로토타입 체인을 통해 그렇게 동작합니다. obj.prop3도 마찬가지이며, 이 메커니즘을 프로토타입체인이라고 합니다."}),(0,s.jsx)(o.A,{text:"원문에는 여기서 이쁜 그림도 있습니다. 원하시면 상단의 링크를 따라가시면 됩니다."})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"When we call the property or method of an object, the browser checks to see if the actual object has the method on it, if not it checks if the method is available to it through its prototype object."}),(0,s.jsx)("div",{className:"mt-2",children:"객체의 속성이나 메소드를 호출 할 때, 브라우저는 해당 객체를 그것들을 가지고 있는지 확인합니다. 없으면 프로토타입 객체에서 할 수 있는지 체크합니다."})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{className:"mb-2",children:[(0,s.jsx)("div",{children:"If the method’s not defined on the prototype object, the browser checks up another level to see if the current prototype object has the method available on its prototype object. The browser will do this all the way up until it reaches the object at the top with null as its prototype."}),(0,s.jsx)("div",{className:"mt-2",children:"프로토타입에도 없다면, 브라우저는 한 단계 위의 프로토타입에 찾아갑니다. 브라우저는 최상위 레벨의 프로토타입까지 찾아가 null을 발견할때 까지 갈겁니다."})]}),(0,s.jsx)("br",{}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:"function Car(brandName, topSpeed, color) {\n  this.brandName = brandName,\n  this.topSpeed = topSpeed,\n  this.color = color\n}\n\nconst sportsCar = new Car('BMW', 330, 'black');\nCar.prototype.gearType = 'automatic';\nsportsCar.brandName\nsportsCar.color\nsportsCar.gearType\nsportsCar.hasOwnProperty('gearType') // false\nCar.hasOwnProperty('gearType') // false\nCar.prototype.hasOwnProperty('gearType') // true\n  "}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"In the above example, we have created a constructor called Car, which defines a brand new car."}),(0,s.jsx)("div",{className:"mt-2",children:"샘플을 보면, Car라는 생성자를 만들고 새 차를 생성 했습니다."})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"We create sportsCar and provide properties of brandName, topSpeed, and color. Then we added a property called gearType to the Car prototype object and assigned the value ‘automatic’ to it."}),(0,s.jsx)("div",{className:"mt-2",children:"sportsCar 객체를 만들고 brandName, topSpeed, and color 속성을 설정했습니다. 그 후, Car.prototype 에 gearType이라는 속성을 추가하고 value로 'automatic'을 할당 했습니다."})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsxs)("div",{children:["When we call any defined object property, ",(0,s.jsx)("br",{}),"it will give you the value because it is available in the object itself, ",(0,s.jsx)("br",{}),"and when we call gearType it will also give you the value but, ",(0,s.jsx)("br",{}),"the only difference is it is available in the objects constructor prototype."]}),(0,s.jsxs)("div",{className:"mt-2",children:["객체의 속성을 호출하면, ",(0,s.jsx)("br",{}),"객체 자체에 값이 존재하면 줍니다. ",(0,s.jsx)("br",{}),"그리고 gearType을 호출하면 또한 값을 줍니다 하지만, ",(0,s.jsx)("br",{}),"다른점은 객체의 생성자 prototype에 있었다는 겁니다."]})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsxs)("div",{children:["But if we check if either sportsCar. ",(0,s.jsx)("br",{}),"hasOwnProperty(‘gearType’) and Car.hasOwnProperty(‘gearType’) of ‘gearType’ and both return false, ",(0,s.jsx)("br",{}),"but Car.prototype.hasOwnProperty(‘gearType’) return true. ",(0,s.jsx)("br",{}),"That is a Javascript prototype-based inheritance."]}),(0,s.jsxs)("div",{className:"mt-2",children:["스포츠카를 확인하면, ",(0,s.jsx)("br",{}),"hasOwnProperty(‘gearType’)나 Car.hasOwnProperty(‘gearType’)에는 gearType 속성이 없습니다. ",(0,s.jsx)("br",{}),"대신 Car.prototype에 있습니다. ",(0,s.jsx)("br",{}),"이게 Javascript의 prototype 기반 상속입니다."]})]}),(0,s.jsx)("div",{className:"text-center font-bold m-5",children:"*\xa0\xa0\xa0 *\xa0\xa0\xa0 *"}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{children:"Now let’s get on with ES6 class."}),(0,s.jsx)("div",{className:"mt-2",children:"ES6 class를 보죠."})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)(a.A,{text:"Class Inheritance"}),(0,s.jsx)("div",{className:"",children:"클래스 상속"})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsxs)("div",{children:["A class is like a classification of the object to be created and in classical inheritance, ",(0,s.jsx)("br",{})," methods from the base class get copied into the derived class."]}),(0,s.jsxs)("div",{className:"mt-2",children:["클래스는 생성될 객체의 하나의 분류(설계도)와 같으며, 전통적인 상속"," ","방식에서는,",(0,s.jsx)("br",{}),"기본 클래스의 메서드가 파생 클래스로 복사됩니다."]})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsxs)("div",{children:["In class inheritance, ",(0,s.jsx)("br",{}),"it creates sub-class relationships by inheriting objects or methods from base class to derived class. ",(0,s.jsx)("br",{}),"The way we use the instance in Javascript, ",(0,s.jsx)("br",{}),"you can’t similarly make use of classes. ",(0,s.jsx)("br",{}),"To invoke methods, ",(0,s.jsx)("br",{}),"you must first instantiate an object of the class and then invoke."]}),(0,s.jsxs)("div",{className:"mt-2",children:["(전형적인) 클래스의 상속은, ",(0,s.jsx)("br",{}),"기본 클래스에서 파생 클래스로 객체와 메서드를 상속함으로써 서브 클래스 관계를 형성합니다. ",(0,s.jsx)("br",{}),"자바스크립트에서 구현체를 사용하는 방식은, ",(0,s.jsx)("br",{}),"클래스를 만드는것과 다릅니다. ",(0,s.jsx)("br",{}),"메소드를 호출하면, ",(0,s.jsx)("br",{}),"먼저 클래스의 구현체를 생성하고, 그 instantiate에서 호출 되어야 합니다.."]})]}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsxs)("div",{children:["Let’s understand it through example… ",(0,s.jsx)("br",{}),"Consider we have a class User as defined below"]}),(0,s.jsx)("div",{className:"mt-2",children:"예제를 보겠습니다. class User를 정의합니다."})]}),(0,s.jsx)("br",{}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:"class User {\n  constructor(name) {\n    this.username = name;\n  }\n\n  register() {\n    console.log(this.username)\n  }\n}\n\nlet john = new User('John');\njohn.register();\n  "}),(0,s.jsx)("br",{}),(0,s.jsxs)("section",{children:[(0,s.jsx)("div",{className:"font-bold",children:"Note: Since ES6, Class inheritance may or may not use the class keyword. Constructor functions are used, instead."}),(0,s.jsx)("div",{className:"mt-2",children:"노트: ES6이후, 클래스 상속시 class 키워드를 써도 되고 안써도 됩니다. 대신, 생성자 함수가 사용됩니다."}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"…and we would like to create another class as Member based on User class:"}),(0,s.jsx)("div",{className:"mt-2",children:"그리고 다른 클래스 Member를 User를 기본으로 해서 만들어 보겠습니다."}),(0,s.jsx)("br",{}),(0,s.jsx)(i.A,{codeType:"language-javascript",codeBlock:"class Member extends User {\n  constructor(name, email) {\n    super(name);\n    this.email = email;\n  }\n\n  getEmail() {\n    console.log(this.email)\n  }\n}\n\nlet anny = new Member('Anny', 'anny@gmail.com');\nanny.register();\nanny.getEmail();"}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"So, here in the above example, anny objects can have access to both User methods and Member methods."}),(0,s.jsx)("div",{className:"mt-2",children:"anny 객체는 User의 메소드와 Member의 method 모두에 접근이 됩니다."}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"Let’s understand how this works, internally extends keyword works using the prototype mechanism."}),(0,s.jsx)("div",{className:"mt-2",children:"이제, 그걸 이해해 보죠. extends 키워드는 내부적으로 프로토타입 메카니즘을 사용합니다."}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{className:"font-bold",children:"class Child extends Parent this will get converted into the prototype object i.e. Child.prototype.__proto__ will be Parent.prototype"}),(0,s.jsx)("div",{className:"mt-2 mb-2",children:"Child가 Parent를 extends하면, 프로토타입 객체로 변환 됩니다. 즉, Child.prototype.__proto__ 가 Parent.prototype를 가리킵니다."}),(0,s.jsx)(o.A,{text:"Child.prototype이 있다는건 함수라는 의미가 됩니다.\n글쓴이가 말하는 Child.prototype.__proto__ 에서,\n__proto__는 레거시 형식이지만 어쨓건 Child 함수가 가진 prototype 속성의 [[Prototype]]을 의미할 겁니다.\n원래는 Object.prototype가 되어야 하지만, Parent.prototype을 참조하도록 대체한다는 의미가 되겠네요.\n          "}),(0,s.jsx)("br",{}),(0,s.jsxs)("div",{children:["In our case: Member.prototype.__proto__ = User.prototype ",(0,s.jsx)("br",{}),"So if the method is not found in Member class, Javascript takes it from the User class. ",(0,s.jsx)("br",{}),"This is the basic idea of how class inheritance works on top of prototypal inheritance."]}),(0,s.jsxs)("div",{className:"mb-2",children:["이번 경우: Member.prototype.__proto__ = User.prototype ",(0,s.jsx)("br",{}),"따라서 Member의 클래스에 메소드를 찾지 못하면, 자바스크립트는 User 클래스를 찾습니다. ",(0,s.jsx)("br",{}),"이것이, 프로토타입 상속에 기반한 클래스 상속이 동작하는 기본 원리입니다."]}),(0,s.jsx)(o.A,{text:"메소드를 찾지 못하면,\nMember.prototype이 참조하고 있는 [[Prototype]]을 뒤져보려 할텐데, 애초에 Object.prototype이어야 할 것을,\nUser.prototype으로 되어있을테니 거기로 갔다는 거죠."}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"Well done for making it to the end of this article…!!!"}),(0,s.jsx)("div",{children:"수고하셨습니다."}),(0,s.jsx)("br",{})]}),(0,s.jsxs)("section",{children:[(0,s.jsx)(a.A,{text:"Conclusion"}),(0,s.jsx)("div",{children:"꽁꿀루숑"}),(0,s.jsx)("br",{}),(0,s.jsxs)("div",{children:["Classes from other languages like Java that don’t technically exist in Javascript but Classes are just syntactic sugar. ",(0,s.jsx)("br",{}),"It follows a prototype mechanism to achieve inheritance."]}),(0,s.jsxs)("div",{className:"mt-2",children:["Java 같은 다른 언어의 Class는 JavaScript에 기술적으로 존재하지 않습니다. ",(0,s.jsx)("br",{}),"JavaScript에서 Class는 단지 문법적 편의일 뿐입니다. ",(0,s.jsx)("br",{}),"JavaScript는 상속을 프로토타입 메카니즘을 통해 구현합니다."]}),(0,s.jsx)("br",{}),(0,s.jsxs)("div",{children:["Whether or not you agree with the inclusion of classes to the JS language, ",(0,s.jsx)("br",{}),"Prototypal Inheritance stands on its own as an elegant inheritance mechanism. ",(0,s.jsx)("br",{}),"Javascript is prototype-based only, in class inheritance also, it works in prototype mechanism."]}),(0,s.jsxs)("div",{className:"mt-2",children:["당신이 JavaScript의 Class에 동의하든 하지 않든, ",(0,s.jsx)("br",{}),"프로토타입 상속은 그 자체로 우아한 방식입니다. ",(0,s.jsx)("br",{}),"자바스크립트는 철저히 프로토타입 기반의 언어입니다. 상속도 마찬가지이며, 결국 프로토타입 메카니즘으로 작동합니다."]})]})]})}},7556:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>x});var s=t(698),r=t(5155),a=t(2761),i=t(2139),o=t(9969),l=t(908),c=t(2626),d=t.n(c),h=t(6167);function p(){let e=(0,s._)(["import { something } from 'some-library';"]);return p=function(){return e},e}function x(){return(0,r.jsxs)("div",{className:d().container,children:[(0,r.jsx)(a.A,{text:"Move on to ESM-only"}),(0,r.jsx)(h.A,{href:"https://antfu.me/posts/move-on-to-esm-only",prefix:"https://antfu.me/",text:"https://antfu.me/posts/move-on-to-esm-only"}),(0,r.jsx)(l.A,{text:"2025.2.17"}),(0,r.jsxs)("section",{className:d().paragraph,children:[(0,r.jsxs)("p",{children:[(0,r.jsx)("a",{href:"https://javascriptweekly.com/issues/723",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://javascriptweekly.com/issues/723"}),(0,r.jsx)("span",{children:"에 실린 링크를 통해 읽은 글입니다. 본문 해석에 오류가 있을 수 있어, 가능한 한 본문을 함께 실었습니다."})]}),(0,r.jsxs)("div",{className:"pt-2 pb-2",children:["최근 Fastify로 프로젝트를 만들면서, ESM으로 작성했습니다.",(0,r.jsx)("p",{children:"하지만, TypeScript를 스키마에만 적용하는데에도, 짜증나는 점이 많았습니다."}),(0,r.jsx)(h.A,{href:"https://github.com/dezcao/fastify-kubernetes-basic",title:"개인 프로젝트",prefix:"Fastify Basic 프로젝트",text:"https://github.com/dezcao/fastify-kubernetes-basic"})]}),(0,r.jsx)("p",{children:"설정에 노가다가 들어가는 부분도 그렇지만,"}),(0,r.jsx)("p",{children:"특히나 타입스크립트를 위한 번들링이 된 뒤에 import문이 찾고있는 파일에 대해서"}),(0,r.jsx)("p",{children:"확장자가 .ts로 남아있으면서 프로그램이 올바르게 실행되지 않았습니다."}),(0,r.jsx)("p",{className:"pt-2",children:"설정으로 해결하는 방법도 있는듯 하지만, 제 입장에서 가장 손쉽게 해결한건 .ts파일을 import 구문에서 .js로 입력하는 거였습니다."}),(0,r.jsx)("p",{children:"작동은 하지만, 실제 파일은 .ts이면서 import에서 .js로 적는 이질감은 상당했습니다."}),(0,r.jsx)("p",{className:"pt-2",children:"마침, ESM-only에 대한 글이 있어서 읽어봤습니다."}),(0,r.jsx)("p",{children:"생태계와 잇점을 생각하고 한일은 아니었지만, 어쨓든 ESM으로 하기를 잘한것 같다는 생각이 들었습니다."}),(0,r.jsx)("p",{children:"저는 vue에서 쓰던것과 같이, 일관된 문법으로 도배를 하고 싶어서 억지로 붙였던 것인데."}),(0,r.jsx)("p",{children:"아래 글에서 나오지만, 트리셰이킹으로 미세하나마 번들 크기도 줄어들 테니까요."})]}),(0,r.jsx)(l.A,{}),(0,r.jsx)(a.A,{text:"ESM-only로 이동하기"}),(0,r.jsxs)("section",{className:"mb-2",children:[(0,r.jsxs)("div",{children:[(0,r.jsx)("p",{children:"Three years ago, I wrote a post about shipping ESM & CJS in a single package,"}),(0,r.jsx)("p",{children:"advocating for dual CJS/ESM formats to ease user migration and trying to make the best of both worlds."})]}),(0,r.jsxs)("div",{className:"mt-2",children:[(0,r.jsx)("p",{children:"3년전, ESM과 CJS 두가지 포맷을 단일 패키지로 배포하는 글을 쓴적이 있습니다."}),(0,r.jsx)("p",{children:"두 포맷을 사용자가 쉽게 마이그레이션 하도록 돕고 두 방식의 장점을 살리려 노력했습니다. (마이그 - CJS에서 ESM으로 전환. ESM이 최신 권장)"})]})]}),(0,r.jsx)(o.A,{text:"shipping - 배포하다. 출시하다. 배송하다."}),(0,r.jsx)(l.A,{text:"잠시, 위에서 말하는 각 방식의 장점을 정리해 봅니다."}),(0,r.jsx)(i.A,{text:"ESM (ECMAScript Module)"}),(0,r.jsxs)("ul",{className:"list-disc ml-5 text-gray-900",children:[(0,r.jsx)("li",{children:"브라우저에서 호환이 됨."}),(0,r.jsx)("li",{children:"비동기 로딩 가능 (await import)"}),(0,r.jsxs)("li",{children:["Tree shaking : 번들 크기 최적화 가능. 필요한 모듈만 가져올 수 있음 (\xa0",String.raw(p())," )"]}),(0,r.jsx)("li",{children:"미래의 표준 : React, Vue, Vite등 ESM 기반으로 설계됨."})]}),(0,r.jsx)(i.A,{text:"CJS (CommonJS)"}),(0,r.jsxs)("ul",{className:"list-disc ml-5 text-gray-900",children:[(0,r.jsx)("li",{children:"동기적 로딩 : require()가 순차적으로 실행됨."}),(0,r.jsx)("li",{children:"__dirname, __filename 사용 가능. 파일 경로 다루기 편함. ESM은 import.meta.url 을 써야함."}),(0,r.jsx)("li",{children:'특별한 설정 없이 바로 require를 사용. ESM은 package.json에서 type: "module" 추가 필요.'})]}),(0,r.jsx)(l.A,{}),(0,r.jsxs)("section",{className:"mb-2",children:[(0,r.jsxs)("div",{className:"mb-2",children:[(0,r.jsx)("p",{children:"As of 2025, a decade has passed since ESM was first introduced in 2015."}),(0,r.jsx)("p",{children:"Modern tools and libraries have increasingly adopted ESM as the primary module format."}),(0,r.jsx)("p",{children:"According to WOOORM’s script, the packages that ships ESM on npm in 2021 was 7.8%,"}),(0,r.jsx)("p",{children:"and by the end of 2024, it had reached 25.8%."}),(0,r.jsx)("p",{children:"Although a significant portion of packages still use CJS, the trend clearly shows a good shift towards ESM."})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("p",{children:"2025년으로, 2015년 ESM이 소개된지 10년이 되었다."}),(0,r.jsx)("p",{children:"최근 개발 도구와 라이브러리들은 점차 ESM을 우선으로 채택하고 있다."}),(0,r.jsx)("p",{children:"WOOORM’s script에 따르면, 2021년 npm에서 ESM으로 배포된 패키지는 7.8% 였고,"}),(0,r.jsx)("p",{children:"2024년 말에 25.8%가 되었다."}),(0,r.jsx)("p",{children:"상당한 패키지들이 여전히 CJS를 쓰지만, ESM으로의 바람직한 전환이 뚜렷한 추세를 보였다. [원문에서는 여기에 이미지가 있습니다. 궁금하시면 상단에 공유된 원문 링크로.]"})]})]}),(0,r.jsxs)("section",{className:"mb-2",children:[(0,r.jsx)("p",{children:"Here in this post, I’d like to share my thoughts on the current state of the ecosystem and why I believe it’s time to move on to ESM-only."}),(0,r.jsx)("p",{children:"이번 글에서, 현제의 생태계 상황과 ESM-only로 해야할 때라는 나의 생각을 공유해 보겠다."})]}),(0,r.jsxs)("section",{children:[(0,r.jsxs)("div",{children:[(0,r.jsx)(i.A,{text:"The Toolings are Ready",type:"h2"}),(0,r.jsx)("p",{children:"도구가 준비 되었다."})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)(i.A,{text:"Morder tools"}),(0,r.jsx)("p",{children:"With the rise of Vite as a popular modern frontend build tool,"}),(0,r.jsx)("p",{children:"many meta-frameworks like Nuxt, SvelteKit, Astro, SolidStart, Remix, Storybook, Redwood, and many others"}),(0,r.jsx)("p",{children:"are all built on top of Vite nowadays, that treating ESM as a first-class citizen."})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("p",{children:"비트(Vite)가 인기있는 최근 프론트 빌드 도구로 떠오르면서,"}),(0,r.jsx)("p",{className:"mb-2",children:"많은 meta-frameworks(Nuxt, SvelteKit etc)들이 비트를 기반으로 구축되었고, ESM을 최우선으로 지원한다."}),(0,r.jsx)(o.A,{text:"Meta-framework - 기존 프레임워크 위에서 동작하는 프레임워크. ex, Next(React 기반)/Nuxt(Vue 기반)"})]})]}),(0,r.jsxs)("section",{className:"mt-2",children:[(0,r.jsxs)("div",{children:[(0,r.jsx)("p",{children:"As a complement, we have also testing library Vitest,"}),(0,r.jsx)("p",{children:"which was designed for ESM from the day one with powerful module mocking capability and efficient fine-grain caching support."})]}),(0,r.jsxs)("div",{children:[(0,r.jsx)("p",{children:"보충하자면, 테스팅 라이브러리인 Vitetest 같은것은, "}),(0,r.jsx)("p",{className:"mb-2",children:"처음부터 ESM을 기반으로 설계 되었고, 강력한 모듈 모킹과 효과적인 세밀한 캐싱이 지원된다."})]}),(0,r.jsx)(o.A,{text:"from the day one - 처음부터\n          fine-grain - 세밀한"})]}),(0,r.jsxs)("section",{className:"mt-2",children:[(0,r.jsx)("p",{children:"CLI tools like tsx and jiti offer a seamless experience for running TypeScript and ESM code without requiring additional configuration."}),(0,r.jsx)("p",{children:"This simplifies the development process and reduces the overhead associated with setting up a project to use ESM."}),(0,r.jsx)("p",{children:"tsx나 jiti같은 CLI 툴들은 추가적인 설정 없이 타입스크립트와 ESM코드를 원활하게 경험할 수 있도록 지원한다."}),(0,r.jsx)("p",{className:"mb-2",children:"이는 개발 프로세스가 단순해지고 ESM을 세팅하는데 필요한 부담을 줄인다."}),(0,r.jsx)("p",{children:"Other tools, for example, ESLint, in the recent v9.0, introduced a new flat config system that enables native ESM support with eslint.config.mjs, even in CJS projects."}),(0,r.jsx)("p",{children:"예를들어, 최근의 ESLint v9.0에서는 CJS 프로젝트에서도 ESM을 지원하는 설정이 가능해졌다."})]}),(0,r.jsx)("section",{children:(0,r.jsxs)("div",{children:[(0,r.jsx)(i.A,{text:"Top-Down & Bottom-Up"}),(0,r.jsxs)("div",{children:[(0,r.jsx)("p",{children:"Back in 2021, when SINDRESORHUS first started migrating all his packages to ESM-only, for example, find-up and execa, it was a bold move."}),(0,r.jsx)("p",{children:"2021년, SINDRESORHUS가 자신의 모든 패키지를 ESM 전용으로 마이그를 시작했을때, 예를들어 find-up과 execa같은, 그건 대담한 일이었다."}),(0,r.jsx)("p",{children:"I consider this move as a bottom-up approach, as the packages that rather low-level and many their dependents are not ready for ESM yet."}),(0,r.jsx)("p",{children:"나는 이걸 상향식 접근으로 본다. 그 패키지들은 비교적 저수준의 것이고, 그들에 의존하는 많은 것들이 아직 ESM에 대해 준비되지 않았기 때문이다."}),(0,r.jsx)("p",{children:"I was worried that this would force those dependents to stay on the old version of the packages,"}),(0,r.jsx)("p",{children:"난 그 의존하던 것들이 구버전에 머물러 있도록 강요 될까 걱정했다,"}),(0,r.jsx)("p",{children:"which might result in the ecosystem being fragmented."}),(0,r.jsx)("p",{children:"그로인해 생태계가 파편화될까 두려웠다."}),(0,r.jsx)("p",{children:"(As of today, I actually appreciate that move bringing us quite a lot of high-quality ESM packages, regardless that the process wasn’t super smooth)."}),(0,r.jsx)("p",{children:"지금은, 그 움직임이 우리가 꽤 많은 고품질 ESM 패키지로 얻게 했다는걸 인정한다, 비록 과정이 아주 매끄럽진 못했음에도 말이다."}),(0,r.jsx)("p",{className:"mt-2",children:"It’s way easier for an ESM or Dual formats package to depend on CJS packages, but not the other way around."}),(0,r.jsx)("p",{children:"ESM이나 듀얼 포맷이 CJS 패키지에 의존하는 것이 그 반대보다 쉽다."}),(0,r.jsx)("p",{children:"In terms of smooth adoption, I believe the top-down approach is more effective in pushing the ecosystem forward."}),(0,r.jsx)("p",{children:"원활한 도입의 면에서 보면, 하향식이 생태계를 나아가게 하는데 더 효과적이라고 본다."}),(0,r.jsx)("p",{children:"With the support of high-level frameworks and tools from top-down, it’s no longer a significant obstacle to use ESM-only packages."}),(0,r.jsx)("p",{children:"고수준 프레임워크와 도구의 하향식 지원으로, ESM-only 패키지를 하는데 더이상 큰 장애물이 없다."}),(0,r.jsx)("p",{children:"The remaining challenges in terms of ESM adoption primarily lie with package authors needing to migrate and ship their code in ESM format."}),(0,r.jsx)("p",{children:"남은 과제는 (npm)패키지 작성자들이 ESM 형식으로 변환하고 배포하는데 있다."})]})]})}),(0,r.jsxs)("section",{children:[(0,r.jsx)(i.A,{text:"Requiring ESM in Node.js"}),(0,r.jsxs)("div",{className:"mb-2",children:[(0,r.jsxs)("p",{children:["The capability to require() ESM modules in Node.js, initiated by JOYEECHEUNG, marks an incredible milestone.",(0,r.jsx)("br",{})," This feature allows packages to be published as ESM-only while still being consumable by CJS codebases with minimal modifications.",(0,r.jsx)("br",{}),"It helps avoid the async infection (also known as Red Functions) introduced by dynamic import() ESM, which can be pretty hard,",(0,r.jsx)("br",{}),"if not impossible in some cases, to migrate and adapt."]}),(0,r.jsxs)("p",{children:[(0,r.jsx)("span",{children:"Node.js에서 require()로 ESM 모듈을 가능하게는, JOYEECHEUNG에 의해 시적된, 놀라운 이정표가 되었다."}),(0,r.jsx)("br",{}),(0,r.jsx)("span",{children:"이 기능으로 ESM-only 패키지 배포가 CJS기반에서 최소한의 수정으로 사용이 가능하다."}),(0,r.jsx)("br",{}),(0,r.jsx)("span",{children:"이것은 동적 import() 기반의 ESM이 초래하는 async 전염을 막고(Red Functions으로 알려진),"}),(0,r.jsx)("br",{}),(0,r.jsx)("span",{children:"Red Functions은 마이그레이션과 적용을, 경우에 따라 불가능할 정도로, 어렵게 한다."})]}),(0,r.jsxs)("p",{className:"mt-2",children:["( 위에서 말하는 레드 펑션에 대한 링크 :",(0,r.jsx)("a",{href:"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/"}),")"]})]}),(0,r.jsxs)("div",{className:"mb-2",children:[(0,r.jsxs)("p",{children:["This feature was recently unflagged and backported to Node.js v22 (and soon v20), ",(0,r.jsx)("br",{}),"which means it should be available to many developers already."," ",(0,r.jsx)("br",{}),"Consider the top-down or bottom-up metaphor, ",(0,r.jsx)("br",{}),"this feature actually makes it possible to start ESM migration also from middle-out, ",(0,r.jsx)("br",{}),"as it allows import chains like ESM → CJS → ESM → CJS to work seamlessly."]}),(0,r.jsxs)("p",{children:["최근 플래그가 해제되어(정식 기능이 됨) Node.js v22(곧 v20도) 이미 많은 개발자가 사용할 수 있음을 뜻한다. ",(0,r.jsx)("br",{}),"탑다운이나 바텀업 방식의 비유를 볼때, ",(0,r.jsx)("br",{}),"이 기능은 미들아웃(중간부터의) 마이그를 시작할 수 있게 한다. ",(0,r.jsx)("br",{}),"ESM → CJS → ESM → CJS 같은 import 체인을 원활히 할 수 있게 해주기 때문이다."]}),(0,r.jsxs)("p",{className:"mt-2",children:["For more details on the progress and discussions around this feature, keep track on this issue. ",(0,r.jsx)("br",{}),"이 기능의 진행상황과 논의는 이 이슈(링크)를 참조.",(0,r.jsx)("br",{}),(0,r.jsx)("a",{href:"https://github.com/nodejs/node/issues/52697",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://github.com/nodejs/node/issues/52697"})]})]})]}),(0,r.jsx)("section",{children:(0,r.jsxs)("div",{children:[(0,r.jsx)(i.A,{text:"The Troubles with Dual Formats",type:"h2"}),(0,r.jsx)("p",{children:"듀얼 포맷의 문제점"}),(0,r.jsxs)("p",{className:"mt-4",children:["While dual CJS/ESM packages have been a quite helpful transition mechanism, ",(0,r.jsx)("br",{}),"they come with their own set of challenges. ",(0,r.jsx)("br",{}),"Maintaining two separate formats can be cumbersome and error-prone,"," ",(0,r.jsx)("br",{}),"especially when dealing with complex codebases."]}),(0,r.jsxs)("p",{className:"mt-2",children:["듀얼 패키지 포맷은 전환 과정에 유용하지만, ",(0,r.jsx)("br",{}),"자체적인 문제도 가진다. ",(0,r.jsx)("br",{}),"두개를 유지하는것은 번거롭고 오류를 유발하기 쉽다, ",(0,r.jsx)("br",{}),"특히 복잡한 코드에서 더 그렇다."]}),(0,r.jsxs)("p",{className:"mt-2",children:["Here are some of the issues that arise when maintaining dual formats:",(0,r.jsx)("br",{}),"다음은 듀얼포맷의 몇가지 문제들이다."]}),(0,r.jsx)(i.A,{text:"Interop Issues: 호환성 문제"}),(0,r.jsxs)("p",{children:["Fundamentally, CJS and ESM are different module systems with distinct design philosophies. ",(0,r.jsx)("br",{}),"Although Node.js has made it possible to import CJS modules in ESM, dynamically import ESM in CJS, and even require() ESM modules,"," ",(0,r.jsx)("br",{}),"there are still many tricky cases that can lead to interop issues."]}),(0,r.jsxs)("p",{className:"mb-2",children:["근원적으로, CJS와 ESM은 서로 다른 철학으로 설계된 별개의 모듈 시스템이다. ",(0,r.jsx)("br",{}),"비록 Node.js에서 ESM에 CJS 모듈을 import하거나, CJS에서 ESM을 동적으로 import 하거나, 심지어 requrie()로 ESM 모듈을 가능하게 했지만, ",(0,r.jsx)("br",{}),"여전히 호환성 문제를 야기할 수 있는 까다로운 문제들이 많다."]}),(0,r.jsx)(o.A,{text:"Interop - Interoperability. 상호운용성."}),(0,r.jsxs)("p",{className:"mt-5",children:["One key difference is that CJS typically uses a single module.exports object, ",(0,r.jsx)("br",{}),"while ESM supports both default and named exports. ",(0,r.jsx)("br",{}),"When authoring code in ESM and transpiling to CJS, ",(0,r.jsx)("br",{}),"handling exports can be particularly challenging, ",(0,r.jsx)("br",{}),"especially when the exported value is a non-object, ",(0,r.jsx)("br",{}),"such as a function or a class. ",(0,r.jsx)("br",{}),"Additionally, to make the types correct, we also need to introduce further complications with .d.mts and .d.cts declaration files. And so on…"]}),(0,r.jsxs)("p",{className:"mt-2",children:["주요차이점 하나는 CJS가 일반적으로 단일 moudule.exports 객체를 쓸 때, ",(0,r.jsx)("br",{}),"ESM은 default 와 named를 모두 지원한다. ",(0,r.jsx)("br",{}),"ESM에서 작성하고 CJS로 바꿀때, ",(0,r.jsx)("br",{}),"exports는 다루기 어렵게 된다, ",(0,r.jsx)("br",{}),"특히 내보내는 것이 객체가 아니라, 함수나 클래스이면. ",(0,r.jsx)("br",{}),"게다가, 타입을 올바르게 유지하려면, .d.mts와 c.cts를 선언하는 더 복잡한 과정이 필요하다. 등."]}),(0,r.jsxs)("p",{className:"mt-5",children:["As I am trying to explain this problem deeper, ",(0,r.jsx)("br",{}),"I found that I actually wish you didn’t even need to be bothered with this problem at all. ",(0,r.jsx)("br",{}),"It’s frankly too complicated and frustrating. ",(0,r.jsx)("br",{}),"If you are just a user of packages, let alone the package authors to worry about that. ",(0,r.jsx)("br",{}),"This is one of the reasons I advocate for the entire ecosystem to transition to ESM, to leave these problems behind and spare everyone from this unnecessary hassle."]}),(0,r.jsxs)("p",{className:"mt-2 mb-2",children:["더 깊이 설명하려 할 때, ",(0,r.jsx)("br",{}),"당신이 이 문제로 귀찮지 않았으면 좋겠다는 생각이 들었다. ",(0,r.jsx)("br",{}),"솔직히 너무 복잡하고 짜증난다. ",(0,r.jsx)("br",{}),"패키지 작성자는 물론이고, 단지 패키지 사용자로도 그런걸 걱정해야 한다면. ",(0,r.jsx)("br",{}),"이게 내가 ESM으로 생태계를 전환하자는 이유중 하나이다, ",(0,r.jsx)("br",{}),"이 문제를 뒤로하고 불필요한 논쟁에서 벗어나기 위해서다."]}),(0,r.jsx)(o.A,{text:"let alone - 물론\n                   hassle - 격론"}),(0,r.jsx)(i.A,{text:"Dependency Resolution: 의존성 관리리"}),(0,r.jsxs)("p",{className:"mt-5",children:["When a package has both CJS and ESM formats, the resolution of dependencies can become convoluted. ",(0,r.jsx)("br",{}),"For example, if a package depends on another package that only ships ESM, ",(0,r.jsx)("br",{}),"the consumer must ensure that the ESM version is used. ",(0,r.jsx)("br",{}),"This can lead to version conflicts and dependency resolution issues, especially when dealing with transitive dependencies."]}),(0,r.jsxs)("p",{className:"mt-2 mb-2",children:["패키지가 두 형태로 되어있을때, 이존성 해결은 꼬일 수 있다. ",(0,r.jsx)("br",{}),"예를들어, ESM전용으로된 패키지를 의존하는 패키지는, 사용자가 ESM으로만 쓸 수있게 보장된다. ",(0,r.jsx)("br",{}),"이건 버전 충돌과 의존성 이슈를 유발할 수 있다 특히, 전이적 의존성일때."]}),(0,r.jsx)(o.A,{text:"convoluted - 둘둘 말린\n                   transitive dependencies - 전이적 의존. 또 다른 의존성에 의존."}),(0,r.jsxs)("p",{className:"mt-2 mb-2",children:["Also for packages that are designed to used with singleton pattern,"," ",(0,r.jsx)("br",{}),"this might introduce multiple copies of the same package and cause unexpected behaviors. ",(0,r.jsx)("br",{}),"싱글톤 패턴으로 설계된 패키지의 경우, ",(0,r.jsx)("br",{}),"같은 패키지가 여러 개 로드될 수 있고 의도치 않은 동작을 유발 할 수 있다."]}),(0,r.jsx)(i.A,{text:"Package Size: 패키지 크기"}),(0,r.jsxs)("p",{children:["Shipping dual formats essentially doubles the package size, as both CJS and ESM bundles need to be included. ",(0,r.jsx)("br",{}),"While a few extra kilobytes might not seem significant for a single package, ",(0,r.jsx)("br",{}),"the overhead can quickly add up in projects with hundreds of dependencies, leading to the infamous node_modules bloat. ",(0,r.jsx)("br",{}),"Therefore, package authors should keep an eye on their package size."," ",(0,r.jsx)("br",{}),"Moving to ESM-only is a way to optimize it, especially if the package doesn’t have strong requirements on CJS."]}),(0,r.jsxs)("p",{className:"mt-2",children:["듀얼 포맷은 패키지 사이즈를 두배로 만든다, 두 번들이 모두 포함되야 하기 때문이다. ",(0,r.jsx)("br",{}),"단일 패키지에 몇킬로 바이트는 무제가 안될 수 있지만, ",(0,r.jsx)("br",{}),"수백 개의 의존성을 가진 프로젝트에서는 이런 자원소모(overhead)는 엄청난 node_modules 증가를 빠르게 초래한다. ",(0,r.jsx)("br",{}),"따라서, 패키지 제작자는 사이즈에서 눈을 떼면 안된다. ",(0,r.jsx)("br",{}),"ESM전용으로 전환하는것이 최적화하는 방법이다, 특히 CJS가 필수적이지 않다면."]})]})}),(0,r.jsx)("section",{children:(0,r.jsxs)("div",{children:[(0,r.jsx)(i.A,{text:"When Should We Move to ESM-only?",type:"h2"}),(0,r.jsx)("p",{children:"언제 ESM 전용으로 할까."}),(0,r.jsxs)("p",{children:[(0,r.jsx)("br",{}),"This post does not intend to diminish the value of dual-format publishing. ",(0,r.jsx)("br",{}),"Instead, I want to encourage evaluating the current state of the ecosystem and the potential benefits of transitioning to ESM-only."," ",(0,r.jsx)("br",{}),"듀얼포맷을 폄하 하려는게 아니다. ",(0,r.jsx)("br",{}),"대신, 현재 생태계를 평가하고 ESM전용으로 하는 잠재적 이익에 대해 권장하고 싶다. ",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"There are several factors to consider when deciding whether to move to ESM-only: ",(0,r.jsx)("br",{}),"전향하는데 고려할 몇가지 요소가 있다."]}),(0,r.jsx)(i.A,{text:"New Packages"}),(0,r.jsxs)("p",{children:["I strongly recommend that all new packages be released as ESM-only, as there are no legacy dependencies to consider. ",(0,r.jsx)("br",{}),"New adopters are likely already using a modern, ESM-ready stack, there being ESM-only should not affect the adoption. ",(0,r.jsx)("br",{}),"Additionally, maintaining a single module system simplifies development, reduces maintenance overhead, and ensures that your package benefits from future ecosystem advancements. ",(0,r.jsx)("br",{}),"기존 의존성을 고려할 필요가 없는 신규 패키지면 강력이 권한다. ",(0,r.jsx)("br",{}),"신규 사용자는 이미 최신 ESM 지원환경을 사용하고 있을것이고, 전용으로 해도 적용에 문제가 없을 것이다. ",(0,r.jsx)("br",{}),"게다가, 단일한 모듈로 개발하면 단순해지고, 유지보수 비용이 줄고, 향후 생태게 발전의 잇점을 누리기도 쉬워진다."]}),(0,r.jsx)(i.A,{text:"Browser-targeted Packages"}),(0,r.jsxs)("p",{children:["If a package is primarily targeted for the browser, it makes total sense to ship ESM-only. ",(0,r.jsx)("br",{}),"In most cases, browser packages go through a bundler, where ESM provides significant advantages in static analysis and tree-shaking."," ",(0,r.jsx)("br",{}),"This leads to smaller and more optimized bundles, which would also improve loading performance and reduce bandwidth consumption for end users. ",(0,r.jsx)("br",{}),"브라우저를 우선으로 한다면, ESM전용이 가장 좋다. ",(0,r.jsx)("br",{}),"대부분, 브라우저패키지는 번들러를 거치는데, 정적 분석과 트리셰이킹에서 잇점이 있다. ",(0,r.jsx)("br",{}),"이건 더 작고 최적화된 번들과 로딩 성능 개선, 유저의 네트워크 사용을 줄여준다."]}),(0,r.jsx)(i.A,{text:"Standalone CLI"}),(0,r.jsxs)("p",{children:["For a standalone CLI tool, it’s no difference to end users whether it’s ESM or CJS. ",(0,r.jsx)("br",{}),"However, using ESM would enable your dependencies to also be ESM, facilitating the ecosystem’s transition to ESM from a top-down approach. ",(0,r.jsx)("br",{}),"독립실행 툴일때, ESM이든 CJS든 차이는 없다. ",(0,r.jsx)("br",{}),"그러나, ESM을 쓰면 당신 패키지가 의존하는 패키지가 ESM을 사용하게 할 것이고, 탑다운 방식으로 생태계를 촉진할것이다."]}),(0,r.jsx)(o.A,{text:"CLI - Command-Line Interface (ex, git, npm, ESLint).\nCLI가 개발환경을 주도하고 있어서, 소비주체인 CLI가 오히려 의존패키지들에게 영향을 준다는것 같습니다(탑다운). 예를들어, ESLint v9가 ESM-only가 되었음.\n            "}),(0,r.jsx)(i.A,{text:"Node.js Support"}),(0,r.jsxs)("p",{children:["If a package is targeting the evergreen Node.js versions, ",(0,r.jsx)("br",{}),"it’s a good time to consider ESM-only, especially with the recent require(ESM) support. ",(0,r.jsx)("br",{}),"최신 Node.js버전을 대상으로 하면, ESM-only를 고려하기 좋을 때입니다. 특히 최근엔 require(ESM)이 지원되니까요."]}),(0,r.jsx)(i.A,{text:"Know Your Consumers"}),(0,r.jsxs)("p",{children:["If a package already has certain users, it’s essential to understand the dependents’ status and requirements. ",(0,r.jsx)("br",{}),"For example, for an ESLint plugin/utils that requires ESLint v9,"," ",(0,r.jsx)("br",{}),"while ESLint v9’s new config system supports ESM natively even in CJS projects, ",(0,r.jsx)("br",{}),"there is no blocker for it to be ESM-only. ",(0,r.jsx)("br",{}),"이미 패키지에 사용자가 있다면, 의존상태와 요구를 이해해야 한다."," ",(0,r.jsx)("br",{}),"예를들어 ESLint v9를 쓰는 플러그인과 유틸의 경우, ",(0,r.jsx)("br",{}),"린트가 CJS프로젝트에서 ESM을 지원하는 환경을 제공하므로, ",(0,r.jsx)("br",{}),"ESM-only로 이동하는데 장애물이 없을 겁니다. ",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"Definitely, there are different factors to consider for different projects. ",(0,r.jsx)("br",{}),"But in general, I believe the ecosystem is ready for more packages to move to ESM-only, ",(0,r.jsx)("br",{}),"and it’s a good time to evaluate the benefits and potential challenges of transitioning. ",(0,r.jsx)("br",{}),"프로젝트마다 고려할 요소는 다를 수 있다. ",(0,r.jsx)("br",{}),"하지만 대게, 이제 생태계는 준비되었고, ",(0,r.jsx)("br",{}),"전환으로의 이점과 잠재적 과제를 평가할 좋은 시기이다."]})]})}),(0,r.jsx)("section",{children:(0,r.jsxs)("div",{children:[(0,r.jsx)(i.A,{text:"How Far We Are?",type:"h2"}),(0,r.jsx)("p",{children:"얼마나 왔나."}),(0,r.jsx)("br",{}),(0,r.jsxs)("p",{children:["The transition to ESM is a gradual process that requires collaboration and effort from the entire ecosystem. ",(0,r.jsx)("br",{}),"Which I believe we are on a good track moving forward. ",(0,r.jsx)("br",{}),"To improve the transparency and visibility of the ESM adoption,"," ",(0,r.jsx)("br",{}),"I recently built a visualized tool called Node Modules Inspector for analyzing your packages’s dependencies. ",(0,r.jsx)("br",{}),"It provides insights into the ESM adoption status of your dependencies and helps identify potential issues when migrating to ESM. ",(0,r.jsx)("br",{}),"전환은 생태계의 협력과 노력이 필요한 점진적 과정입니다. ",(0,r.jsx)("br",{}),"우리는 잘 가고 있다고 생각합니다. ",(0,r.jsx)("br",{}),"ESM 적용의 투명성과 가시성을 향상시키기 위해, ",(0,r.jsx)("br",{}),"패키지 의존성을 분석하는 Node Modules Inspector라는 시각화 툴을 개발했습니다. ",(0,r.jsx)("br",{}),"의존성의 ESM 적용에 대한 통찰을 제공하고, 전환에 대한 잠재적 문제를 식별하는데 도움을 줄겁니다. ",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"This tool is still in its early stages, ",(0,r.jsx)("br",{}),"but I hope it will be a valuable resource for package authors and maintainers to track the ESM adoption progress of their dependencies and make informed decisions about transitioning to ESM-only. ",(0,r.jsx)("br",{}),"To learn more about how to use it and inspect your projects, check the repository ",(0,r.jsx)("br",{}),"시작단계지만, 패키지 제작자와 유지보수 담당자에게 의존라이브러리의, ESM 적용 상황을 추적하고 ESM-only으로 전향하는데 더나은 결정을 하는데 도움이 되기 바랍니다. ",(0,r.jsx)("br",{}),(0,r.jsx)("a",{href:"https://github.com/antfu/node-modules-inspector",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://github.com/antfu/node-modules-inspector"}),"(본문에는 이미지도 있습니다.)"]})]})}),(0,r.jsx)("section",{children:(0,r.jsxs)("div",{children:[(0,r.jsx)(i.A,{text:"Moving Forward",type:"h2"}),(0,r.jsx)("p",{children:"앞으로"}),(0,r.jsx)("br",{}),(0,r.jsxs)("p",{children:["the dependencies we rely on. ",(0,r.jsx)("br",{}),"We also have plenty of exciting ideas for the Node Modules Inspector, aiming to provide more useful insights and help find the best path forward. ",(0,r.jsx)("br",{}),"I look forward to a more portable, resilient, and optimized JavaScript/TypeScript ecosystem. ",(0,r.jsx)("br",{}),"I hope this post has shed some light on the benefits of moving to ESM-only and the current state of the ecosystem. ",(0,r.jsx)("br",{}),"If you have any thoughts or questions, feel free to reach out using the links below. Thank you for reading! ",(0,r.jsx)("br",{}),"저는 제가 관리하는 패키지들을 점진적으로 ESM-only로 전환하고 의존하는 것들을 살펴볼 것입니다. ",(0,r.jsx)("br",{}),"또, Node Modules Inspector에 아이디어들이 있고, 더 유용한 통찰과 최적의 전환경로를 찾는데 도움이 될 것들을 추가할 예정입니다. ",(0,r.jsx)("br",{}),"더 경량의, 탄력적인, 최적의 JS/TS 환경을 기대합니다. ",(0,r.jsx)("br",{}),"전환에 대한 이점과 상황을 이해하는데 도움이 되었기를 바랍니다."," ",(0,r.jsx)("br",{}),"당신의 생각이나 질문을, 편하게 아래 링크로 연락해 주셔도 됩니다."," ",(0,r.jsx)("br",{}),(0,r.jsx)("a",{href:"https://antfu.me/",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://antfu.me/"}),"(글쓴이는 블로그에서 이메일도 되는것 같습니다. X는 가입을 안해서 저자의 링크를 못땄습니다.)"]})]})}),(0,r.jsx)(l.A,{text:"옮기고 나서"}),(0,r.jsxs)("section",{children:["의외로, 저자가 React가 아니라 Vue, Nuxt팀인것을 알게 되었습니다. ",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"요즘 구직환경에서, 점점 React로의 편중을 느끼는 와중에 반갑다 해야할지."," ",(0,r.jsx)("br",{}),"이름에 Fu라고 하는것으로 보아, 중국계인가 봅니다. Vue의 창시자 Evan Yu 처럼요. ",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"글은 긴데 요약하면, 두 줄 같습니다.",(0,r.jsxs)("ul",{className:"list-disc ml-5",children:[(0,r.jsx)("li",{children:"생태계가 ESM으로 가고 있다."}),(0,r.jsx)("li",{children:"당신도 가자.."})]}),(0,r.jsx)("br",{}),"개인적인 생각일 뿐이나, ",(0,r.jsx)("br",{}),"Vue의 입지는 앞으로 더 줄어들것 같습니다. ",(0,r.jsx)("br",{}),"불과 몇 년 사이, 구직시장에서 온도차가 피부로 느껴질 정도로 차갑습니다."," ",(0,r.jsx)("br",{}),"그냥, 내가 안팔리는 건가...",(0,r.jsx)("br",{}),(0,r.jsx)("br",{}),"하지만, 저는 Vue를 더 좋게 생각합니다.",(0,r.jsx)("br",{}),"벌레 수준이지만, 공부를 위해, 이 블로그를 React SSG로 만들면서 React코드가 조금 더 난잡해지기 쉽다는 생각이 들었습니다.",(0,r.jsx)("br",{}),"React가 모든것은 함수이다라는 철학에서 시작했기 때문에, 태그를 함수에 끼웠지만, ",(0,r.jsx)("br",{}),"바로 그것 때문에 시각적으로 난잡하다고 느꼈습니다."]})]})}},763:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>u});var s=t(5155),r=t(2761),a=t(908),i=t(2626),o=t.n(i),l=t(6167),c=t(5483),d=t(8173),h=t.n(d),p=t(9969),x=t(2139);function u(){return(0,s.jsxs)("div",{className:o().container,children:[(0,s.jsx)(r.A,{text:"Oracle justified its JavaScript trademark with Node.js—now it wants that ignored"}),(0,s.jsx)(l.A,{href:"https://deno.com/blog/deno-v-oracle2",prefix:"Deno.com",text:"https://deno.com/blog/deno-v-oracle2"}),(0,s.jsx)(a.A,{text:"2025.03.07"}),(0,s.jsxs)("section",{children:['이럴수가, Oracle이 "JavaScript" 상표권을 가지고 있었다는걸 처음 알게 되었습니다.',(0,s.jsx)("br",{}),"Deno의 창시자 Ryan Dahl(또한, Node.js 창시자)가 USPTO(미국 특허청)에 상표권 취소 요청을 제출했다고 하네요.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"모두의 것인줄 알았던 것에 주인이 있었다고? 개인적으로 깜짝 놀랐고. Deno가, 아니, 우리가 이겼으면 좋겠습니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"본문을 읽다보면, JavaScript를 풀어줄 것에 서명하는 링크가 있습니다.",(0,s.jsx)("br",{}),(0,s.jsx)(h(),{href:"https://javascript.tm/",target:"_blank",className:"text-blue-600 hover:underline hover:text-yellow-600",children:"javascript.tm (서명하는 링크입니다.)"})," ","깃헙 계정이 있으면 클릭 몇번으로 서명이 되네요."," "]}),(0,s.jsx)(a.A,{}),(0,s.jsx)(r.A,{text:"오라클, Node.js를 앞세워 JavaScript 상표권을 주장해놓고—이제 와서 외면하려 한다"}),(0,s.jsxs)(c.A,{children:["Yesterday, Oracle filed"," ",(0,s.jsx)(h(),{href:"https://ttabvue.uspto.gov/ttabvue/v?pno=92086835&pty=CAN&eno=7",target:"_blank",className:"text-blue-400 hover:underline hover:text-yellow-400",children:"a motion to dismiss"})," ","in response to Deno’s petition to cancel its “JavaScript” trademark. But instead of addressing the real issue—that JavaScript is an open standard with multiple independent implementations—Oracle is trying to stall the process and sidestep accountability."]}),(0,s.jsxs)("section",{children:['오라클이 Deno의 "JavaScript" 상표권 취소 청원에 대해서 기각 요청을 제출했습니다.',(0,s.jsx)("br",{}),"그러나—JavaScript가 다수의 독립적인 구현체를 가진 공개 표준—이라는 실질적 문제로 다투는 대신,",(0,s.jsx)("br",{}),"절차적으로 지연시키며 해명을 회피할 목적으로 보입니다."]}),(0,s.jsx)(x.A,{text:"개요"}),(0,s.jsxs)(c.A,{children:["Two years ago, I published"," ",(0,s.jsx)(h(),{href:"https://tinyclouds.org/trademark",target:"_blank",className:"text-blue-400 hover:underline hover:text-yellow-400",children:"a blog post"})," ","asking Oracle to release the JavaScript trademark as a goodwill gesture. That got no response.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Last September, I published an"," ",(0,s.jsx)(h(),{href:"https://javascript.tm/",target:"_blank",className:"text-blue-400 hover:underline hover:text-yellow-400",children:"open letter"})," ","co-signed by Brendan Eich (creator of JavaScript), current TC39 editors, and over 16,000 JavaScript developers. Many were shocked to learn that Oracle even claimed ownership of JavaScript. Oracle still said nothing.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"So last November, I filed"," ",(0,s.jsx)(h(),{href:"https://deno.com/blog/deno-v-oracle",target:"_blank",className:"text-blue-400 hover:underline hover:text-yellow-400",children:"a formal petition with the USPTO"})," ","through my company, Deno, to cancel Oracle’s “JavaScript” trademark. Among other things, we pointed out that in 2019, Oracle renewed its trademark by submitting a screenshot of the Node.js website—a project I created—as proof of use, despite having no affiliation with it.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Our petition challenges Oracle’s trademark on three grounds:",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsxs)("ul",{className:"list-disc ml-10",children:[(0,s.jsx)("li",{children:"Genericness – JavaScript is a widely used programming language, not an Oracle product."}),(0,s.jsx)("li",{children:"Abandonment – Oracle does not control, maintain, or enforce the trademark."}),(0,s.jsx)("li",{children:"Fraud on the USPTO – Oracle submitted misleading evidence in its renewal filing."})]}),(0,s.jsx)("br",{}),"You can read the full peititon for cancellation"," ",(0,s.jsx)(h(),{href:"https://deno.com/blog/deno-v-oracle/petition-for-cancellation.pdf",target:"_blank",className:"text-blue-400 hover:underline hover:text-yellow-400",children:"here"}),"."]}),(0,s.jsxs)("section",{children:["2년전, 게시한"," ",(0,s.jsx)(h(),{href:"https://tinyclouds.org/trademark",target:"_blank",className:"text-blue-600 hover:underline hover:text-yellow-600",children:"이 글에서"})," ","오라클에게 JavaScript 상표권을 풀어줄 것을 정중히 요청하였다. 응답은 없었다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"지난 9월, 공개한"," ",(0,s.jsx)(h(),{href:"https://javascript.tm/",target:"_blank",className:"text-blue-600 hover:underline hover:text-yellow-600",children:"서신"})," ","은, Brendan Eich (creator of JavaScript), 현 TC39 에디터들, 그리고 16,000명이 넘는 JavaScript 개발자들의 서명이 있었다. 많은 이들이 오라클이 JavaScript에 권리를 주장하고 있는것을 알고 충격을 받았다."," ",(0,s.jsx)("br",{}),"오라클은 대답하지 않았다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"그래서 지난 11월, 나는"," ",(0,s.jsx)(h(),{href:"https://deno.com/blog/deno-v-oracle",target:"_blank",className:"text-blue-600 hover:underline hover:text-yellow-600",children:"USPTO에 정식 청원으로"})," ","나의 회사, Deno, 명의로 Oracle의 “JavaScript” 상표권 취소를 제기 하였다.",(0,s.jsx)("br",{}),"특히, 2019년, 오라클이 상표권을 갱신하면서, 자신들과는 아무 관련 없는 Node.js 웹사이트 스크린샷을—내가 만든 프로젝트이다—증빙으로 제출했다는 점을 지적했다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"우리의 청원은 오라클의 상표권에 대해 세 가지 문제를 제기했다 :",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsxs)("ul",{className:"list-disc ml-10",children:[(0,s.jsx)("li",{children:"일반성 – JavaScript는 오라클의 제품을 위해서가 아니라 널리 사용되는 프로그래밍 언어이다."}),(0,s.jsx)("li",{children:"방치 – 오라클은 상표를 관리, 유지보수, 보강하지 않았다."}),(0,s.jsx)("li",{children:"USPTO를 속였다 – 오라클이 상표권 갱신을 하면서, 거짓 증빙을 제출했다."})]}),(0,s.jsx)("br",{}),"취소청원의 전문을 보려면"," ",(0,s.jsx)(h(),{href:"https://deno.com/blog/deno-v-oracle/petition-for-cancellation.pdf",target:"_blank",className:"text-blue-600 hover:underline hover:text-yellow-600",children:"이곳"}),"."]}),(0,s.jsx)(x.A,{text:"오라클의 방어: “그 제출한 증빙? 무시해라.”"}),(0,s.jsxs)(c.A,{children:["Oracle has finally responded—but only to the fraud claim. Their argument: Yes, we used a screenshot from Node.js, but it doesn’t matter because we also submitted another specimen.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Here’s how they frame our petition in their filing:",(0,s.jsx)("br",{}),(0,s.jsxs)("div",{className:"border-l-4 px-3",children:["“The Petition ignores completely that Oracle submitted two specimens.",(0,s.jsx)("br",{}),"Moreover, on its face, the Petition fails to allege a claim of fraud as to the renewal in Class 42 because the specimen it touts as ‘fraudulent’ was submitted to support only the renewal in Class 9 and not Class 42.”"]}),(0,s.jsx)("br",{}),"Oracle’s JavaScript trademark covers both software products (Class 9) and technology services (Class 42). Their argument is that the Node.js screenshot was only for Class 9 and that their primary specimen—an Oracle JET page—was sufficient for both.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{className:"border-l-4 px-3",children:"“Petitioner has not challenged and could not plausibly challenge the JAVASCRIPT Extension Toolkit page from Oracle’s own website that Oracle submitted as its primary specimen in Class 9 and as its only specimen in Class 42.”"}),(0,s.jsx)("br",{}),"This raises serious questions:",(0,s.jsx)("br",{}),(0,s.jsxs)("ul",{className:"list-disc ml-10",children:[(0,s.jsx)("li",{children:"If Oracle’s primary specimen (a screenshot of Oracle JET) was truly sufficient, why submit a screenshot of Node.js at all?"}),(0,s.jsx)("li",{children:"Oracle JET isn’t even a standalone JavaScript runtime—it’s a UI toolkit."}),(0,s.jsx)("li",{children:"Has anyone even used Oracle JET, or is it just there to keep the trademark alive?"}),(0,s.jsx)("li",{children:"Oracle never explained why it used a screenshot from a project it had no connection to."})]}),(0,s.jsx)("br",{}),"They even go as far as saying:",(0,s.jsx)("br",{}),(0,s.jsx)("div",{className:"border-l-4 px-3",children:"“Oracle does not concede that submission of the Node.js Specimen was improper. However, the Board need not address that question in connection with this Motion.”"}),(0,s.jsx)("br",{}),"Oracle isn’t denying that it used my project—it’s just arguing that it doesn’t matter. If a company misrepresents something in a legal filing, you’d expect them to acknowledge it. But Oracle hasn’t even addressed it. No apology. No explanation. Just an attempt to move past it as if nothing happened.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"I created Node.js and released it under the MIT license to benefit developers, not so it could be used as a legal pawn by a Fortune 500 company. Now, instead of correcting their misrepresentation, they’re using it to stall the case."]}),(0,s.jsxs)("section",{children:["Oracle은 마침내 대응했습니다—오직 거짓 증거 제출에 대해서만 말이죠.",(0,s.jsx)("br",{}),"그들의 논리: 네, 우리가 Node.js 스샷을 썻습니다. 하지만, 그건 문제가 안됩니다",(0,s.jsx)("br",{}),"왜냐하면 다른 것도 제출했기 때문입니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"우리의 청원에 대해서 그들(Oracle)이 제시한 프레임:",(0,s.jsx)("br",{}),(0,s.jsxs)("div",{className:"border-l-4 px-3",children:["“이 청원은 오라클이 두가지 증빙을 제시한걸 완전히 무시했다.",(0,s.jsx)("br",{}),"게다가, 그것대로, Class 42 갱신과 관련해 사기라고 주장할 수가 없다. 청원의 주장은 Class 9에만 해당하기 때문이다."]}),(0,s.jsx)("br",{}),"오라클의 JavaScript 상표권은 소프트웨어 제품(Class 9)과 기술 서비스(Class 42)를 포함한다.",(0,s.jsx)("br",{}),"그들의 주장은 Node.js 스크린샷이 Class 9만 해당되며, 주요 증빙 자료로 제출한 —Oracle JET 페이지—가 두 Class 모두를 뒷받침하는데 충분하다고 합니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{className:"border-l-4 px-3",children:"“청원인은 오라클이 Class 9의 주요 증빙 자료이자 Class 42의 유일한 증빙 자료로 제출한 JAVASCRIPT Extension Toolkit 페이지에 대해 문제를 제기하지 않았고 그럴듯한 문제를 제기하지도 못 할 것이다.”"}),(0,s.jsx)("br",{}),"여기엔 심각한 의문이 제기된다:",(0,s.jsx)("br",{}),(0,s.jsxs)("ul",{className:"list-disc ml-10",children:[(0,s.jsx)("li",{children:"만약 Oracle의 주요 증빙 (Oracle JET 스샷)이 정말 충분한 증거가 되면, 왜 Node.js도 제출 했나?"}),(0,s.jsx)("li",{children:"Oracle JET는 독자적인 JavaScript 런타임이 아닙니다—그저 UI 툴킷일 뿐이죠."}),(0,s.jsx)("li",{children:"Oracle JET을 사용하는 사람 있나요? 그냥 JET 사이트만 있으면 상표권이 유지됩니까?"}),(0,s.jsx)("li",{children:"Oracle은 자신들과 아무 상관 없는 스크린샷을 사용했으면서 여전히 어떠한 설명도 내놓지 않습니다."})]}),(0,s.jsx)("br",{}),"심지어 이렇게까지 말하고 있습니다:",(0,s.jsx)("br",{}),(0,s.jsxs)("div",{className:"border-l-4 px-3",children:["“Oracle은 Node.js를 증거로 제시한 것이 잘못이라 생각지 않는다.",(0,s.jsx)("br",{}),"그래도, 이사회는 이런 청원에 대해 언급하지 않을 것이다.”"]}),(0,s.jsx)("br",{}),"Oracle은 내 프로젝트를 사용한 사실을 부정하지 않으면서, 그게 문제가 없다고 합니다.",(0,s.jsx)("br",{}),"우리는, 만약 어떤 기업이 법적 제출물을 잘못 낸다면, 인정은 할거라 기대합니다.",(0,s.jsx)("br",{}),"하지만 Oracle은 그에 대해 언급도 없고, 사과도 없고, 설명 없습니다.",(0,s.jsx)("br",{}),"그냥 아무일도 없었던 것처럼 지나가겠답니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"저는 개발자들의 이익을 위해 Node.js를 만들었고, MIT 라이센스로 배포했습니다.",(0,s.jsx)("br",{}),"Fortune 500에 속하는 회사가 마음대로 법적인 제출물에 쓰라고 만든게 아닙니다.",(0,s.jsx)("br",{}),"그들은 잘못된 제출물을 바로잡는게 아니라, 제기된 건을 지연시키는 데 이용하고 있습니다."]}),(0,s.jsx)("img",{className:"mt-3",src:"/image/slug/specimens.png"}),(0,s.jsx)(x.A,{text:"절차 지연시키기"}),(0,s.jsxs)(c.A,{children:["Oracle waited until the deadline to file this motion, delaying their response to the real issue: whether “JavaScript” is a generic term.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{className:"border-l-4 px-3",children:"“This motion tolls the deadline to otherwise answer the Petition, and Oracle requests that the Board reset the answer deadline to at least 30 days after the date of its decision on this motion.”"}),(0,s.jsx)("br",{}),"Oracle won’t even discuss whether “JavaScript” should remain a trademark until they’ve finished dragging out this fraud claim.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"This legal maneuvering puts us in a difficult position:",(0,s.jsxs)("ul",{className:"list-decimal ml-10",children:[(0,s.jsx)("li",{children:"Agree to drop the fraud claim, letting them get away with misrepresenting their trademark renewal."}),(0,s.jsx)("li",{children:"Spend months fighting this procedural issue before even getting to the real debate."})]})]}),(0,s.jsxs)("section",{children:["Oracle은 이 대응을 마감직전까지 기다렸습니다.",(0,s.jsx)("br",{}),"그러면서도 정작 핵심 문제에 대한 대답은 지연시키고 있습니다: “JavaScript”는 일반 명사이다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{className:"border-l-4 px-3",children:"“이 기각 요청(motion, Oracle의 기각요청)은 (Deno의)청원에 대한 답변 기한을 중단시키며, Oracle은, 이사회가 기각 요청을 결의하는데 시간이 소요되었으므로, 이 청원에 대한 답변 기한을 최소 30일 연장해 줄것을 요청함.”"}),(0,s.jsx)("br",{}),"Oracle은 부정확한 증거 제출 문제를 가지고 시간을 질질 끌면서, 이 문제가 끝날 때까지 “JavaScript” 상표권에 대해서는 논의도 못하게 하고 있습니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"이 법기술이 우리를 어렵게 만들고 있습니다:",(0,s.jsxs)("ul",{className:"list-decimal ml-10",children:[(0,s.jsx)("li",{children:"거짓 증거라는 주장을 철회하라, 이렇게 된다면 그들은 상표권 갱신에 자기들이 잘못 사용한 제출물 문제를 피해가게 될겁니다."}),(0,s.jsx)("li",{children:"실제 쟁점은 논쟁조차 못하고 절차 문제로 여러 달을 소모하게 되는 겁니다."})]})]}),(0,s.jsx)(x.A,{text:"진짜 문제"}),(0,s.jsxs)(c.A,{children:["The situation is self-evident to anyone working in tech: Oracle did not create JavaScript. Oracle does not control JavaScript. Oracle should not own the trademark for JavaScript.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"JavaScript is defined by an open specification (ECMA-262), maintained by TC39, an industry group with representatives from Google, Apple, Microsoft, Mozilla, and others. The major implementations of JavaScript are in the browsers built by Mozilla, Google, Apple, and Microsoft. Oracle has no role in JavaScript’s governance, implementation, or evolution—yet it continues to wield this trademark as a legal cudgel.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"This isn’t just about JavaScript. If Oracle can hold onto this trademark, what does that say about the trademark system as a whole? Should corporations be able to warehouse trademarks indefinitely, even when they play no meaningful role in the things they claim to own? Even when they commit fraud to maintain them?",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"A company with no role in JavaScript’s past or future has no right to control its name."]}),(0,s.jsxs)("section",{children:["이 상황은 tech 분야에서 일하는 누구에게나 명백합니다: Oracle은 JavaScript를 만들지 않았습니다. Oracle은 JavaScript로 아무것도 안했습니다. Oracle이 JavaScript 상표권을 가져선 안됩니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"JavaScript는 공개표준(ECMA-262)로 정의되고, TC39가 이를 유지보수 하고 있습니다. TC39는 Google, Apple, Microsoft, Mozilla, 그밖에 산업을 대표하는 이들입니다. JavaScript의 주요 구현체들은 Mozilla, Google, Apple, 그리고 Microsoft같은 곳에서 만든 브라우저에서 실행됩니다. Oracle은 JavaScript의 관리, 구현, 발전에 아무런 역할도 안했습니다— 그저 상표권을 법적인 무기로 활용할 궁리를 하고 있습니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"이건 JavaScript만의 문제가 아닙니다.",(0,s.jsx)("br",{}),"만약 Oracle이 이걸 지켜내게 되면, 전체 상표권 시스템에 어떤 영향이 미칠까요?",(0,s.jsx)("br",{}),"기업이 실질적 역할은 하지 않고 영원히 자기 보관함에 두었다가, 본인들 것이라 주장할 수 있습니까?",(0,s.jsx)("br",{}),"상표 유지를 위해 허위 증거를 제출해도 됩니까?",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"JavaScript에서 과거와 미래에 아무것도 하지 않을 회사가 그 이름을 소유할 권리는 없습니다."]}),(0,s.jsx)("br",{}),(0,s.jsx)(p.A,{text:"만약 Oracle이 끝내 승리하고, 빌런으로 나서는 최악의 세계선을 상상해 보았습니다.\n          1. 특정 상표 관련 제품에 대해 라이선스를 요구.\n          2. 네임드 개발자들이 어떻게든 다른 대안을 찾아 제시하고, JS로 이루어진 생태계가 서서히 옮겨가려는 힘이 작동되면,\n          새로운 생산물을 고민하는 대신 동일한 생산물을 오직 다른 언어로 대체하기 위해, 인류급 시간과 에너지를 쓰는 상황.\n\n          2번은 Oracle도 얻는게 없으니 희박 하겠지만, 상표권 자체는 어떻게든 놓지 않으려 할지도."}),(0,s.jsx)(x.A,{text:"돕는 방법"}),(0,s.jsxs)(c.A,{children:[(0,s.jsxs)("ul",{className:"list-disc ml-5",children:[(0,s.jsx)("li",{children:"Share this post and spread awareness about Oracle’s trademark claim."}),(0,s.jsxs)("li",{children:["Sign the open letter at"," ",(0,s.jsx)(h(),{href:"https://javascript.tm/",target:"_blank",className:"text-blue-400 hover:underline hover:text-yellow-400",children:"javascript.tm"})," "]}),(0,s.jsx)("li",{children:"If you’re a journalist, reach out—I’m happy to talk."})]}),(0,s.jsx)("br",{}),"Let one thing be clear: we are not intimidated by Oracle’s legal maneuvering, and we will continue to fight this case on its very strong merits. You can"," ",(0,s.jsx)(h(),{href:"https://bsky.app/profile/deno.land",target:"_blank",className:"text-blue-400 hover:underline hover:text-yellow-400",children:"follow us here"})," ","to be kept up to date."]}),(0,s.jsxs)("section",{children:[(0,s.jsxs)("ul",{className:"list-disc ml-5",children:[(0,s.jsx)("li",{children:"Oracle의 상표권 주장에 대해 널리 알려주세요."}),(0,s.jsxs)("li",{children:[(0,s.jsx)(h(),{href:"https://javascript.tm/",target:"_blank",className:"text-blue-600 hover:underline hover:text-yellow-600",children:"javascript.tm"})," ","에서 서명에 참여 해주세요."]}),(0,s.jsx)("li",{children:"기자시면, 연락 주세요—기꺼이 이야기 하겠습니다."})]}),(0,s.jsx)("br",{}),"한가지는 확실합니다:",(0,s.jsx)("br",{}),"우리는 Oracle의 법적 전략에 굴복하지 않을 것이며, 이 사안에서 계속 강하게 싸울것입니다. ",(0,s.jsx)("br",{}),(0,s.jsx)(h(),{href:"https://bsky.app/profile/deno.land",target:"_blank",className:"text-blue-600 hover:underline hover:text-yellow-600",children:"여기를 팔로우"})," ","하시면 최신 소식을 받아보실 수 있습니다."]}),(0,s.jsx)("img",{className:"mt-3",src:"/image/slug/organizational_charts.png"}),(0,s.jsx)(h(),{href:"https://bonkersworld.net/organizational-charts",target:"_blank",className:"text-blue-600 hover:underline hover:text-yellow-600",children:"https://bonkersworld.net/organizational-charts"})," ",(0,s.jsx)(a.A,{text:"이 글을 읽고 나서, 관련된 정보를 알아 보았습니다."}),(0,s.jsxs)("section",{children:["JavaScript는 원래 Netscape가 만든 언어이다.",(0,s.jsx)("br",{}),"1995년, Netscape에서 Brendan Eich가 개발하였고,",(0,s.jsx)("br",{}),"처음에는 Mocha → LiveScript라고 불리다가,",(0,s.jsx)("br",{}),"Sun Microsystems가 Java와 연관성을 강조하기 위해 JavaScript로 이름을 바꿈. (실제로 Java와는 관련 없음)",(0,s.jsx)("br",{}),'Sun Microsystems가 "JavaScript" 상표를 등록',(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"2010년, Oracle이 Sun Microsystems를 인수 (아... 지못미. 넷스케이프는 MS의 똥덩어리 익스플로러 때문에 피해를 보기도 했건만)",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"Deno의 주장 요약:",(0,s.jsx)("br",{}),"JavaScript는 오픈 스탠다드이며, 특정 기업이 소유해서는 안 된다.",(0,s.jsx)("br",{}),"Oracle은 이 상표를 적극적으로 사용하지 않았다.",(0,s.jsx)("br",{}),"Oracle은 2019년 상표권 갱신 시 Node.js 웹사이트의 스크린샷을 제출했고 이건 사기 행위에 해당한다. (Node.js와 Oracle은 무관함)",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"원문에 게시된 마지막 이미지의 의미를 유추해 보건데,",(0,s.jsx)("br",{}),"Oracle은, 거대한 법무팀과 상대적으로 쪼그만 엔지니어링 팀을 상징하는 것 같습니다. 기술보다 법이 더 중심인 회사.",(0,s.jsx)("br",{}),"그밖에, MS는 부서들 끼리 서로 견제하고 싸우는 모양 같습니다.",(0,s.jsx)("br",{}),(0,s.jsx)("br",{}),"그림의 원 출처"," ",(0,s.jsx)(h(),{href:"https://bonkersworld.net/organizational-charts",target:"_blank",className:"text-blue-600 hover:underline hover:text-yellow-600",children:"https://bonkersworld.net/organizational-charts"})," ","를 따라가 보면, 만들어진 시기가 2011-06-27 입니다.",(0,s.jsx)("br",{}),"즉, 이일을 풍자하기 위해 새로 그려진 것이 아님에도, 아무런 위화감이 없네요."]})]})}},8373:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>l});var s=t(5155),r=t(2761),a=t(908),i=t(2626),o=t.n(i);function l(){return(0,s.jsxs)("div",{className:o().container,children:[(0,s.jsx)(r.A,{text:"Git 수정사항 제거 명령어 선택 플로우차트"}),(0,s.jsx)(a.A,{text:"2025.03.03"}),(0,s.jsxs)("section",{className:o().paragraph,children:[(0,s.jsx)("strong",{children:"출처 : 팀을 위한 Git - (저자) 엠마 제인 호그빈 웨스트비"}),(0,s.jsx)("br",{}),"책에 소개된 플로우 차트를 옮겨 그렸습니다."]}),(0,s.jsx)(a.A,{}),(0,s.jsx)("img",{className:"mt-3",src:"/image/slug/gitFlowChart.webp"})]})}},6335:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>x});var s=t(5155),r=t(7711);t(8452);var a=t(2761),i=t(908),o=t(2626),l=t.n(o),c=t(5483),d=t(8173),h=t.n(d),p=t(9969);function x(){let e=(0,r.default)(()=>t.e(773).then(t.bind(t,7773)).then(e=>e.default),{loadableGenerated:{webpack:()=>[7773]},ssr:!1});return(0,s.jsxs)("div",{className:l().container,children:[(0,s.jsx)(a.A,{text:"Google Place API(new), NUXT UI를 활용하여 주소검색 만들기."}),(0,s.jsx)(i.A,{text:"2025.08.29"}),(0,s.jsxs)("section",{className:l().paragraph,children:[(0,s.jsx)("strong",{children:"프로젝트 : Ecormarine. Oceanlook_xp 화물운송 웹 프로젝트"}),(0,s.jsx)("br",{}),(0,s.jsxs)("span",{children:["화물을 위한 출발지, 도착지가 ",(0,s.jsx)("strong",{children:"해외 주소"}),"를 포함해야 하는 경우가 있어, ",(0,s.jsx)("strong",{children:"Google Place API(new)"}),"를 이용하기로 결정하였음."]}),(0,s.jsx)("br",{}),(0,s.jsx)("span",{children:"구글에서 필요한 라이브러리 활성화: Maps JavaScript API , Places API(New)"}),(0,s.jsx)("br",{}),(0,s.jsx)(h(),{href:"https://developers.google.com/maps/documentation/javascript/load-maps-js-api?hl=ko&_gl=1*14oa674*_up*MQ..*_ga*MzY2ODEwNTc0LjE3NTU0ODY4NzM.*_ga_NRWSTWS78N*czE3NTU0OTQyMTIkbzMkZzEkdDE3NTU0OTQyOTIkajQ3JGwwJGgw",className:"text-blue-600 hover:underline pl-1",children:"공식문서 : Maps JavaScript API"}),(0,s.jsx)("br",{}),(0,s.jsx)(h(),{href:"https://github.com/googlemaps/js-api-loader",className:"text-blue-600 hover:underline pl-1",children:"NPM 라이브러리 : https://github.com/googlemaps/js-api-loader"}),(0,s.jsx)("br",{})]}),(0,s.jsx)(i.A,{text:"첫 번째, 삽질"}),(0,s.jsxs)("section",{className:l().paragraph,children:["api 요청 자체를 구현함. 이러면, 사용전에 js가 다 로딩 되었는지도 확인해야함. 그러나, 구글은 npm으로 공식 js를 제공하고 있어 이럴 필요가 없었음. ",(0,s.jsx)("br",{}),(0,s.jsx)("strong",{children:"@googlemaps/js-api-loader"})," 사용하는게 나음.",(0,s.jsx)(c.A,{title:"직접 API 요청 구현 코드 보기",children:(0,s.jsx)(e,{language:"javascript",code:'// 첫 번째 삽질: 직접 NUXT Plugin에서 API 요청 구현 (비효율적)\n// plugins/google-places.client.js\nexport default defineNuxtPlugin(() => {\n  const config = useRuntimeConfig();\n\n  if (window._googleReady) {\n    return { provide: { googleReady: window._googleReady } };\n  }\n\n  const ready = new Promise((resolve, reject) => {\n    // 이미 준비됨\n    if (window.google?.maps?.importLibrary) {\n      resolve();\n      return;\n    }\n\n    const SCRIPT_ID = "google-maps-js";\n    const POLL_MS = 120;\n    const MAX_WAIT_MS = 15_000;\n\n    let intervalId = null;\n    let timeoutId = null;\n    let done = false;\n\n    const cleanup = () => {\n      if (intervalId) {\n        clearInterval(intervalId);\n        intervalId = null;\n      }\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n      // 이벤트 핸들러 제거\n      const s = document.getElementById(SCRIPT_ID);\n      if (s) {\n        s.onload = null;\n        s.onerror = null;\n      }\n    };\n\n    const finish = (ok, value) => {\n      if (done) return;\n      done = true;\n      cleanup();\n      ok ? resolve(value) : reject(value);\n    };\n\n    const ensureScript = () => {\n      let s = document.getElementById(SCRIPT_ID);\n      if (!s) {\n        s = document.createElement("script");\n        s.id = SCRIPT_ID;\n        s.async = true;\n        s.src =\n          "https://maps.googleapis.com/maps/api/js" +\n          "?key=" + encodeURIComponent(config.public.googleApiKey) +\n          "&loading=async&v=weekly";\n        s.onerror = () =>\n          finish(false, new Error("Failed to load Google Maps JS"));\n        s.onload = () => {\n          // 로드 직후 한 번 체크\n          if (window.google?.maps?.importLibrary) finish(true);\n        };\n        document.head.appendChild(s);\n      }\n    };\n\n    // 폴링 시작\n    const startPolling = () => {\n      intervalId = setInterval(() => {\n        if (window.google?.maps?.importLibrary) {\n          finish(true);\n        } else if (window.google?.maps?.places?.Autocomplete) {\n          // 구버전 API가 로드된 경우도 성공으로 처리\n          console.log("구버전 Places API 감지됨");\n          finish(true);\n        }\n      }, POLL_MS);\n\n      // 타임아웃 가드\n      timeoutId = setTimeout(() => {\n        finish(\n          false,\n          new Error("Timed out waiting for google.maps.importLibrary"),\n        );\n      }, MAX_WAIT_MS);\n    };\n\n    ensureScript();\n    startPolling();\n  });\n\n  window._googleReady = ready;\n  return { provide: { googleReady: ready } };\n});\n'})}),(0,s.jsx)(c.A,{title:"Nuxt UI로 구현한 주소검색 컴포넌트 코드 보기",children:(0,s.jsx)(e,{language:"javascript",code:'<script setup>\nconst text = defineModel("text", { type: String, default: "" });\nconst lng = defineModel("lng", { type: Number, default: null });\nconst lat = defineModel("lat", { type: Number, default: null });\nconst placeId = defineModel("placeId", { type: String, default: "" });\n\nconst emit = defineEmits(["select", "clear"]);\nconst host = ref(null);\nconst { $googleReady } = useNuxtApp(); // 04.google-places.client.js 주입.\n\nconst updateModels = (data) => {\n  text.value = data.text || "";\n  lng.value = data.lng || null;\n  lat.value = data.lat || null;\n  placeId.value = data.placeId || "";\n  emit("select", data);\n};\n\nconst clearModels = () => {\n  text.value = "";\n  lng.value = null;\n  lat.value = null;\n  placeId.value = "";\n  emit("clear");\n};\n\n\nconst init = async () => {\n  // https://developers.google.com/maps/documentation/javascript/add-google-map-wc-tut?hl=ko&_gl=1*11vhrr6*_up*MQ..*_ga*MTg0MzYxNjczNS4xNzU1NDgwMDE2*_ga_NRWSTWS78N*czE3NTU0ODAwMTUkbzEkZzEkdDE3NTU0ODA1MTUkajYwJGwwJGgw#step-2\n  try {\n    // 1) 스크립트 로딩 대기\n    await $googleReady;\n\n    // 2) Places (New) 로드\n    await google.maps.importLibrary("places");\n    const { PlaceAutocompleteElement } = google.maps.places;\n    if (!PlaceAutocompleteElement)\n      throw new Error("PlaceAutocompleteElement not available");\n\n    // 3) 엘리먼트 생성 + 옵션(이상한 옵션 끼우면 에러나서 모두 뺌)\n    const el = new PlaceAutocompleteElement(); // 이 엘리먼트에서 gmp-select 이벤트가 트리거되어 옴.\n    el.placeholder = "주소를 입력하세요";\n\n    el.requestOptions = {\n      includedPrimaryTypes: ["geocode"],\n      locationRestriction: {\n        country: "KR",\n      },\n    };\n\n    // 4) 선택 이벤트: gmp-select\n    el.addEventListener("gmp-select", async (ev) => {\n      try {\n        const prediction = ev?.placePrediction; // 예측 객체\n        if (!prediction) return;\n\n        const place = prediction.toPlace(); // 예측 객체를 장소 객체로 변경\n\n        // 과금 (타이핑은 0)\n        await place.fetchFields({\n          fields: ["id", "formattedAddress", "location", "displayName"],\n        });\n\n        const loc = place.location;\n        const data = {\n          text: place.formattedAddress || place.displayName || "",\n          placeId: place.id,\n          lng: loc?.lng(),\n          lat: loc?.lat(),\n          place: place.toJSON(),\n          apiVersion: "Places API (New)",\n        };\n\n        updateModels(data);\n      } catch (err) {\n        console.error("Place (New) select error:", err);\n      }\n    });\n\n    el.addEventListener("click", () => {\n      if (!el.value) {\n        clearModels();\n      }\n    });\n\n    host.value.appendChild(el); // html 요소 붙임.\n  } catch (err) {\n    console.warn("Places (New) 사용 불가, 레거시 API로 폴백:", err);\n  }\n};\n\nonMounted(() => {\n  init();\n  console.log("OcnAddress mounted.", document.querySelector("gmp-place-text-search-request"));\n});\n\ndefineExpose({\n  clearModels,\n  updateModels,\n});\n<\/script>\n\n<template>\n  <div\n    class="w-full border border-gray-300 rounded-md bg-white shadow-sm transition-all duration-200 hover:border-gray-400 focus-within:border-blue-500 focus-within:ring-2 focus-within:ring-blue-500/20 overflow-visible relative"\n  >\n    <div ref="host" class="w-full" />\n  </div>\n</template>\n\n\x3c!--쉐도우돔 내부 클리어 버튼은 접근이 어려움--\x3e\n\x3c!--https://jsfiddle.net/gh/get/library/pure/googlemaps-samples/js-api-samples/tree/main/dist/samples/place-autocomplete-basic-map/jsfiddle--\x3e'})})]}),(0,s.jsx)(i.A,{text:"두 번째, 삽질"}),(0,s.jsxs)("section",{className:l().paragraph,children:["구글이 쉐도우돔을 사용하고 있고, closed된 쉐도우 돔이라. 허용된 요소를 통해서만 조작이 가능함.",(0,s.jsx)("br",{}),"그런데 이때, 어떻게든 인풋영역의 높이를 줄여 다른 디자인 요소와 높이를 맞출 수는 있었지만, 클리어 버튼의 CSS 변경은 불가능했음.",(0,s.jsx)("br",{}),"결국, 클리어 버튼위로 마우스가 올라가면 높이를 초과하는 만큼의 효과가 나타남.",(0,s.jsx)("br",{}),"첫 번째 삽질의 교훈을 살려, NPM 라이브러리 중에서 Wrapping된 구글 주소록이 있을까 하여 찾아보았음...",(0,s.jsx)("br",{}),"내가 못찾은걸 수 있으나, React용에 비하여 Vue 진영의 라이브러리 생태계가 약하다는 사실만 확인함. 좌절감이 들었음."]}),(0,s.jsx)(i.A,{text:"세 번째, 삽질"}),(0,s.jsxs)("section",{className:l().paragraph,children:["구글이 제공하는 라이브러리가 CommonJs 방식이라 아래와 같은 오류가 남, Nuxt4에서는 그냥 클라이언트 전용으로 하였음. (onMounted 내부에서 import)",(0,s.jsx)("br",{}),(0,s.jsx)(p.A,{text:"`   Named export 'Loader' not found. The requested module   '@googlemaps/js-api-loader' is a CommonJS module, which may not   support all module.exports as named exports. CommonJS modules can   always be imported via the default export, for example using: import   pkg from '@googlemaps/js-api-loader'; const {Loader} = pkg;   `"})]}),(0,s.jsx)(i.A,{text:"최종 완성. Nuxt UI와 결합시킴"}),(0,s.jsxs)("section",{className:l().paragraph,children:["현재 프로젝트가 채택한 화면프레임웤인"," ",(0,s.jsx)(h(),{href:"https://ui.nuxt.com/",className:"text-blue-600 hover:underline pl-1",children:"Nuxt UI (https://ui.nuxt.com/)"}),(0,s.jsx)("strong",{children:"UInputMenu"}),"를 활용하여 주소검색 UI를 구현함.",(0,s.jsx)("br",{}),"주의할 점은, 구글의 주소검색 API는 사용량에 따라 과금이 발생할 수 있으므로, 요금을 아낄 수 있도록 고려해야 함.",(0,s.jsx)("br",{}),"또한, 구글의 저작권 관련 약관을 준수하여, 커스텀인 경우 Powered by Google과 같은 문구를 넣어야만 함.",(0,s.jsx)(e,{language:"javascript",code:"// nuxt.config.ts\nexport default defineNuxtConfig({\n  // ... 기타 설정들 ...\n  runtimeConfig: {\n    public: {\n      baseUrl: {\n        api: process.env.BASE_URL_API,\n      } as Record<string, string>,\n      googleApiKey: process.env.NUXT_PUBLIC_GOOGLE_API_KEY,\n    },\n  },\n});"}),(0,s.jsx)(e,{language:"javascript",code:'// components/common/MyAddress.vue\n<script setup>\nimport { ref, onMounted, computed, watch } from "vue";\nimport { useDebounceFn } from "@vueuse/core";\n\nconst SEPARATOR = " | "; // 구분자\n\n// 외부 v-model:text -  Google API 주소와 상세주소(동, 호수 등)이 합쳐진 주소를 반환함.\nconst text = defineModel("text", { type: String, default: "" });\nconst lng = defineModel("lng", { type: Number, default: null });\nconst lat = defineModel("lat", { type: Number, default: null });\nconst placeId = defineModel("placeId", { type: String, default: "" });\n\n// 내부 필드들 (UI용)\nconst googleAddress = ref(""); // Google API 검색 필드\nconst detailAddress = ref(""); // 상세주소 입력 필드\nconst apiResults = ref([]);\nconst loading = ref(false);\n\nlet placesLib = null; // 구글 장소라이브러리. onMounted훅에서 await loader.importLibrary("places"); 됨.\nlet sessionToken = null;\n\nconst ensureToken = () => {\n  if (!sessionToken) sessionToken = new placesLib.AutocompleteSessionToken();\n};\n\n// 외부에서 온 값을 파싱해서 내부 필드들에 분배\nconst parseExternalValue = (fullAddress) => {\n  if (!fullAddress) {\n    googleAddress.value = "";\n    detailAddress.value = "";\n    return;\n  }\n\n  const parts = fullAddress.split(SEPARATOR);\n  googleAddress.value = parts[0] || "";\n  detailAddress.value = parts[1] || "";\n};\n\n// 내부 필드들을 합쳐서 외부 모델에 반영\nconst combineToExternal = () => {\n  const combined = detailAddress.value\n    ? googleAddress.value + SEPARATOR + detailAddress.value\n    : googleAddress.value;\n  text.value = combined;\n};\n\nconst items = computed(() => {\n  const results = [...apiResults.value];\n\n  if (googleAddress.value && !results.includes(googleAddress.value)) {\n    results.unshift(googleAddress.value);\n  }\n\n  return results;\n});\n\nconst fetchPredictions = useDebounceFn(async (q) => {\n  if (!placesLib || !q?.trim()) {\n    apiResults.value = [];\n    return;\n  }\n\n  ensureToken();\n  loading.value = true;\n  try {\n    const { AutocompleteSuggestion } = placesLib;\n    const req = {\n      input: q,\n      includedPrimaryTypes: ["geocode"],\n      sessionToken,\n    };\n    const { suggestions } =\n      await AutocompleteSuggestion.fetchAutocompleteSuggestions(req);\n\n    apiResults.value = (suggestions || [])\n      .map((s) => s.placePrediction?.text?.toString?.() ?? "")\n      .filter(Boolean);\n\n    if (apiResults.value.length) {\n      // 구글이 제공하는 표준 생성이 아닌경우 표시 의무.\n      // https://developers.google.com/maps/terms-20180207\n      // 9.4 Attribution b.\n      apiResults.value.push("Powered by Google");\n    }\n  } catch (error) {\n    console.warn("검색 실패:", error);\n    apiResults.value = [];\n  } finally {\n    loading.value = false;\n  }\n}, 250);\n\nconst handleSearch = (searchText) => {\n  fetchPredictions(searchText);\n};\n\n// 외부 값 변경 시 내부 필드들에 분배\nwatch(\n  text,\n  (newText) => {\n    // 외부에서 변경된 경우에만 파싱 (무한 루프 방지)\n    const currentCombined = detailAddress.value\n      ? googleAddress.value + SEPARATOR + detailAddress.value\n      : googleAddress.value;\n    if (newText !== currentCombined) {\n      parseExternalValue(newText);\n    }\n  },\n  { immediate: true },\n);\n\n// 내부 필드들 변경 시 외부로 합쳐서 전송\nwatch([googleAddress, detailAddress], () => {\n  combineToExternal();\n});\n\nconst config = useRuntimeConfig();\n\nonMounted(async () => {\n  // CommonJS 모듈 클라이언트에서만 실행.\n  const GoogleMapsLoaderModule = await import("@googlemaps/js-api-loader");\n  const { Loader } = GoogleMapsLoaderModule;\n\n  const loader = new Loader({\n    apiKey: config.public.googleApiKey,\n    version: "weekly",\n  });\n\n  placesLib = await loader.importLibrary("places");\n});\n<\/script>\n\n<template>\n  <div class="space-y-2">\n    \x3c!-- Google 주소 검색 필드 --\x3e\n    <UInputMenu\n      v-model="googleAddress"\n      :items="items"\n      icon="i-lucide-map-pin"\n      :loading="loading"\n      placeholder="도로명 주소를 입력하세요"\n      class="w-full"\n      @update:search-term="handleSearch"\n    />\n\n    \x3c!-- 상세주소 입력 필드 --\x3e\n    <UInput\n      v-model="detailAddress"\n      placeholder="상세주소 (동, 호수, 층수 등)"\n      icon="i-lucide-home"\n      class="w-full"\n    />\n\n    \x3c!-- 디버그/미리보기 (필요시 제거) --\x3e\n    <div v-if="text" class="text-xs p-2 bg-gray-50 rounded">\n      <strong>전체 주소:</strong> {{ text }}\n    </div>\n  </div>\n</template>'}),(0,s.jsx)(e,{language:"html",code:'<UFormField\n  label="도착지 주소"\n  name="deliverAddress"\n>\n  <MyAddress v-model:text="state.deliverAddress" />\n</UFormField>'})]})]})}},3390:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>d});var s=t(5155),r=t(7711);t(8452);var a=t(2761),i=t(908),o=t(2626),l=t.n(o),c=t(5483);function d(){let e=(0,r.default)(()=>t.e(773).then(t.bind(t,7773)).then(e=>e.default),{loadableGenerated:{webpack:()=>[7773]},ssr:!1});return(0,s.jsxs)("div",{className:l().container,children:[(0,s.jsx)(a.A,{text:"Leaflet으로 시간경계선을 지나는 경로를 그리기."}),(0,s.jsx)(i.A,{text:"2025.08.29"}),(0,s.jsxs)("section",{className:"".concat(l().paragraph," space-y-2"),children:[(0,s.jsx)("strong",{children:"프로젝트 : Ecormarine. Oceanlook_xp 화물운송 웹 프로젝트"}),(0,s.jsx)("br",{}),(0,s.jsx)("div",{children:"Leaflet API를 사용하여 지도를 그리고, 그 지도위로 경로(PolyLine)을 그려야 한다."}),(0,s.jsx)("div",{children:"지구가 둥글고 지도를 화면에 보여주면 반복되는 지역이 생기게 된다."}),(0,s.jsxs)("div",{children:["이때 -180도 ~ 180도 경계를 벗어나는 경유지점을 만나면, 지도의 반대편 동일 지점과 연결하면서 이상 경로를 표시하는 경우가 생긴다.",(0,s.jsx)("br",{}),"worldCopyJump: false, 날짜변경선 점프 활성화를 설정해도 마찬가지였다."]}),(0,s.jsxs)("div",{children:["핵심은, ",(0,s.jsx)("strong",{children:"unwrapPath"})," 함수이다. 가까운 다음 지점이 맵의 반대편에 있으면 문제를 바로잡는다."]}),(0,s.jsx)(e,{language:"javascript",code:"const latLngs0 = toLatLngs(waypoints);\nconst latLngs  = unwrapPath(latLngs0);\nconst polyParts = splitByAntimeridian(latLngs);"}),(0,s.jsx)(i.A,{text:"삽질 예시"}),(0,s.jsx)("section",{className:l().paragraph,children:(0,s.jsx)("img",{className:"mt-3 border border-gray-200 rounded-lg shadow-md",src:"/image/slug/leafletPolylineOverPacific.webp",alt:"이상 경로로 태평양을 가로지름"})})]}),(0,s.jsx)(i.A,{text:"바로잡은 모습"}),(0,s.jsx)("section",{className:l().paragraph,children:(0,s.jsx)("img",{className:"mt-3 border border-gray-200 rounded-lg shadow-md",src:"/image/slug/leafletPolyline.webp",alt:"올바른 경로로 태평양을 가로지름"})}),(0,s.jsx)(i.A,{text:"최종 코드"}),(0,s.jsxs)("section",{className:l().paragraph,children:[(0,s.jsx)(c.A,{title:"API 응답 예시",children:(0,s.jsx)(e,{language:"javascript",code:'\n  {\n    "routes": [\n      {\n        "distance": 10206.29, // 경유지 까지 거리\n        "sequence": 1, // 경유지 순서\n        "coordinates": [\n          {\n            "latitude": 30,\n            "longitude": 121.8\n          },\n          {\n            "latitude": 30.2,\n            "longitude": 121.8\n          },\n          {\n            "latitude": 30.9,\n            "longitude": 122.5\n          },\n          {\n            "latitude": 34,\n            "longitude": 126.3\n          }\n        ]\n      }\n    ]\n  }\n  '})}),(0,s.jsx)(c.A,{title:"API 요청 및 응답 처리 예시",children:(0,s.jsx)(e,{language:"javascript",code:"\n  // Map컴포넌트가 원하는 형식으로 API 응답을 변환\nconst processRoutesData = (routes = []) => {\n  if (!Array.isArray(routes) || routes.length === 0) {\n    return { waypoints: [], totalDistance: 0 };\n  }\n\n  // sequence 순서대로 정렬\n  const sortedRoutes = routes.sort((a, b) => (a.sequence || 0) - (b.sequence || 0));\n\n  // 모든 coordinates를 하나로 합치기\n  const allCoordinates = [];\n  let totalDistance = 0;\n\n  sortedRoutes.forEach((route, index) => {\n    if (route.coordinates && Array.isArray(route.coordinates)) {\n      // 첫 번째 route가 아니면 중복되는 첫 번째 좌표는 제외\n      const coords = index === 0 ? route.coordinates : route.coordinates.slice(1);\n      allCoordinates.push(...coords);\n    }\n\n    totalDistance += Number(route.distance) || 0;\n  });\n\n  return {\n    waypoints: allCoordinates,\n    totalDistance: totalDistance\n  };\n};\n\n\n// 경로계산 요청\nconst portRouteMap = useTemplateRef('portRouteMap');\nconst handleCalculate = async () => {\n\n  const response = await useCachePortDistance(token, params); // API 호출 - 응답형태 예시를 참조.\n\n  const { waypoints, totalDistance } = processRoutesData(response.routes); // response.routes가 있다고 가정.\n  routeData.value = {\n    distance: totalDistance,\n    waypoints,\n    segments: params.segments || [],\n    routes: response.routes // 원본 routes 데이터도 보관\n  };\n\n  portRouteMap.value.drawRoute(waypoints, totalDistance, currentSegments.value); // 지도에 그리기 트리거\n}\n"})}),(0,s.jsx)(c.A,{title:"Leaflet 컴포넌트 사용예",children:(0,s.jsx)(e,{language:"html",code:'<PortRouteMap\n  ref="portRouteMap"\n  :is-loading="isLoading"\n  :route-data="routeData"\n/>'})}),(0,s.jsx)(c.A,{title:"Polyline용 컴포저블",children:(0,s.jsx)(e,{language:"javascript",code:"import L from \"leaflet\";\n\nexport const useDistance = () => {\n\n    /**\n     * 사용자의 입력값을 구분하여 emit 해줄 객체로 재구성.\n     * @param {Array} userInputRows\n     * @param {Boolean} avoidSuez\n     * @param {Boolean} avoidPanama\n     * @returns {Object}\n     */\n    const getCalculateParam = (userInputRows, avoidSuez, avoidPanama) => {\n        const destinations = [];\n        const segments = []; // 구간별 정보 추가\n\n        userInputRows.forEach((row, index) => {\n            // 첫 번째 행의 출발항\n            if (index === 0 && row.departurePortCode) {\n                destinations.push(row.departurePortCode);\n            }\n\n            // 도착항 추가 (이전 항구와 다른 경우만)\n            if (row.arrivalPortCode) {\n                const lastDestination = destinations[destinations.length - 1];\n                if (lastDestination !== row.arrivalPortCode) {\n                    destinations.push(row.arrivalPortCode);\n                }\n\n                segments.push({\n                    from: index === 0 ? row.departurePortCode : destinations[destinations.length - 2],\n                    to: row.arrivalPortCode,\n                    sog: Number(row.sog) || 10,\n                    portStayTime: Number(row.portStayTime) || 12,\n\n                    // 출발항 정보도 같이 묶어서\n                    fromCityName: row.departurePortObject?.cityName,\n                    fromCountryName: row.departurePortObject?.countryName,\n                    toCityName: row.arrivalPortObject?.cityName,\n                    toCountryName: row.arrivalPortObject?.countryName,\n\n                    // 기존 소비처가 사용하는 도착항 정보 그대로 둠\n                    cityName: row.arrivalPortObject?.cityName,\n                    countryName: row.arrivalPortObject?.countryName,\n                    longitude: row.arrivalPortObject?.longitude,\n                    latitude: row.arrivalPortObject?.latitude,\n\n                    index\n                });\n\n            }\n        });\n\n        const waypoints = destinations.map(portCode => ({\n            type: 'PORT',\n            value: portCode\n        }));\n\n        return {\n            avoidSuez,\n            avoidPanama,\n            destinations: destinations,\n            waypoints: waypoints,\n            segments: segments, // 구간별 정보 전달\n            distanceUnit: 'NM'\n        };\n    }\n\n    /**\n     * 경도를 -180~180 범위로 정규화\n     * @param {number} lng - 경도 값\n     * @returns {number} 정규화된 경도\n     */\n    const normalizeLng = (lng) => {\n        let normalized = lng;\n        while (normalized > 180) normalized -= 360;\n        while (normalized < -180) normalized += 360;\n        return normalized;\n    };\n\n    /**\n     * waypoints를 유효한 [lat, lng] 배열로 변환\n     * @description 경도가 -180~180 범위가 아닌경우 순환적이라서 조정 normalizeLng 실행시킴. (방어용)\n     * @param {RouteWaypoint[]} waypoints - 경로점 배열\n     * @returns {number[][]} [lat, lng] 배열\n     */\n     const toLatLngs = (waypoints = []) =>\n           waypoints\n             .map(p => [Number(p.latitude), normalizeLng(Number(p.longitude))])\n         .filter(([lat, lng]) => Number.isFinite(lat) && Number.isFinite(lng));\n\n    /**\n     * prevLng 기준으로 현재 경도를 연속축으로 펼치기(가장 가까운 분지 선택)\n     * @description 날짜변경선 교차 문제, 이전 점에서 가장 가까운 방향으로 현재 점을 배치\n     * @param {Number} prevLng 이전 경도\n     * @param {Number} currLng 현재 경도\n     * @returns {Number} x 반환 경도\n     */\n    const unwrapToContinuousLng = (prevLng, currLng) => {\n        // 지구가 둥금.\n        let x = currLng;\n        while (x - prevLng > 180) x -= 360; // 현재점이 이전점보다 180도 동쪽에 있으면 서쪽으로 한바퀴 돌림.\n        while (prevLng - x > 180) x += 360; // 이전점보다 현재점이 180도 이상 서쪽에 있으면, 동쪽에 있는 지점으로\n        return x;\n    };\n\n    /**\n     * 경로 전체를 연속 경도로 풀기\n     * @param {Array} latLngs 이전 경도\n     * @returns {Array} out 반환 경도\n     */\n    const unwrapPath = (latLngs) => {\n        if (!latLngs || latLngs.length < 2) return latLngs || [];\n        const out = [ [latLngs[0][0], latLngs[0][1]] ]; // 첫 번째 지점은 그대로 둔다.\n        for (let i = 1; i < latLngs.length; i++) {\n            const [pl, ql] = out[out.length - 1]; // 이전 점의 경도\n            const [cl, cg] = latLngs[i]; // 현재 점의 경도\n            out.push([cl, unwrapToContinuousLng(ql, cg)]); // 이전 경도에서 가장 가까운 위치로 현재 경도를 조정.\n        }\n        return out;\n    };\n\n    /**\n     * 날짜변경선(\xb1180\xb0)을 넘는 경로를 여러 파트로 분할\n     * 지도에서 대륙 가로지르는 직선이 생기지 않도록 처리\n     * @param {number[][]} latLngs - [lat, lng] 좌표 배열\n     * @returns {number[][][]} 분할된 경로 파트들\n     */\n    function splitByAntimeridian(latLngs) {\n        if (!latLngs || latLngs.length < 2) return [latLngs || []];\n\n        const parts = [[]];\n        let prev = latLngs[0];\n        parts[0].push([prev[0], prev[1]]);\n\n        for (let i = 1; i < latLngs.length; i++) {\n            const curr = latLngs[i];\n            const prevLng = prev[1]; // 이전 점의 경도\n            const currLng = curr[1]; // 현재 점의 경도\n            const dLon = Math.abs(currLng - prevLng); // 경도간의 차이\n\n            // 이전과 현재의 경도 표시값이, 날짜 변경선을 가로질렀음.\n            if (dLon > 180) {\n                const crossingLng = prevLng < currLng ? 180 : -180; // 어느 방향으로 넘어가는지 판단\n\n                const totalDelta = currLng - prevLng;           // 연속점 간의 경도 차이\n                const t = (crossingLng - prevLng) / totalDelta; // 0~1 교차 비율\n                const crossLat = prev[0] + (curr[0] - prev[0]) * t; // 교차점 위도\n\n                // 현재 파트 끝에 교차점(+180/-180) 추가\n                parts[parts.length - 1].push([crossLat, crossingLng]);\n\n                // 반대편에서 새 파트 시작(-180/180)\n                const wrappedLng = crossingLng === 180 ? -180 : 180;\n                parts.push([[crossLat, wrappedLng], [curr[0], currLng]]);\n            } else {\n                // 정상적인 연결\n                parts[parts.length - 1].push([curr[0], currLng]);\n            }\n            prev = curr;\n        }\n\n        return parts.filter(p => p.length >= 2);\n    }\n\n\n    /**\n     * 두 경도 간의 최단 경로상 차이를 계산 (날짜변경선 고려)\n     * @param {number} lng1 - 첫 번째 경도\n     * @param {number} lng2 - 두 번째 경도\n     * @returns {number} 최단 경로상의 경도 차이 (-180 ~ 180)\n     */\n    const getShortestLngDifference = (lng1, lng2) => {\n        let diff = lng2 - lng1;\n        if (diff > 180) diff -= 360; // 180보다 크면 반대방향이 더 가까움.\n        if (diff < -180) diff += 360;\n        return diff;\n    };\n\n    /**\n     * 태평양 횡단 경로인지 판단\n     * @param {number[][]} latLngs - [lat, lng] 좌표 배열\n     * @returns {boolean} 태평양 횡단 여부\n     */\n    const isPacificCrossing = (latLngs) => {\n        if (!latLngs || latLngs.length < 2) return false;\n\n        // 경로상에서 가장 동쪽과 서쪽 경도\n        let eastmost = -180;\n        let westmost = 180;\n\n        latLngs.forEach(([lat, lng]) => {\n            if (lng > eastmost) eastmost = lng;\n            if (lng < westmost) westmost = lng;\n        });\n\n        // 경도 범위가 240도 이상이면 태평양 횡단으로 판단\n        // (정상적인 대서양이나 인도양 항로는 이 정도 범위를 갖지 않음)\n        return (eastmost - westmost) > 240;\n    };\n\n    /**\n     * 위치점들 사이의 누적 거리를 해상마일(NM) 단위로 계산\n     * @param {number[][]} latLngs - [lat, lng] 좌표 배열\n     * @returns {number[]} 누적 거리 배열 (NM)\n     */\n    const buildCumulativeNM = (latLngs) => {\n        const cum = [0];\n        for (let i = 1; i < latLngs.length; i++) {\n            const dNM = L.latLng(latLngs[i - 1]).distanceTo(L.latLng(latLngs[i])) / 1852;\n            cum.push(cum[cum.length - 1] + dNM);\n        }\n        return cum;\n    };\n\n    /**\n     * 세그먼트의 목적지 좌표를 polyline 인덱스에 매핑\n     * 여러 좌표 필드들 중에서 항구 위치를 찾음\n     * @param {number[][]} latLngs - api에서 받은 polyline 좌표 배열 (원본, unwrapped 아님)\n     * @param {RouteSegment[]} segments - 사용자가 입력한 경로 세그먼트 배열\n     * @returns {number[]} polyline 인덱스 배열\n     */\n    const computePortIdxsFromSegments = (latLngs, segments = []) => {\n        const lastIdx = latLngs.length - 1; // 마지막 인덱스\n        if (lastIdx < 1) return [0];\n\n        const idxs = [0]; // 시작점 보장\n        let prev = 0; // 이전 찾은 인덱스\n\n        const segCount = Array.isArray(segments) ? segments.length : 0;\n        const middleCount = Math.max(segCount - 1, 0); // 마지막 세그먼트 제외\n\n        /**\n         * 세그먼트에서 목적지(도착항) 좌표 추출\n         * @param {RouteSegment} seg - 경로 세그먼트\n         * @returns {number[]|null} [lat, lng] 또는 null\n         */\n        const getToPortLatLng = (seg) => {\n            const lat = Number(seg?.latitude);\n            const lng = Number(seg?.longitude);\n            if (Number.isFinite(lat) && Number.isFinite(lng)) {\n                return [lat, normalizeLng(lng)];\n            }\n            return null;\n        };\n\n        for (let i = 0; i < middleCount; i++) {\n            const approx = Math.round(lastIdx * ((i + 1) / (segCount + 1))); // 시작점 근사치 계산. 전체 경로를 세그먼트 개수로 나눔.\n            const portCoords = getToPortLatLng(segments[i]); // 목표 항구\n            let bestIdx = approx;\n\n            if (portCoords) {\n                try {\n                    const targetLat = portCoords[0]; // 목표항구 위도\n                    const targetLng = portCoords[1]; // 목표항구 경도\n                    let minDistance = Infinity;\n\n                    // polyline에서 가장 가까운 점 찾기 (날짜변경선 고려)\n                    for (let j = prev + 1; j <= lastIdx - 1; j++) {\n                        const point = latLngs[j];\n                        if (!point || !Number.isFinite(point[0]) || !Number.isFinite(point[1])) continue;\n\n                        // 날짜변경선을 고려한 거리 계산\n                        const latDiff = point[0] - targetLat;\n                        const lngDiff = getShortestLngDifference(point[1], targetLng);\n                        const distance = Math.sqrt(latDiff * latDiff + lngDiff * lngDiff);\n\n                        if (distance < minDistance) { // 최소값. 가장 가까운 거리에 있는곳.\n                            minDistance = distance;\n                            bestIdx = j;\n                        }\n                    }\n                } catch (error) {\n                    console.warn('[port-matching] 좌표 매칭 실패:', error);\n                    bestIdx = approx;\n                }\n            } else {\n                console.warn('[port-matching] 세그먼트에 도착항 좌표 없음. 근사치 사용:', segments[i]);\n            }\n\n            // 인덱스 범위 제한\n            bestIdx = Math.max(bestIdx, prev + 1); // 이전보다 뒤에있다\n            bestIdx = Math.min(bestIdx, lastIdx - 1); // 끝점보다 앞에있다\n            idxs.push(bestIdx);\n            prev = bestIdx;\n        }\n\n        idxs.push(lastIdx); // 종료점 보장\n        return idxs;\n    };\n\n    /**\n     * 시작 시간으로부터 지정 시간 후의 ETA 계산\n     * @param {Date} startTime - 시작 시간\n     * @param {number} hoursFromStart - 경과 시간 (hours)\n     * @returns {string} ISO 형식의 시간 문자열 (UTC)\n     */\n    const calculateETA = (startTime, hoursFromStart) => {\n        const eta = new Date(startTime.getTime() + hoursFromStart * 60 * 60 * 1000);\n        return eta.toISOString().slice(0, 16).replace('T', ' ') + ' UTC';\n    };\n\n    /**\n     * 경로의 구간별 요약 정보 생성\n     * @param {number[][]} latLngs - polyline 좌표 배열\n     * @param {RouteInfo[]} routes - 경로 정보 배열\n     * @param {RouteSegment[]} segments - 경로 세그먼트 배열\n     * @param {Date} startTime - 시작 시간\n     * @returns {Array} legSummaries - 구간 요약 배열\n     */\n    const buildLegSummary = (latLngs, routes, segments, startTime = new Date()) => {\n        const segs = Array.isArray(segments) ? segments : [];\n        const routeDistances = Array.isArray(routes) ? routes.map(r => Number(r.distance) || 0) : null;\n\n        // polyline 기반 거리 계산 (폴백용)\n        const cumNM = latLngs?.length >= 2 ? buildCumulativeNM(latLngs) : null;\n        const portIdxs = latLngs?.length >= 2 ? computePortIdxsFromSegments(latLngs, segs) : [0, 0];\n\n        const legSummaries = [];\n        let timeOffset = 0; // 시작으로부터 경과 시간\n\n        const legCount = Math.min(\n            routeDistances ? routeDistances.length : (portIdxs.length - 1),\n            Math.max(segs.length, 1)\n        );\n\n        for (let i = 0; i < legCount; i++) {\n            // 거리: routes 우선, 없으면 polyline 기반\n            const distanceNM = routeDistances\n                ? routeDistances[i]\n                : (cumNM[portIdxs[i + 1]] - cumNM[portIdxs[i]]);\n\n            const speed = segs[i]?.sog || 10;\n            const sailingHours = distanceNM / Math.max(speed, 0.1);\n\n            const etd = calculateETA(startTime, timeOffset);\n            timeOffset += sailingHours;\n            const eta = calculateETA(startTime, timeOffset);\n\n            const stayHours = (i < legCount - 1) ? (segs[i]?.portStayTime ?? 12) : 0;\n            timeOffset += stayHours;\n\n            legSummaries.push({\n                index: i,\n                from: segs[i]?.from,\n                to: segs[i]?.to,\n                fromCityName: segs[i]?.fromCityName,\n                toCityName: segs[i]?.toCityName,\n                nm: Math.round(distanceNM * 10) / 10,\n                kn: speed,\n                sailHrs: Math.round(sailingHours * 10) / 10,\n                stayHrs: stayHours,\n                etd,\n                eta,\n                // 지도 연동용 인덱스\n                sIdx: portIdxs[i],\n                eIdx: portIdxs[i + 1]\n            });\n        }\n\n        return legSummaries;\n    };\n\n    /**\n     * 지정된 거리(NM)에 해당하는 중간점을 보간으로 GPS 좌표 계산\n     * @param {number[][]} latLngs - [lat, lng] 좌표 배열\n     * @param {number[]} cumNM - 누적 거리 배열\n     * @param {number} startIdx - 시작 인덱스\n     * @param {number} endIdx - 종료 인덱스\n     * @param {number} targetNM - 목표 거리 (NM)\n     * @returns {number[]} [lat, lng] 좌표\n     */\n    const findPointAtSailingNM = (latLngs, cumNM, startIdx, endIdx, targetNM) => {\n        for (let i = startIdx; i < endIdx; i++) {\n            if (cumNM[i + 1] >= targetNM) {\n                const segNM = cumNM[i + 1] - cumNM[i];\n                const r = segNM > 0 ? (targetNM - cumNM[i]) / segNM : 0;\n                const lat = latLngs[i][0] + (latLngs[i + 1][0] - latLngs[i][0]) * r;\n                const lng = latLngs[i][1] + (latLngs[i + 1][1] - latLngs[i][1]) * r;\n                return [lat, lng];\n            }\n        }\n        return latLngs[endIdx];\n    };\n\n    return {\n        getCalculateParam,\n        normalizeLng,\n        toLatLngs,\n        unwrapPath,\n        splitByAntimeridian,\n        getShortestLngDifference,\n        isPacificCrossing,\n        calculateETA,\n        buildCumulativeNM,\n        computePortIdxsFromSegments,\n        buildLegSummary,\n        findPointAtSailingNM\n    }\n}"})}),(0,s.jsx)(c.A,{title:"Leaflet 구현체 PortRouteMap.vue",children:(0,s.jsx)(e,{language:"html",code:'\n  <script setup>\nimport { ref, computed, nextTick, onMounted, onUnmounted } from "vue";\nimport L from "leaflet";\nimport "tilelayer-canvas";\nimport {useDistance} from "~/composables/port/useDistance.js";\n\n/**\n * @typedef {Object} RouteWaypoint\n * @property {number} latitude - 위도\n * @property {number} longitude - 경도\n */\n\n/**\n * @typedef {Object} RouteSegment\n * @property {string} from - 출발항 코드\n * @property {string} to - 도착항 코드\n * @property {string} [fromCityName] - 출발 도시명\n * @property {string} [toCityName] - 도착 도시명\n * @property {string} [countryName] - 국가명\n * @property {string} [cityName] - 도시명\n * @property {number} [sog=12] - 선속 (knots)\n * @property {number} [portStayTime=24] - 항구 체류 시간 (hours)\n * @property {number} [latitude] - 도착항 위도\n * @property {number} [longitude] - 도착항 경도\n * @property {number} [berthingCount] - 접안 횟수\n * @property {number} [headingCount] - 출항 횟수\n */\n\n/**\n * @typedef {Object} RouteInfo\n * @property {number} distance - 구간 거리 (NM)\n */\n\n/**\n * @typedef {Object} RouteData\n * @property {RouteWaypoint[]} waypoints - 경로점 배열\n * @property {number} distance - 총 거리 (NM)\n * @property {RouteInfo[]} [routes] - 구간별 거리 정보\n * @property {RouteSegment[]} [segments] - 구간 정보 (deprecated, 외부에서 전달)\n */\n\n/**\n * @typedef {Object} LegSummary\n * @property {number} index - 구간 인덱스\n * @property {string} from - 출발항 코드\n * @property {string} to - 도착항 코드\n * @property {string} fromCityName - 출발 도시명\n * @property {string} toCityName - 도착 도시명\n * @property {number} nm - 구간 거리 (NM)\n * @property {number} kn - 선속 (knots)\n * @property {number} sailHrs - 항해 시간 (hours)\n * @property {number} stayHrs - 체류 시간 (hours)\n * @property {string} etd - 출발 예정 시각 (ETD)\n * @property {string} eta - 도착 예정 시각 (ETA)\n * @property {number} sIdx - polyline 시작 인덱스\n * @property {number} eIdx - polyline 종료 인덱스\n */\n\n/**\n * Props 정의\n */\nconst props = defineProps({\n  /** @type {boolean} 로딩 상태 */\n  isLoading: { type: Boolean, default: false },\n  /** @type {RouteData|null} 경로 데이터 */\n  routeData: { type: Object, default: null },\n})\n\n// 지도 관련 상태\nconst mapContainer = ref(null);\nlet mapInstance = null;\nlet mapInitialized = false;\n\n// 경로 계산 상태\nconst currentSegments = ref([]);\nconst currentSpeed = ref(12);     // 기본 선속 (knots)\nconst portStayTime = ref(24);     // 기본 체류시간 (hours)\n\n/* ====================== 유틸리티 함수 ====================== */\nconst { toLatLngs, splitByAntimeridian, calculateETA,\n  buildCumulativeNM,\n  computePortIdxsFromSegments, buildLegSummary, findPointAtSailingNM, unwrapPath, normalizeLng } = useDistance();\n\n/* ====================== 마커 및 경로 렌더링 ====================== */\n/**\n * 시간 마커들(ETA/ETD 및 시간 틱)을 지도에 그리기\n * @param {number[][]} latLngs - polyline 좌표 배열\n * @param {number} _totalDistance - 총 거리 (사용안함)\n * @param {RouteSegment[]} segments - 경로 세그먼트 배열\n * @param {any[]} destinations - 목적지 배열 (사용안함)\n * @param {any} resolver - 리졸버 (사용안함)\n */\nlet timeLayer = null;\nlet lastTimeArgs = null; // 재그리기용 캐시\n\n// 줌에 따라 원하는 \'대략적인\' 틱 개수 결정 (너무 많지도 적지도 않게)\n// 줌 2~14 범위에서 대략 10~40개 사이로 움직이게 세팅\nconst desiredTicksForZoom = (z) => {\n  const zoom = Number(z) || 2;\n  return Math.max(10, Math.min(40, Math.round(14 + (zoom - 2) * 2.4)));\n};\n\n// 총 항해시간과 줌에 따라 "틱 간격(시간)"을 고름 (6h, 12h, 24h, 48h ... 식으로 배수 증가)\nconst chooseTickStepHours = (totalHours, zoom) => {\n  const base = 6; // 최소 6시간 단위\n  const desired = desiredTicksForZoom(zoom);\n  // totalHours / step ≈ desired 가 되도록 step을 6 * 2^k 로 선택\n  let step = base;\n  while (totalHours / step > desired) step *= 2;\n  // 상\xb7하한 클램프(너무 촘촘/성김 방지)\n  if (step < 6) step = 6;\n  if (step > 96) step = 96; // 4일 단위 이상은 과함\n  return step;\n};\n\nconst drawTimeMarkers = (latLngs, _totalDistance, segments = []) => {\n  // 0) 캐시 (줌 변경 시 재사용)\n  lastTimeArgs = [latLngs, _totalDistance, segments];\n\n  // 1) 기존 마커 삭제 → 레이어 비우기\n  if (timeLayer) timeLayer.clearLayers();\n\n  const startTime = new Date();\n  const cumNM = buildCumulativeNM(latLngs);\n  const segs = Array.isArray(segments) ? segments : [];\n\n  // 항구 위치 인덱스\n  const portIdxs = computePortIdxsFromSegments(latLngs, segments);\n  const legCount = Math.max(portIdxs.length - 1, 1);\n\n  // 2) ETD/ETA 마커(항구별)만 먼저 그리기 (필수 정보라 항상 찍음)\n  let timeCursor = 0;\n  for (let legIndex = 0; legIndex < legCount; legIndex++) {\n    const startIdx = portIdxs[legIndex];\n    const endIdx   = portIdxs[legIndex + 1];\n    const legNM    = cumNM[endIdx] - cumNM[startIdx];\n    const speed    = segs[legIndex]?.sog || currentSpeed.value;\n    const sailHrs  = legNM / Math.max(speed, 0.1);\n\n    if (legIndex === 0) {\n      const etd = calculateETA(startTime, timeCursor);\n      L.marker(latLngs[startIdx], {\n        icon: L.divIcon({\n          className: \'eta-marker start\',\n          html: \'<div class="eta-content"><div class="eta-time">ETD</div><div class="eta-date">\' + etd + \'</div></div>\',\n          iconSize: [120, 40], iconAnchor: [60, 45]\n        })\n      }).addTo(timeLayer);\n    }\n\n    timeCursor += sailHrs;\n\n    const eta = calculateETA(startTime, timeCursor);\n    L.marker(latLngs[endIdx], {\n      icon: L.divIcon({\n        className: \'eta-marker \' + (legIndex === legCount - 1 ? \'end\' : \'waypoint\'),\n        html: \'<div class="eta-content"><div class="eta-time">ETA</div><div class="eta-date">\' + eta + \'</div></div>\',\n        iconSize: [120, 40], iconAnchor: [60, 45]\n      })\n    }).addTo(timeLayer);\n\n    if (legIndex < legCount - 1) {\n      const stayHrs = segs[legIndex]?.portStayTime ?? portStayTime.value;\n      timeCursor += stayHrs;\n    }\n  }\n\n  // 3) 타임라인 블록 구성(항해/정박)\n  const timeline = [];\n  for (let i = 0; i < legCount; i++) {\n    const sIdx = portIdxs[i];\n    const eIdx = portIdxs[i + 1];\n    const legNM = cumNM[eIdx] - cumNM[sIdx];\n    const spd   = segs[i]?.sog || currentSpeed.value;\n    const sailH = legNM / Math.max(spd, 0.1);\n\n    timeline.push({ type: \'sail\', hours: sailH, startIdx: sIdx, endIdx: eIdx, speed: spd });\n    if (i < legCount - 1) {\n      const stayH = segs[i]?.portStayTime ?? portStayTime.value;\n      timeline.push({ type: \'stay\', hours: stayH, atIdx: eIdx });\n    }\n  }\n  const totalHrs = timeline.reduce((a, b) => a + b.hours, 0);\n\n  // 4) "틱 간격" 자동 선택 + 전체 최대 갯수 하드캡\n  const zoom = mapInstance?.getZoom?.() ?? 2;\n  const step = chooseTickStepHours(totalHrs, zoom); // 예: 6/12/24/48 등\n  const MAX_TICKS = 80; // 절대 상한 (원하면 60~100 사이로 조절)\n\n  // 5) 목표 시간 위치에 틱 찍기\n  const placeTickAtTime = (targetTime) => {\n    let acc = 0;\n    for (const block of timeline) {\n      if (acc + block.hours >= targetTime) {\n        const remain = targetTime - acc;\n        if (block.type === \'stay\') {\n          // 정박 중 → 항구 위치에 표시\n          const eta = calculateETA(startTime, targetTime);\n          L.marker(latLngs[block.atIdx], {\n            icon: L.divIcon({\n              className: \'time-marker\',\n              html: \'<div class="time-tick"><div class="tick-dot"></div><div class="tick-label">+\' + Math.round(targetTime) + \'h</div><div class="tick-eta">\' + eta.split(\' \')[1].slice(0,5) + \'</div></div>\',\n              iconSize: [60, 30], iconAnchor: [30, 15]\n            })\n          }).addTo(timeLayer);\n        } else {\n          // 항해 중 → 선상 보간점\n          const frac   = block.hours > 0 ? (remain / block.hours) : 0;\n          const startNM= cumNM[block.startIdx];\n          const tgtNM  = startNM + (cumNM[block.endIdx] - startNM) * frac;\n          const p      = findPointAtSailingNM(latLngs, cumNM, block.startIdx, block.endIdx, tgtNM);\n          const eta    = calculateETA(startTime, targetTime);\n\n          L.marker(p, {\n            icon: L.divIcon({\n              className: \'time-marker\',\n              html: \'<div class="time-tick"><div class="tick-dot"></div><div class="tick-label">+\' + Math.round(targetTime) + \'h</div><div class="tick-eta">\' + eta.split(\' \')[1].slice(0,5) + \'</div></div>\',\n              iconSize: [60, 30], iconAnchor: [30, 15]\n            })\n          }).addTo(timeLayer);\n        }\n        return;\n      }\n      acc += block.hours;\n    }\n  };\n\n  // 6) 실제 틱 생성 (step 간격, 하드캡 적용)\n  let count = 0;\n  for (let t = step; t < totalHrs && count < MAX_TICKS; t += step) {\n    placeTickAtTime(t);\n    count++;\n  }\n};\n\n/**\n * 경로를 지도에 그리기 (polyline + 마커)\n * @param {RouteWaypoint[]} waypoints - 경로점 배열\n * @param {number} _distance - 총 거리 (사용안함)\n * @param {RouteSegment[]} segments - 경로 세그먼트 배열\n * @param {any[]} destinations - 목적지 배열 (사용안함)\n */\nlet routeLayer = null;\nconst showPortValidationToast = ref(false)\nconst drawRoute = (waypoints, _distance, segments = []) => {\n\n  if (!mapInstance) {\n    console.warn(\'[route-drawing] 지도가 초기화되지 않음\');\n    return;\n  }\n\n  const latLngs0 = toLatLngs(waypoints);\n  const latLngs  = unwrapPath(latLngs0);\n  // 날짜변경선 분할 처리\n  const polyParts = splitByAntimeridian(latLngs);\n\n\n  if (latLngs.length < 2) {\n    console.warn(\'[route-drawing] 유효한 경로점이 2개 미만입니다:\', latLngs);\n    showPortValidationToast.value = true\n    return;\n  }\n\n  currentSegments.value = segments;\n  // 기존 경로 레이어 제거\n  if (routeLayer) {\n    routeLayer.forEach(layer => mapInstance.removeLayer(layer));\n    routeLayer = null;\n  }\n\n  // 각 분할된 부분을 별도의 polyline으로 생성\n  const polylines = [];\n  polyParts.forEach((part, index) => {\n    if (part.length >= 2) {\n      const polyline = L.polyline(part, {\n        color: \'#2563eb\',\n        weight: 4,\n        opacity: 0.8\n      });\n      polylines.push(polyline);\n      polyline.addTo(mapInstance);\n    }\n  });\n\n  // 시작/종료 마커 생성\n  const portIcon = L.icon({\n    iconUrl: \'/icon/port-icon.svg\',\n    iconSize: [23, 33],\n    iconAnchor: [12, 30]\n  });\n\n  const startMarker = L.marker(latLngs[0], { icon: portIcon })\n      .bindPopup(\'시작점\')\n      .addTo(mapInstance);\n\n  const endMarker = L.marker(latLngs[latLngs.length - 1], { icon: portIcon })\n      .bindPopup(\'도착점\')\n      .addTo(mapInstance);\n\n  routeLayer = [...polylines, startMarker, endMarker];\n\n  // 지도 경계를 경로에 맞춤 (날짜변경선 고려)\n  const partsBounds = L.latLngBounds([]);\n  polyParts.forEach(part => {\n    const b = L.latLngBounds(part);\n    if (b.isValid()) partsBounds.extend(b);\n  });\n  if (partsBounds.isValid()) {\n    mapInstance.fitBounds(partsBounds, { padding: [20, 20] });\n  }\n\n  // 시간 마커들 그리기\n  drawTimeMarkers(latLngs, _distance, segments);\n};\n\n/* ====================== 여행 시간 계산 ====================== */\n\n/**\n * routes 배열에서 구간별 거리 추출\n * @param {RouteInfo[]} routes - 경로 정보 배열\n * @returns {number[]|null} 거리 배열 (NM) 또는 null\n */\nconst getLegDistancesNM = (routes = []) => {\n  if (!Array.isArray(routes) || !routes.length) return null;\n  return routes.map(route => Number(route.distance) || 0);\n};\n\n/**\n * 총 여행 시간 계산 (항해 시간 + 체류 시간)\n * routes 데이터가 있으면 우선 사용, 없으면 polyline 기반으로 계산\n */\nconst totalTravelTime = computed(() => {\n  if (!props.routeData) return 0;\n\n  const segments = currentSegments.value?.length ? currentSegments.value : [];\n  const routeDistances = getLegDistancesNM(props.routeData.routes);\n\n  let totalSailingTime = 0;\n  let totalStayTime = 0;\n\n  // routes 데이터가 있는 경우 (우선순위)\n  if (routeDistances && routeDistances.length) {\n    const legCount = Math.min(routeDistances.length, Math.max(segments.length, 1));\n\n    for (let i = 0; i < legCount; i++) {\n      const speed = segments[i]?.sog || currentSpeed.value;\n      totalSailingTime += routeDistances[i] / Math.max(speed, 0.1);\n\n      if (i < legCount - 1) {\n        totalStayTime += segments[i]?.portStayTime ?? portStayTime.value;\n      }\n    }\n    return totalSailingTime + totalStayTime;\n  }\n\n  // waypoints 기반 계산 (폴백)\n  if (!props.routeData.waypoints || !props.routeData.waypoints.length) return 0;\n\n  const latLngs = toLatLngs(props.routeData.waypoints);\n  if (latLngs.length < 2) return 0;\n\n  const cumNM = buildCumulativeNM(latLngs);\n  const portIdxs = computePortIdxsFromSegments(latLngs, segments);\n  const legCount = Math.max(portIdxs.length - 1, 1);\n\n  for (let i = 0; i < legCount; i++) {\n    const startIdx = portIdxs[i];\n    const endIdx = portIdxs[i + 1];\n    const legDistance = cumNM[endIdx] - cumNM[startIdx];\n    const speed = segments[i]?.sog || currentSpeed.value;\n\n    totalSailingTime += legDistance / Math.max(speed, 0.1);\n\n    if (i < legCount - 1) {\n      totalStayTime += segments[i]?.portStayTime ?? portStayTime.value;\n    }\n  }\n\n  return totalSailingTime + totalStayTime;\n});\n\n/* ====================== 구간 요약 ====================== */\n\n/**\n * 현재 경로의 구간별 요약 정보\n */\nconst legSummary = computed(() =>\n    buildLegSummary(\n        toLatLngs(props.routeData?.waypoints || []),\n        props.routeData?.routes || [],\n        currentSegments.value\n    )\n);\n\n/**\n * 특정 구간으로 지도 중심 이동\n * @param {LegSummary} leg - 구간 정보\n */\n/**\n * 특정 구간으로 지도 중심 이동\n * @param {LegSummary} leg - 구간 정보\n */\nconst panToLeg = (leg) => {\n  if (!mapInstance || !props.routeData?.waypoints) return;\n\n  // unwrapped된 좌표가 아닌 원본 waypoints에서 좌표 가져오기\n  const originalLatLngs = toLatLngs(props.routeData.waypoints);\n\n  if (!originalLatLngs.length) return;\n\n  // leg.eIdx가 배열 범위를 벗어나지 않도록 보장\n  const targetIdx = Math.min(Math.max(leg?.eIdx ?? 0, 0), originalLatLngs.length - 1);\n  const targetCoords = originalLatLngs[targetIdx];\n\n  // 좌표 유효성 검사\n  if (!targetCoords || !Number.isFinite(targetCoords[0]) || !Number.isFinite(targetCoords[1])) {\n    return;\n  }\n\n  // 경도를 -180~180 범위로 정규화하여 지도 이동\n  const normalizedLng = normalizeLng(targetCoords[1]);\n  mapInstance.panTo([targetCoords[0], normalizedLng]);\n};\n\n/* ====================== 지도 초기화 및 생명주기 ====================== */\n/**\n * Leaflet 지도 인스턴스 초기화\n */\nconst initializeMap = () => {\n  if (mapInitialized) return;\n  mapInitialized = true;\n\n  mapInstance = L.map("distance-map", {\n    center: [35.1098, 129.0621], // 부산 중심\n    zoom: 2,\n    minZoom: 2,\n    maxZoom: 14,\n    maxBounds: L.latLngBounds([-90, -360], [90, 360]),\n    maxBoundsViscosity: 1.0,\n    preferCanvas: true,\n    zoomControl: false,\n    worldCopyJump: false  // 날짜변경선 점프 활성화\n  });\n\n  // 타일 레이어 추가\n  L.tileLayer(\'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png\', {\n    attribution: \'&copy; OpenStreetMap contributors &copy; CARTO\',\n    subdomains: \'abcd\',\n    maxZoom: 18,\n    // noWrap: true\n  }).addTo(mapInstance);\n\n  timeLayer = L.layerGroup().addTo(mapInstance);\n\n// 줌 바뀌면 밀도 재계산해서 틱만 다시 그림\n  mapInstance.on(\'zoomend\', () => {\n    if (!lastTimeArgs) return;\n    const [latLngs, totalDistance, segments] = lastTimeArgs;\n    // ETD/ETA는 유지하고 \'시간 틱\'만 다시 그리려면, 아래처럼 틱만 지우고 다시 찍을 수도 있음\n    // 여기서는 간단히 전체 타임마커를 다시 그립니다.\n    drawTimeMarkers(latLngs, totalDistance, segments);\n  });\n};\n\n/**\n * 지도 크기 재조정\n */\nconst resizeMap = () => {\n  if (mapInstance) {\n    setTimeout(() => mapInstance.invalidateSize(), 100);\n  }\n};\n\n// ResizeObserver 인스턴스\nlet resizeObserver = null;\n\n// 컴포넌트 언마운트 시 정리\nonUnmounted(() => {\n  if (resizeObserver) resizeObserver.disconnect();\n  if (mapInstance) mapInstance.remove();\n  mapInstance = null;\n});\n\n// 컴포넌트 마운트 시 초기화\nonMounted(async () => {\n  await nextTick();\n\n  if (mapContainer.value) {\n    initializeMap();\n\n    // 리사이즈 감지 설정\n    if (window.ResizeObserver) {\n      resizeObserver = new ResizeObserver(() => resizeMap());\n      resizeObserver.observe(mapContainer.value);\n    }\n\n    // 초기 크기 조정\n    requestAnimationFrame(() => resizeMap());\n  }\n});\n\nconst closePortValidationToast = () => {\n  showPortValidationToast.value = false\n}\n\n// 외부에서 사용할 수 있는 메서드 노출\ndefineExpose({\n  drawRoute\n})\n<\/script>\n\n<template>\n  <div class="map__section">\n    <div\n        v-if="showPortValidationToast"\n        class="fixed bottom-4 right-4 z-[9999]"\n    >\n      <Alert\n          :isOpen="showPortValidationToast"\n          @close="closePortValidationToast"\n          title="경로 확인"\n          description="시작항구와 도착항구를 확인하세요"\n          icon="warning"\n      />\n    </div>\n\n    <div class="map__container">\n      \x3c!-- 지도 컨테이너 --\x3e\n      <div id="distance-map" class="distance-map" ref="mapContainer"></div>\n\n      \x3c!-- 로딩 오버레이 --\x3e\n      <div v-if="isLoading" class="map-loading-overlay">\n        <div class="loading-content">\n          <div class="loading-spinner"></div>\n          <div class="loading-text">항로 계산 중...</div>\n          <div class="loading-subtext">잠시만 기다려주세요.</div>\n        </div>\n      </div>\n\n      \x3c!-- 구간 정보 패널 --\x3e\n      <div v-if="legSummary?.length" class="leg-panel">\n        <div\n            v-for="leg in legSummary"\n            :key="leg.index"\n            class="leg-item"\n            @click="panToLeg(leg)"\n            :title="클릭하여 이동"\n        >\n          <div class="leg-title">{{ leg.fromCityName }} → {{ leg.toCityName }}</div>\n          <div class="leg-row">Dist {{ leg.nm }} NM \xb7 {{ leg.kn }} kn</div>\n          <div class="leg-row">\n            Sail {{ leg.sailHrs }} h\n            <span v-if="leg.stayHrs"> \xb7 Stay {{ leg.stayHrs }} h</span>\n          </div>\n          <div class="leg-row">ETD {{ leg.etd }}</div>\n          <div class="leg-row">ETA {{ leg.eta }}</div>\n        </div>\n      </div>\n\n      \x3c!-- 거리 정보 오버레이 --\x3e\n      <div v-if="routeData" class="distance-overlay">\n        <div class="distance-info">\n          <div class="distance-value">\n            {{ Math.round(routeData.distance * 10) / 10 }} NM\n          </div>\n          <div class="distance-label">총 거리</div>\n\n          <div class="time-info">\n            <div class="time-value">\n              {{ Math.round(totalTravelTime * 10) / 10 }} hrs\n            </div>\n          </div>\n\n          \x3c!-- 추가 정보 --\x3e\n          <div class="segments-info" v-if="currentSegments.length > 0">\n            <div class="segments-count">{{ currentSegments.length }}개 구간</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<style scoped>\n.map__section {\n    width: 100%;\n    margin-top: 30px;\n}\n\n.map__container {\n    width: 100%;\n    height: 500px;\n    border: 1px solid #e0e0e0;\n    border-radius: 8px;\n    overflow: hidden;\n    position: relative; /* relative positioning 추가 */\n}\n\n.distance-map {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    z-index: 1;\n}\n\n/* map__container를 기준으로 한 로딩 오버레이 */\n.map-loading-overlay {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: rgba(255, 255, 255, 0.8);\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    z-index: 1000;\n    backdrop-filter: blur(2px);\n}\n\n.loading-content {\n    text-align: center;\n    padding: 30px;\n    background: white;\n    border-radius: 12px;\n    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);\n    border: 1px solid #e0e0e0;\n}\n\n.loading-spinner {\n    width: 40px;\n    height: 40px;\n    border: 3px solid #f3f3f3;\n    border-top: 3px solid #2563eb;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n    margin: 0 auto 16px;\n}\n\n@keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n}\n\n.loading-text {\n    font-size: 16px;\n    font-weight: 600;\n    color: #2563eb;\n    margin-bottom: 8px;\n}\n\n.loading-subtext {\n    font-size: 14px;\n    color: #666;\n}\n\n/* 거리 정보 오버레이 (기존 스타일 유지) */\n.distance-overlay {\n    position: absolute;\n    top: 10px;\n    right: 10px;\n    z-index: 1000;\n    pointer-events: none;\n}\n\n.distance-info {\n    background: rgba(255, 255, 255, 0.95);\n    border-radius: 8px;\n    padding: 12px 16px;\n    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);\n    border: 1px solid #e0e0e0;\n}\n\n.distance-value, .time-value {\n    font-size: 18px;\n    font-weight: bold;\n    color: #2563eb;\n    text-align: center;\n}\n\n.distance-label, .time-label {\n    font-size: 11px;\n    color: #666;\n    text-align: center;\n    margin-top: 2px;\n}\n\n.time-info {\n    margin-top: 8px;\n    padding-top: 8px;\n    border-top: 1px solid #e0e0e0;\n}\n\n:deep(.eta-marker) {\n    .eta-content {\n        background: rgba(37, 99, 235, 0.9);\n        color: white;\n        padding: 4px 8px;\n        border-radius: 4px;\n        text-align: center;\n        font-size: 10px;\n        line-height: 1.2;\n        box-shadow: 0 2px 4px rgba(0,0,0,0.2);\n    }\n\n    .eta-time {\n        font-weight: bold;\n    }\n\n    &.start .eta-content {\n        background: rgba(16, 185, 129, 0.9);\n    }\n\n    &.end .eta-content {\n        background: rgba(239, 68, 68, 0.9);\n    }\n}\n\n:deep(.time-marker) {\n    .time-tick {\n        text-align: center;\n        font-size: 11px;\n    }\n\n    .tick-dot {\n        width: 8px;\n        height: 8px;\n        background: #f59e0b;\n        border-radius: 50%;\n        margin: 0 auto;\n        border: 1px solid white;\n    }\n\n    .tick-label {\n        color: #f59e0b;\n        font-weight: bold;\n        font-size: 11px;\n        margin-top: 2px;\n    }\n\n    .tick-eta {\n        color: #666;\n        font-size: 9px;\n    }\n}\n\n.leg-panel{position:absolute;left:10px;top:10px;z-index:1000;background:#fff;border:1px solid #e0e0e0;border-radius:8px;padding:8px 10px;max-width:260px;max-height:60vh;overflow:auto;box-shadow:0 2px 10px rgba(0,0,0,.1)}\n.leg-item{padding:8px;border-bottom:1px solid #eee;cursor:pointer}\n.leg-item:last-child{border-bottom:0}\n.leg-title{font-weight:700;margin-bottom:4px}\n.leg-row{font-size:12px;color:#444}\n</style>\n  '})})]}),(0,s.jsx)(i.A,{text:"AI가 없었다면."}),(0,s.jsxs)("section",{className:"".concat(l().paragraph," space-y-2"),children:[(0,s.jsxs)("div",{children:[(0,s.jsx)("strong",{children:"스스로 이 문제를 풀 수 있었을까?"}),(0,s.jsx)("br",{}),(0,s.jsx)("span",{children:"대답은 확실히, 아니오."})]}),(0,s.jsx)("div",{children:"AI의 도움을 받아, 쉽게 해결된것도 아니다. 이틀을 여기에 쏟아부어야 했다."}),(0,s.jsxs)("div",{children:["적나라하게 고백하자면, unwrapPath 함수는 AI가 일찍 제시 했지만,",(0,s.jsx)("br",{})," 내가 부족하다보니 스스로 바로잡지 못했다."]}),(0,s.jsxs)("div",{children:["결과가 나온 후에 AI 코드에 주석을 달면서 느낀것이지만, 해결하려는 방향성, 예를들어 지도 반대편을 위해 360도를 고려 등등 그 의도는 알겠다 하더라도. ",(0,s.jsx)("br",{}),"제시된 연산식 들을 완전히 이해한것도 아니다."]}),(0,s.jsx)("div",{children:"앞선 문제로 인해 다른 문제들은 지나가는 길에 즈려밟는 사소한 것으로 느껴질 정도다."}),(0,s.jsxs)("div",{children:["그밖의 문제 1 - Leaflet에게 사이즈를 미리 알려주지 않으면 UX가 부자연스럽게 나온다. (resizeMap 함수)",(0,s.jsx)("br",{}),"그밖의 문제 2 - 각 나라별 언어로 지명이 표기된다. 모두 영문으로 표기하려면, attribution: '\xa9 OpenStreetMap contributors \xa9 CARTO'로 설정해야 한다."]}),(0,s.jsx)("br",{}),(0,s.jsx)("strong",{children:"AI에게 일을 시키는게 '나'여야 하나?"}),(0,s.jsxs)("div",{children:["처음엔, AI가 전에도 할 수 있었던 일을 더 쉽고, 빠르게 해주는줄 알았다."," ",(0,s.jsx)("br",{}),"나중에는, AI가 내가 짠 코드를 개선시켜 준다고 느꼈다. 나를 향상시켜 준다고 느낀거다. ",(0,s.jsx)("br",{}),"지금 보면, AI는 내가 할 수 없는 일을 한다. ",(0,s.jsx)("br",{}),"그러면, AI에게 일을 시키는게 꼭 나여야 할까?"]}),(0,s.jsxs)("div",{children:["내가 자세한 원리를 몰라도 원하는 결과를 얻을 수 있었다면, ",(0,s.jsx)("br",{})," 다른 사람이 내 대신 그렇게 하면 안될 이유가 있을까?"]})]})]})}},9890:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>c});var s=t(5155);t(7711),t(8452);var r=t(2761),a=t(908),i=t(2626),o=t.n(i);t(8173);var l=t(2101);function c(){return(0,s.jsxs)("div",{className:o().container,children:[(0,s.jsx)(r.A,{text:"Nuxt sever가 캐시된 값이 있으면 되돌려 주기."}),(0,s.jsx)(a.A,{text:"2025.08.29"}),(0,s.jsxs)("section",{className:"".concat(o().paragraph," space-y-2"),children:[(0,s.jsx)("strong",{children:"프로젝트 : Ecormarine. Oceanlook_xp 화물운송 웹 프로젝트"}),(0,s.jsx)("div",{children:"항구 목록을 API로 받아와야 하는데, 이 데이터는 자주 바뀌지 않으므로 캐시를 해두고 일정 시간(24시간) 이내에는 캐시된 데이터를 사용하도록 했습니다."})]}),(0,s.jsx)(a.A,{text:"최종 코드"}),(0,s.jsxs)("section",{className:o().paragraph,children:[(0,s.jsx)(l.A,{title:"Nuxt.js - server cache",codeType:"language-javascript",codeBlock:"// 서버 사이드 포트 데이터 캐시\n// server/api/port-cache.post.js\nlet portCache = {\n    data: null,\n    lastFetch: null,\n    isLoading: false\n}\n\nconst CACHE_DURATION = 24 * 60 * 60 * 1000 // 24시간 (ms)\nconst API_BASE_URL = 'https://www.yourapi.net/apiService/port'\n\nexport default defineEventHandler(async (event) => {\n    try {\n        const body = await readBody(event)\n        const { // 필요한 키 꺼냄 } = body\n\n        // 캐시 유효성 검사\n        const now = Date.now()\n        const isCacheValid = portCache.data &&\n            portCache.lastFetch &&\n            (now - portCache.lastFetch) < CACHE_DURATION\n\n        if (isCacheValid) {\n            return {\n                // 캐시된 데이터 반환\n            }\n        }\n\n        // 새로운 데이터 가져오기\n        portCache.isLoading = true\n        const response = await $fetch(API_BASE_URL, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: {\n                // 필요한 키 넣기\n            }\n        })\n\n        // 캐시 업데이트\n        if (response && response.data && response.data.list) {\n            portCache.data = {\n                // 필요한 데이터 가공\n            }\n            portCache.lastFetch = now\n\n            return {\n                // 가공된 데이터 반환\n            }\n        } else {\n            throw new Error('포트 데이터 형식이 올바르지 않습니다.')\n        }\n    } catch (error) {\n        console.error('포트 데이터 캐시 오류:', error)\n        throw createError({\n            statusCode: 500,\n            statusMessage: '포트 데이터를 가져오는데 실패했습니다.'\n        })\n    } finally {\n        portCache.isLoading = false\n    }\n})"}),(0,s.jsx)(l.A,{title:"api 사용례",codeType:"language-javascript",codeBlock:"// composables/useFetchPort.js\nexport const useCachePortList = async (token, plan) => {\n  return await $fetch('/api/port-cache', {\n    method: 'POST',\n    body: {\n      token,\n      grade: \"STANDARD\",\n      type: \"v4/list\",\n    }\n  });\n};"})]})]})}},9978:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>p});var s=t(5155),r=t(7711);t(8452);var a=t(2761),i=t(908),o=t(2626),l=t.n(o),c=t(8173),d=t.n(c),h=t(2101);function p(){return(0,r.default)(()=>t.e(773).then(t.bind(t,7773)).then(e=>e.default),{loadableGenerated:{webpack:()=>[7773]},ssr:!1}),(0,s.jsxs)("div",{className:l().container,children:[(0,s.jsx)(a.A,{text:"Nuxt UI 컬럼 고정이 겹쳐지는 문제."}),(0,s.jsx)(i.A,{text:"2025.08.29"}),(0,s.jsxs)("section",{className:"".concat(l().paragraph," space-y-2"),children:[(0,s.jsx)("strong",{children:"프로젝트 : Ecormarine. Oceanlook_xp 화물운송 웹 프로젝트"}),(0,s.jsx)("br",{}),(0,s.jsxs)("div",{children:["Nuxt UI에서 제공하는 UTable 컴포넌트는 컬럼 고정 기능을 제공한다.",(0,s.jsx)(d(),{href:"https://ui.nuxt.com/components/table#with-column-pinning",className:"text-blue-600 underline",children:"Nuxt UI 공식문서"})]}),(0,s.jsx)("div",{children:"다만, 여러 컬럼을 고정하는 경우 컬럼들이 겹쳐진다."}),(0,s.jsx)("div",{children:"현재 테일윈드를 쓰고 있고, Nuxt UI가 테일윈드를 쓰기 때문에 tailwind css를 주었다."}),(0,s.jsx)("div",{children:"!left-[180px] 이런식으로 좌측 고정 컬럼의 너비만큼 left값을 주면 된다."})]}),(0,s.jsx)(i.A,{text:"기본형 Nuxt UI Pinning 컬럼이 겹쳐있는 모습"}),(0,s.jsx)("img",{className:"mt-3 border border-gray-200 rounded-lg shadow-md",src:"/image/slug/columnpinning.webp",alt:"Nuxt UTable Column Pinning Example"}),(0,s.jsx)(i.A,{text:"최종 코드"}),(0,s.jsxs)("section",{className:l().paragraph,children:[(0,s.jsx)(h.A,{title:"컬럼 정의",codeType:"language-javascript",codeBlock:'const columnPinning = ref({\n    left: ["tradeName"],\n  });\n\n  const columns = ref([\n  {\n    accessorKey: "tradeName",\n    header: "프로젝트명",\n    meta: {\n      class: {\n        th: "min-w-[180px]", // 최소 너비 지정\n        td: "min-w-[180px]",\n      },\n    },\n  },\n  {\n    accessorKey: "orgName",\n    header: "화주",\n    meta: {\n      class: {\n        th: "!left-[180px]", // 좌측 고정 컬럼을 넘지 못하게 너비 지정\n        td: "!left-[180px]",\n      },\n    },\n  },\n  // ...생략\n]'}),(0,s.jsx)(h.A,{title:"사용례",codeType:"language-html",codeBlock:'<UTable\n  v-model:column-pinning="columnPinning"\n  :data\n  :columns\n  :ui=\'{ \n      th: ["[&.is-pinned]:bg-gray-100 [&.is-pinned]:shadow-lg [&.is-pinned]:z-30"],\n      td: [\n        "[&.is-pinned]:shadow-lg [&.is-pinned]:z-20",\n        "[&.is-pinned]:border-r-2 [&.is-pinned]:border-r-gray-300"\n      ],\n  }\'\n/>'})]})]})}},2626:e=>{e.exports={container:"Content_container__YuMwV",paragraph:"Content_paragraph__JAFHy",codeBlock:"Content_codeBlock__DpLTZ",highlight:"Content_highlight__CU7wi"}}},e=>{var n=n=>e(e.s=n);e.O(0,[29,141,173,689,441,517,358],()=>n(8888)),_N_E=e.O()}]);