(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[87],{9413:(e,s,t)=>{Promise.resolve().then(t.bind(t,3899)),Promise.resolve().then(t.bind(t,7260)),Promise.resolve().then(t.bind(t,3713)),Promise.resolve().then(t.t.bind(t,2626,23)),Promise.resolve().then(t.bind(t,2734)),Promise.resolve().then(t.bind(t,5538)),Promise.resolve().then(t.bind(t,807)),Promise.resolve().then(t.bind(t,2719)),Promise.resolve().then(t.bind(t,1485)),Promise.resolve().then(t.bind(t,619)),Promise.resolve().then(t.bind(t,1811)),Promise.resolve().then(t.bind(t,7474)),Promise.resolve().then(t.bind(t,5735)),Promise.resolve().then(t.bind(t,382)),Promise.resolve().then(t.bind(t,7475)),Promise.resolve().then(t.bind(t,7556))},3899:(e,s,t)=>{"use strict";t.d(s,{default:()=>o});var n=t(5155),i=t(6046),r=t(8173),a=t.n(r);function o(){let e=(0,i.useParams)(),s=(0,i.useSearchParams)(),t=e.slug,r=s.get("page")||1;return(0,n.jsx)(a(),{href:"/".concat(t,"?page=").concat(r),className:"text-blue-600 hover:underline",children:"Back to List"})}},2761:(e,s,t)=>{"use strict";t.d(s,{A:()=>i});var n=t(5155);function i(e){let{text:s}=e;return(0,n.jsx)("h1",{className:"text-4xl font-bold text-left my-5 text-gray-800",children:s})}},2101:(e,s,t)=>{"use strict";t.d(s,{A:()=>o});var n=t(5155),i=t(2115),r=t(910),a=t.n(r);function o(e){let{codeType:s,codeBlock:t,initOpen:r=!0,tail:o}=e,[c,l]=(0,i.useState)(r),[d,h]=(0,i.useState)(0),x=(0,i.useRef)(null);return(0,i.useEffect)(()=>{a().highlightAll()},[c]),(0,i.useEffect)(()=>{x.current&&h(c?x.current.scrollHeight:0)},[c,t]),(0,n.jsxs)("div",{className:"w-full mx-auto mb-3",children:[(0,n.jsxs)("button",{onClick:()=>l(!c),className:"w-full text-left p-2 bg-gray-800 text-white rounded-t-md flex justify-between items-center",children:[(0,n.jsxs)("span",{children:["\uD83D\uDCDC 코드 보기",o]}),(0,n.jsx)("span",{children:c?"▲":"▼"})]}),(0,n.jsx)("div",{ref:x,className:"transition-[max-height] duration-300 ease-in-out overflow-hidden bg-gray-900 rounded-b-md",style:{maxHeight:"".concat(d,"px"),padding:c?"1rem":"0"},children:(0,n.jsx)("pre",{className:"whitespace-pre-wrap ".concat(s),children:(0,n.jsx)("code",{children:t})})})]})}t(8452)},908:(e,s,t)=>{"use strict";t.d(s,{A:()=>i});var n=t(5155);function i(e){let{text:s}=e;return(0,n.jsxs)("div",{style:{display:"flex",alignItems:"center",margin:"40px 0"},children:[(0,n.jsx)("div",{style:{flex:1,height:"1px",backgroundColor:"#ccc"}}),s&&(0,n.jsx)("span",{style:{margin:"0 10px",color:"#666",fontSize:"14px"},children:s}),(0,n.jsx)("div",{style:{flex:1,height:"1px",backgroundColor:"#ccc"}})]})}},6529:(e,s,t)=>{"use strict";t.d(s,{A:()=>i});var n=t(5155);function i(e){let{text:s}=e;return(0,n.jsx)("h2",{className:"text-2xl mt-12 mb-3 text-gray-700 font-bold",children:s})}},9969:(e,s,t)=>{"use strict";t.d(s,{A:()=>i});var n=t(5155);function i(e){let{text:s,addClass:t}=e;return(0,n.jsxs)("div",{className:"".concat(t," border border-dashed border-gray-400 p-4 bg-gray-50 italic shadow-md text-gray-700"),children:[(0,n.jsx)("strong",{className:"font-semibold",children:"Note:"}),(0,n.jsx)("p",{className:"whitespace-pre-line",children:s})]})}},6167:(e,s,t)=>{"use strict";t.d(s,{A:()=>i});var n=t(5155);function i(e){let{href:s,prefix:t,text:i,title:r}=e;return(0,n.jsxs)("div",{children:[(0,n.jsxs)("span",{className:"text-gray-600",children:[r||"출처"," : "]}),t?(0,n.jsxs)("strong",{className:"text-gray-600",children:["[ ",t," ] "]}):null,(0,n.jsx)("a",{href:s,target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:i})]})}},2139:(e,s,t)=>{"use strict";t.d(s,{A:()=>i});var n=t(5155);function i(e){let{text:s,type:t="h3"}=e,i=["h1","h2","h3","p","div"].includes(t)?t:"h2",r="mt-6 mb-2 font-bold text-gray-700 "+("h1"===t?"text-3xl":"h2"===t?"text-2xl":"h3"===t?"text-xl":"text-base");return(0,n.jsx)(i,{className:r,children:s})}},7260:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>x});var n=t(5155),i=t(910),r=t.n(i);t(8452);var a=t(2115),o=t(2761),c=t(6167),l=t(908),d=t(2626),h=t.n(d);function x(){return(0,a.useEffect)(()=>{r().highlightAll()},[]),(0,n.jsxs)("div",{className:h().container,children:[(0,n.jsx)(o.A,{text:"The Anatomy of a Good Decision"}),(0,n.jsx)(c.A,{href:"https://shrime.medium.com/the-anatomy-of-a-good-decision-bc3f590a0d76",prefix:"Medium",text:"https://shrime.medium.com/the-anatomy-of-a-good-decision-bc3f590a0d76"}),(0,n.jsx)(l.A,{text:"2024.01.27"}),(0,n.jsxs)("section",{className:h().paragraph,children:[(0,n.jsx)("div",{children:"좋은 결정의 해부학. 자세한 설명은 링크를 참조."}),(0,n.jsx)("div",{children:"간단한 해석을 그림 하단에 넣었다가, 위로 올렸습니다."}),(0,n.jsx)("div",{children:"왜냐면, 저는 7단계에서 맥이 빠졌기 때문입니다."})]}),(0,n.jsx)(l.A,{}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"Step1: 오너쉽 체크 - 결정할 권한이 있습니까? 결정권이 없다고 하기 전에 혹시 스스로 회피하고 있는지도 생각해 보세요. 도식은 두려움에 회피하지 않는데도 도움이 될겁니다."}),(0,n.jsx)("li",{children:"Step2: 가치 분석 - 세가지 중요한 것을 꼽습니다. 중요도에 대해 1-10 척도를 적용해 두세요.(예, 급여 10, 근무지 2, 근로시간 8)"}),(0,n.jsx)("li",{children:'Step3: 선택지 설정 - 어떤 선택을 할지를 나열해 둡니다. 예를들어, 결혼생활을 고민한다면 "떠난다"와 "남는다" 두가지 선택지가 있을 수 있습니다.'}),(0,n.jsx)("li",{children:"Step4: The dealbreakers(걸림돌) - 절대 받아 들일 수 없는 조건이 있는지 확인합니다."}),(0,n.jsx)("li",{children:"Step5: 각 옵션 평가 - 1~10점 척도로 각 옵션(Step2 가치)에 대해 점수를 주세요. (예, 급여: 8, 근무지 위치: 10, 근로시간: 7)"}),(0,n.jsx)("li",{children:"Step6: 수학은 마법과 같아요 - 5단계 점수와 2단계 가중치를 곱하고, 곱한 값들을 합산하면 됩니다. (예, 직장1 = 급여 10*8 + 근무지 2*10 + 근로시간 8*7)"}),(0,n.jsx)("li",{children:"Step7: 불확실성 - 비록, 이성적으로 결정을 내렸지만 아직입니다. 5일동안 그 결정을 내렸다고 생각하고 살아보세요. 그 후에, 기분이 어떤가요? 만약 계속해서 좋다면, 끝입니다."})]})}),(0,n.jsx)(l.A,{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"마지막 7단계에서 살짝 어이가 없어졌다."}),(0,n.jsx)("div",{children:"무언가 명료한듯 하다가 슬그머니 내빼는 느낌이랄까."}),(0,n.jsx)("div",{children:"저만 이런기분인 걸까요. 암튼, 간단한 수식이지만 결정을 구체화 하는 방안으로 고려해볼 수는 있겠다."}),(0,n.jsx)("div",{children:"팀별 시너지를 계산하는 것도, 기회가 되면 정리해 보겠습니다. GPT와 질의 응답을 통해 만든 수식이지만, 이 글보다 오히려 신뢰도가 있을것 같아요. 기분이를 넣지는 않았거든요."})]}),(0,n.jsx)("br",{}),(0,n.jsx)(c.A,{href:"https://www.markshrime.com/anatomy-pdf",prefix:"markshrime.com",text:"https://www.markshrime.com/anatomy-pdf"}),(0,n.jsx)("img",{className:"mt-3",src:"/image/slug/decisionMaking.jpg"}),(0,n.jsx)(l.A,{text:"저기요... 주의사항이 뒤에 적혀있어요. 아, 안돼..."}),(0,n.jsx)("img",{className:"mt-3",src:"/image/slug/keselius.png"})]})}},3713:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>d});var n=t(5155),i=t(2761),r=t(6167),a=t(908),o=t(2626),c=t.n(o),l=t(9969);function d(){return(0,n.jsxs)("div",{className:c().container,children:[(0,n.jsx)(i.A,{text:"Being a “learn-it-all” will get you way further than being a “know-it-all”"}),(0,n.jsx)(r.A,{href:"https://blog.medium.com/being-a-learn-it-all-will-get-you-way-further-than-being-a-know-it-all-49b63b7cae51",prefix:"Medium",text:"https://blog.medium.com/being-a-learn-it-all-will-get-you-way-further-than-being-a-know-it-all-49b63b7cae51"}),(0,n.jsx)(a.A,{text:"2024.02.04"}),(0,n.jsx)("section",{className:c().paragraph,children:(0,n.jsx)("div",{children:"번역이 틀릴 수 있습니다."})}),(0,n.jsx)(a.A,{}),(0,n.jsx)(i.A,{text:"모든 걸 알고 있다고 하는 것보다, 계속 배우려는 태도를 가지는 것이 훨씬 발전할 수 있다."}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"Y Combinator의 창립자 폴 그래햄은 2007년,"}),(0,n.jsx)("div",{children:"구글의 웹 애플리케이션(주로 Gmail)과 애플이 부상하자 윈도우를 향해 '할머니들이나 쓰는 쓸모없는 도구'로 만들어 버렸다고 말했습니다."})]}),(0,n.jsxs)("section",{className:"mb-5",children:[(0,n.jsx)("div",{children:'그래햄은 "마이크로소프트의 최대 약점"은 그들이 얼마나 형편없는지 모른다는 것이라 했습니다. 다시말해 그들이 안일하다는 겁니다. - 그리고 그래햄의 말이 틀린것도 아니었습니다.'}),(0,n.jsx)(l.A,{text:"complacent - 안일한"})]}),(0,n.jsxs)("section",{className:"mb-5",children:[(0,n.jsx)("div",{children:"마이크로 소프트 엔지니어인 오바산조는 이렇게 회상합니다."}),(0,n.jsx)("div",{children:"수많은 실패에도 불구하고,"}),(0,n.jsx)("div",{children:"많은 이들이 우리가 윈도우와 오피스를 보유했다는 이유로 마치 우리가 엄청난 것처럼 행동 했습니다."}),(0,n.jsx)("div",{children:"그 두 가지는 역사상 가장 성공적인 소프트웨어이긴 했죠."}),(0,n.jsx)(l.A,{text:"best thing since sliced bread - 1928년 미국에서 처음 상업적으로 판매된 식빵. 미리 잘려서 나와서 당시엔 혁신이었다고."}),(0,n.jsx)(l.A,{text:"대단한 것처럼 행동하는 주체가 외부인이 아니라 MS 내부, 자신들을 말하는 것 같습니다."})]}),(0,n.jsxs)("section",{className:"mb-5",children:[(0,n.jsx)("div",{children:"교훈: 성공에 안주하지 않는 것이 때로는 실패를 딛고 다시 일어서는 것보다 더 어렵다."}),(0,n.jsx)("div",{children:"실수를 감수할 용기,"}),(0,n.jsx)("div",{children:"남과 다르게 행동할 용기,"}),(0,n.jsx)("div",{children:"새로운 것에 서툴러도 배우려는 용기"}),(0,n.jsx)("div",{children:"— 이런 것들을 갖추는 것은, 윈도우 처럼 전설적인 제품을 만든 이들이라도 결코 쉬운 일이 아니다."}),(0,n.jsx)(l.A,{text:"find the will - 맘먹고 해내려는 것."}),(0,n.jsx)(l.A,{text:"weird - 기이한."}),(0,n.jsx)(l.A,{text:"from scratch - 완전 새출발. 경주에서 출발선을 긁고(scratch) 거기부터 라는데서 기원. 출발선은 모두에게 공평한 시작점이자, 아무것도 없는 새출발로 의미가 확장 되었다고."})]}),(0,n.jsxs)("section",{className:"mb-5",children:[(0,n.jsx)("div",{children:'나델라는 안일함을 극복하기 위해, "성장 마인드셋", "비판에서 배울것"을 화이트보드에 적어두었습니다.'}),(0,n.jsx)("div",{children:"마이크로 소프트는 마침내 Azure 같은 소프트웨어를 개발했고, 현재 Apple과 나란히 할 만큼 성장했습니다."}),(0,n.jsx)("div",{children:"몇가지 전략적 투자(GitHub, LinkedIn, OpenAI)를 통해 다시 중요한 기업으로 자리했습니다."}),(0,n.jsx)(l.A,{text:"Satya Nadella - MS 최고경영자. MS에 돈과 인재가 가득하다고 해서, 혁신이 뚝딱 하고 쉽게 달성된게 아니었던듯."})]}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{className:"font-bold",children:'필립 콜라도는 리더에게 가장 중요한 것은 겸손과 긍적적인 태도로 사람들이 "현실을 직시"하게 돕는것이라 했습니다.'}),(0,n.jsx)("div",{children:"오바산조가 마이크로소프트에서 일하며 얻은 교훈은 일과 생활 모두에 적용 가능할 것 같습니다."}),(0,n.jsx)("div",{className:"mt-5",children:"끊임없이 배우려는 사람(learn-it-all)이 되는것이,"}),(0,n.jsx)("div",{children:"모든 것을 안다고 하는 사람(know-it-all)보다 멀리 나아가게 할 거라는 거죠."}),(0,n.jsx)(l.A,{text:"primary takeaway - 가장 큰 교훈"})]})]})}},2734:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>m});var n=t(5155),i=t(910),r=t.n(i);t(8452);var a=t(2115),o=t(2761),c=t(6529),l=t(2139),d=t(6167),h=t(908),x=t(9969),j=t(2626),p=t.n(j);function m(){return(0,a.useEffect)(()=>{r().highlightAll()},[]),(0,n.jsxs)("div",{className:p().container,children:[(0,n.jsx)(o.A,{text:"Say Goodbye to JavaScript’s Date. Meet the Powerful New Temporal API"}),(0,n.jsx)(d.A,{href:"https://medium.com/javascript-in-plain-english/say-goodbye-to-javascripts-date-woes-meet-the-powerful-new-temporal-api-73f99c8823e0",prefix:"Medium",text:"Say Goodbye to JavaScript’s Date. Meet the Powerful New Temporal API"}),(0,n.jsx)(h.A,{text:"2024.12.31"}),(0,n.jsx)("section",{className:p().paragraph,children:(0,n.jsxs)("div",{children:["원문을 읽고 요약한 글입니다. 당연히, ",(0,n.jsx)("strong",{children:"번역, 주석 등에 오류가 있을 확률 57,000%."}),(0,n.jsx)("br",{}),"반박시 무조건 제가 틀렸습니다.",(0,n.jsx)("br",{}),(0,n.jsx)("br",{}),"Temporal은 현재 ECMAScript 사양의 Stage 3 단계로, 최종적으로 Stage 4에 도달하면 JavaScript의 표준으로 채택됩니다. Stage 3은 대부분의 기능이 안정화되었고, 구체적인 구현 세부사항을 다듬는 단계입니다."]})}),(0,n.jsx)(h.A,{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{className:"text-gray-500 text-2xl font-bold",children:"변덕쟁이 Date 객체와 싸우는데 지치셨죠?"}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"Date는 초기부터 있었습니다. 시간대 처리, 서머타임 조정, 특이한 API 설계로 수많은 개발자들을 좌절하게 했습니다."}),(0,n.jsx)("div",{children:"이제 대안이 생겼습니다."})]}),(0,n.jsx)(c.A,{text:"왜 Temporal? Date의 한계를 알아보기"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"Time Zone Troubles : 다양한 시간대를 처리해야 할때 거지같음."}),(0,n.jsx)("li",{children:"Mutability Issues: Date가 가변적이라서 코드의 조그만 변경에도 사이드 이팩트가 날 수 있음."}),(0,n.jsx)("li",{children:"Quirky Month Indexing: 월이 0부터 시작해서 자주 함정에 빠뜨림."}),(0,n.jsx)("li",{children:"Limited Precision: 정밀하지 않음. 번거롭고 오류가 발생하기 쉬움."})]})}),(0,n.jsx)(c.A,{text:"The Temporal Basics: 끝내주는 녀석들"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"Temporal.PlainDate"}),(0,n.jsx)("li",{children:"Temporal.PlainTime"}),(0,n.jsx)("li",{children:"Temporal.PlainDateTime"}),(0,n.jsx)("li",{children:"Temporal.ZonedDateTime"}),(0,n.jsx)("li",{children:"Temporal.Duration"})]})}),(0,n.jsx)(h.A,{}),(0,n.jsx)(c.A,{text:"써봅시다."}),(0,n.jsx)(l.A,{text:"날짜 생성"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"const date = Temporal.PlainDate.from('2024-10-11');\nconsole.log(date.toString()); // Output: 2024-10-11"})}),(0,n.jsx)(l.A,{text:"날짜 추가"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"const today = Temporal.PlainDate.from('2024-10-11');\nconst tomorrow = today.add({ days: 1 });\nconsole.log(tomorrow.toString()); // Output: 2024-10-12"})}),(0,n.jsx)(l.A,{text:"타임존"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"const zonedDateTime = Temporal.ZonedDateTime.from({\n  timeZone: 'America/New_York',\n  year: 2024,\n  month: 10,\n  day: 11,\n  hour: 12,\n});\nconsole.log(zonedDateTime.toString()); // Output includes the time zone"})}),(0,n.jsx)(l.A,{text:"쉬운 날짜 계산"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"const start = Temporal.PlainDateTime.from('2024-10-11T12:00');\nconst end = Temporal.PlainDateTime.from('2024-10-11T15:30');\nconst duration = end.since(start);\nconsole.log(duration.toString()); // Output: PT3H30M (3 hours, 30 minutes)"})}),(0,n.jsx)(c.A,{text:"실제 활용 예시"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-disc ml-5",children:[(0,n.jsx)("li",{children:"국제적 앱 - 유저별 시간대 관리 용이"}),(0,n.jsx)("li",{children:"스케쥴 관리 - 예약자별 시간대 관리도 용이"}),(0,n.jsx)("li",{children:"보고서 같은데서 시간 계산 좋음."})]})}),(0,n.jsx)(h.A,{}),(0,n.jsx)(c.A,{text:"Temporal API가 지원되는 플랫폼과 브라우저"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"아직 공식은 아닙니다. 하지만 곧 옵니다."}),(0,n.jsxs)("ul",{className:"list-disc ml-5",children:[(0,n.jsx)("li",{children:"브라우저: 크롬과 파이어폭스 최신 버전은 실험적 지원을 제공합니다."}),(0,n.jsx)("li",{children:"Node.js: 향후 제공할 것으로 예상됩니다."}),(0,n.jsx)("li",{children:"폴리필 사용: 지원하지 않는 환경을 위해 폴리필을 제공하고 있습니다. 즉, 사용해 볼 수 있어요."})]})]}),(0,n.jsx)("br",{}),(0,n.jsx)(x.A,{text:"Polyfill - 기존 기능을 사용하여 아직 지원하지 않는 기능을 구현하도록 하는 코드. 즉, 하위 호환을 위한 도구."}),(0,n.jsx)("br",{}),(0,n.jsx)(c.A,{text:"향후, Javascript가 날짜와 시간을 다루는 법."}),(0,n.jsx)("section",{children:"Temporal은 유연함과 신뢰성을 제공합니다. Temporal인거죠!"})]})}},5538:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>p});var n=t(5155),i=t(910),r=t.n(i);t(8452);var a=t(2115),o=t(2761),c=t(6529),l=t(2139),d=t(6167),h=t(908),x=t(2626),j=t.n(x);function p(){return(0,a.useEffect)(()=>{r().highlightAll()},[]),(0,n.jsxs)("div",{className:j().container,children:[(0,n.jsx)(o.A,{text:"This new JavaScript operator is an absolute game changer"}),(0,n.jsx)(d.A,{href:"https://medium.com/coding-beauty/new-javascript-operator-1e60dea05654",prefix:"Medium",text:"This new JavaScript operator is an absolute game changer"}),(0,n.jsx)(h.A,{text:"2024.12.31"}),(0,n.jsxs)("section",{className:j().paragraph,children:[(0,n.jsxs)("div",{children:["원문을 읽고 요약한 글이며, 당연히, ",(0,n.jsx)("strong",{children:"번역에 오류가 있을 수 있습니다."})," 반박시 당신이 옳습니다."]}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:'?=은 "안전 할당 연산자"라고 하는데, 아직 공식 사양에 포함되지 않았습니다.'}),(0,n.jsx)(d.A,{href:"https://github.com/arthurfiorette/proposal-safe-assignment-operator",prefix:"GitHub",title:"참조",text:"ECMAScript Safe Assignment Operator Proposal"})]}),(0,n.jsx)(h.A,{}),(0,n.jsx)(c.A,{text:"No more try-catch"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"\nasync function name(params) {\n  const [err, res] ?= await fetch('https://codingbeatydev.com');\n  if (err) return console.error(err);\n\n  const [parseError, data] ?= await res.json();\n  if (parseError) return console.log(parseError);\n\n  return data;\n}"})}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"우리는, 이제 깊은 중첩에서 벗어날 수 있다."}),(0,n.jsx)("div",{children:"에러에게 이제 닥치라 하고, 선택하는 것이 가능해졌다."})]}),(0,n.jsx)(l.A,{text:"성공 실패의 상태값이 재할당 되는것이 필요할 때, const를 사용하지 못했지만 이제 그것도 안녕이다."}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"\nfunction writeTransactionToFile(transactions) {\n  const [err, res] ?= fs.writeFileSync('sample.com.txt', transactions);\n  const writeStatus = err ? 'error' : 'success';\n}"})}),(0,n.jsx)(l.A,{text:"어떻게 동작하나?"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"?= 연산자는 내부적으로 Symbol.result를 사용한다."}),(0,n.jsx)("div",{children:"심볼은 어떤 값이 되돌아 오든 일단 작동시킬 수 있다."}),(0,n.jsx)("div",{children:"타입스크립트에서도 사용이 가능하다."})]})]})}},807:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>j});var n=t(5155);t(8452);var i=t(2115),r=t(2761),a=t(6529),o=t(6167),c=t(2101),l=t(908),d=t(9969),h=t(2626),x=t.n(h);function j(){return(0,i.useEffect)(()=>{if(!customElements.get("notification-badge")){class e extends HTMLElement{static get observedAttributes(){return["count"]}attributeChangedCallback(e,s,t){"count"===e&&this.badge&&(this.badge.textContent=t)}connectedCallback(){this.addEventListener("increment",()=>{let e=parseInt(this.getAttribute("count")||"0")+1;this.setAttribute("count",e.toString())}),this.addEventListener("decrement",()=>{let e=Math.max(0,parseInt(this.getAttribute("count")||"0")-1);this.setAttribute("count",e.toString())})}constructor(){super(),this.attachShadow({mode:"open"}),this.badge=document.createElement("span"),this.badge.classList.add("badge"),this.badge.textContent=this.getAttribute("count")||"0";let e=document.createElement("style");e.textContent="\n          .badge {\n            background: red;\n            color: white;\n            padding: 5px 10px;\n            border-radius: 12px;\n            font-size: 12px;\n            display: inline-block;\n          }\n        ",this.shadowRoot.appendChild(e),this.shadowRoot.appendChild(this.badge)}}customElements.define("notification-badge",e)}},[]),(0,n.jsxs)("div",{className:x().container,children:[(0,n.jsx)(r.A,{text:"Web Components Will Kill JavaScript Frameworks (Eventually)"}),(0,n.jsx)(o.A,{href:"https://javascript.plainenglish.io/web-components-will-kill-javascript-frameworks-eventually-c8ea56222e7b",prefix:"Medium",text:"Web Components Will Kill JavaScript Frameworks (Eventually)"}),(0,n.jsx)(l.A,{text:"2024.12.31"}),(0,n.jsx)("section",{className:x().paragraph,children:(0,n.jsxs)("div",{children:["원문을 읽고 요약한 글이며, 당연히,"," ",(0,n.jsx)("strong",{children:"번역, 주석 등에 오류가 있을 확률 58,000%."}),(0,n.jsx)("br",{}),"반박시 무조건 당신이 옳습니다."]})}),(0,n.jsx)(l.A,{}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:["2025년, 새 웹 앱을 만들려고 할 때, 거의 무의식적으로 프레임웤을 선택하려고 할 겁니다.",(0,n.jsx)("br",{})," - React, Vue, Angular, Svelte."]}),(0,n.jsx)("br",{}),(0,n.jsxs)("div",{children:["하지만, 수 천 줄의 다른 사람 코드를 끌어오지 않고,"," ",(0,n.jsx)("strong",{children:"순수 자바스크립트"}),"와 ",(0,n.jsx)("strong",{children:"웹 콤포넌트"}),"로 원하는걸 다할 수 있다면요?"," "]}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"의존성도, 락인(lock-in)도 없고, 가상 DOM의 오버헤드도 없는 - 완전 순수, 브라우저 본연의 힘으로."}),(0,n.jsx)("div",{children:"그런데, 이게 허황된 꿈이 아니면요?!"}),(0,n.jsx)("br",{}),(0,n.jsx)(d.A,{text:"lock-in: 개발 결과물이 프레임웤, 라이브러리, 생태계 등에 종속성이 커지고 나아가 만들어진 앱이 브라우저에 대한 비호환성이 증가하는 현상."})]}),(0,n.jsx)(a.A,{text:"Frameworks: 양날의 검"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"물론 장점들이 많지만, 단점이 없는게 아닙니다."}),(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"프레임웤 락인: React를 Vue로 바꾸고 싶어요? 처음 부터 다 다시 만드세요."}),(0,n.jsx)("li",{children:"성능 오버헤드: 추상화는 앱이 작을때 문제 없지만, 규모가 커진다면? 그 차이가 쌓여 성능에 영향을 줄겁니다."}),(0,n.jsx)("li",{children:"의존성 증가: 프레임웤 업데이트는 앱을 망가뜨릴 위험을 내재하고 있습니다. 프레임웤 유지보수자들이 호환이 잘 되도록 해주기만을 바래야 할거고요."}),(0,n.jsx)("li",{children:"러닝커브: 개발자들에게 종종 프레임웤의 특징에 시간을 쓰게 만들고, JavaScript의 기본을 소흘히 하게 합니다."})]})]}),(0,n.jsx)(a.A,{text:"Pure JavaScript and Web Components"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"순수 스크립트는 사랑이죠. 아니면, 사랑과 증오거나."}),(0,n.jsx)("div",{children:"웹 컴포넌트와 짝을 이루면, 더 빠르고 재사용 가능하고, 비종속적인 그러니까 프레임웤에 종속되지 않는 컴포넌트가 됩니다."})]}),(0,n.jsx)(c.A,{codeType:"language-javascript",codeBlock:'const MyComponentProto = Object.create(HTMLElement.prototype);\n\n  MyComponentProto.connectedCallback = function () {\n    this.innerHTML = "<div>Hello, Web Components!</div>";\n  };\n\n  // 순수스크립트로 프레임웤에 비종속적인 컴포넌트를 만듬.\n  customElements.define("my-component", MyComponentProto.constructor);\n'}),(0,n.jsx)(a.A,{text:"Web Components가 뭔데?"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"사용자 정의 HTML 요소 입니다."}),(0,n.jsx)("div",{children:"브라우저가 지원하는 기본 기술로 스타일, 동작 등을 캡슐화하여 재사용 가능하게 만든 것입니다."}),(0,n.jsx)("br",{}),(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"Custom Elements"}),(0,n.jsx)("li",{children:"Shadow DOM: 스타일과 로직을 캡슐화 하여, 스크립트와 CSS의 누수를 방지합니다."}),(0,n.jsx)("li",{children:"HTML Templates: 재사용 가능하며 동적인 컨텐츠를 만들기도 좋습니다."})]}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"이것들을 통해, 현대적이고 모듈화된 UI를 프레임웤 없이 만들 수 있습니다."})]}),(0,n.jsx)("br",{}),(0,n.jsx)(d.A,{text:"CSS leakage: 특정 요소에 적용한 CSS가 다른 요소 까지 영향을 줌."}),(0,n.jsx)("br",{}),(0,n.jsx)(a.A,{text:"이들이 왜 게임체인저인가?"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"이 둘이 왜 판을 흔들수 있는가."}),(0,n.jsx)("br",{}),(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"Freedom from Frameworks: 이렇게 만든 컴포넌트들은 React환경이든 Vue, Angular 어디든 꼽으면 잘됩니다."}),(0,n.jsx)("li",{children:"Performance Boost: 버츄얼돔이 없으면 더 빠릅니다. 모바일 퍼스트라면 더더욱."}),(0,n.jsx)("li",{children:"Simpler Maintenance: 프레임웤의 버전과 같은 트렌드를 타지도 않을 것이고 시간이 지나도 바닐라 스크립트는 매우 견고한 코드로 남을것입니다."}),(0,n.jsx)("li",{children:"Focus on Fundamentals(기본에 충실하라): 스크립트 자체에 충실하면, 더 강하고 능숙한 개발자가 될 수 있습니다. 이건 현장에서 사용하는 프레임웤이 무엇이든 강력한 개발자로 존재할 수 있게 만듭니다."})]})]}),(0,n.jsx)("br",{}),(0,n.jsx)(a.A,{text:"그럼 Frameworks은 사라지나?"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:(0,n.jsx)("strong",{children:"아니요."})}),(0,n.jsx)("div",{children:"대규모 프로젝트 에서도, 프레임웤은 상태관리(state), 라우팅, 데이터 불러오기 등에서 강력한 기능을 제공합니다."}),(0,n.jsx)("div",{children:"하지만, 작은 규모에서 부터 몇몇 큰 프로젝트에서도 순수 스크립트는 새 애인감으로 곁눈질 하게 만들겁니다."})]}),(0,n.jsx)("br",{}),(0,n.jsx)(a.A,{text:"실제 예제"}),(0,n.jsx)(c.A,{codeType:"language-javascript",codeBlock:"class NotificationBadge extends HTMLElement {\n  constructor() {\n    super();\n    const shadow = this.attachShadow({ mode: 'open' });\n\n    // Create the badge\n    const badge = document.createElement('span');\n    badge.setAttribute('class', 'badge');\n    badge.textContent = this.getAttribute('count') || '0';\n\n    // Add styles\n    const style = document.createElement('style');\n    style.textContent = `\n      .badge {\n        background: red;\n        color: white;\n        padding: 5px 10px;\n        border-radius: 12px;\n        font-size: 12px;\n        display: inline-block;\n      }\n    `;\n\n    shadow.appendChild(style);\n    shadow.appendChild(badge);\n  }\n}\n\ncustomElements.define('notification-badge', NotificationBadge);\n"}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:["이제 ",'<notification-badge count="5"></notification-badge>',"는 앱 어디서든 쓸 수 있습니다."]}),(0,n.jsx)("div",{children:"count 변경이요? 네, 다이나믹 합니다."})]}),(0,n.jsx)("br",{}),(0,n.jsx)(d.A,{text:"개인적으로 class는 javaScript답지 못하며, class 기반 언어에서 건너온 개발자들에게 잘보이려고 속옷을 벗어다 바친, js 진영의 흑역사라 생각함."}),(0,n.jsx)("br",{}),(0,n.jsx)("notification-badge",{count:"5"}),(0,n.jsx)("button",{className:"bg-blue-500 text-white px-4 py-2 rounded-md shadow-md hover:bg-blue-600 active:bg-blue-700 ml-2 mb-2",onClick:()=>{document.querySelector("notification-badge").dispatchEvent(new Event("increment"))},children:"증가 click!! (+)"}),(0,n.jsx)(c.A,{codeType:"language-javascript",codeBlock:'useEffect(() => {\n    if (!customElements.get("notification-badge")) {\n      class NotificationBadge extends HTMLElement {\n        constructor() {\n          super();\n          this.attachShadow({ mode: "open" });\n\n          // Create the badge\n          this.badge = document.createElement("span");\n          this.badge.classList.add("badge");\n          this.badge.textContent = this.getAttribute("count") || "0";\n\n          // Add styles\n          const style = document.createElement("style");\n          style.textContent = `\n            .badge {\n              background: red;\n              color: white;\n              padding: 5px 10px;\n              border-radius: 12px;\n              font-size: 12px;\n              display: inline-block;\n            }\n          `;\n\n          this.shadowRoot.appendChild(style);\n          this.shadowRoot.appendChild(this.badge);\n        }\n\n        static get observedAttributes() {\n          // 속성이 바뀌면 감지 (브라우저에서 제공하는 Custom Elements API의 일부)\n          return ["count"];\n        }\n\n        attributeChangedCallback(name, oldValue, newValue) {\n          // 속성이 변경될 때 실행\n          if (name === "count" && this.badge) {\n            this.badge.textContent = newValue;\n          }\n        }\n\n        connectedCallback() {\n          // 컴포넌트가 DOM에 추가되었을 때 실행\n          this.addEventListener("increment", () => {\n            // 이게 싫어서. 양방향 변경이 좋아서, vue, react 쓰는거 아닙니꽈? 어뜨게 하라는 거야...\n            const newCount = parseInt(this.getAttribute("count") || "0") + 1;\n            this.setAttribute("count", newCount.toString());\n          });\n\n          this.addEventListener("decrement", () => {\n            const newCount = Math.max(\n              0,\n              parseInt(this.getAttribute("count") || "0") - 1\n            );\n            this.setAttribute("count", newCount.toString());\n          });\n        }\n      }\n\n      customElements.define("notification-badge", NotificationBadge);\n    }\n  }, []);',initOpen:!1,tail:" - 실제, 화면에 붙여본 코드.(클릭하여 오픈) 되게 하기 싫어집니다. 아..."}),(0,n.jsx)(c.A,{codeType:"language-html",codeBlock:'<notification-badge count="5"></notification-badge>\n  // 슈밥 코드 하이라이팅도 이상함돠. 아마 인라인에 스크립트 들어있어서? 흑흑 이 롸이브롸리 짜증나요.\n  <button\n    onClick={() => {\n      document\n        .querySelector("notification-badge")\n        .dispatchEvent(new Event("increment"));\n    }}\n  >\n    증가 click!! (+)\n  </button>\n\n  ',initOpen:!1,tail:" - 태그"}),(0,n.jsx)(a.A,{text:"프레임웤이 줄어든 미래의 개발환경"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"웹은 차츰 상호 운용성과 경량화를 향해가고 있습니다."}),(0,n.jsx)("div",{children:"순수 스크립트와 웹 콤포넌트는 이런 경향을 선도하고 있고, 더 빠르고 유지보수 성이 높으며 프레임웤에 의존적이지 않습니다."}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"프레임웤 버리자는게 아닙니다."}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"이제 프레임웤을 사용할 때, 생각을 좀 해보자는 겁니다."}),(0,n.jsxs)("div",{children:[(0,n.jsx)("span",{className:"italic",children:'"혹시, 이거 바닐라랑 웹 콤넌트로 가능할까?"'}),"스스로 대답을 해보면, 아마 놀라실 겁니다."]}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"미래의 웹은 점점 트렌드가 아니라 더 표준을 따르는 쪽으로 가고 있습니다."}),(0,n.jsx)("div",{children:"그리고 그 방향에서 순수 자바스크립트와 웹 콤포넌트를 사용하면, 그 가능성이 무한합니다."})]})]})}},2719:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>j});var n=t(5155),i=t(910),r=t.n(i);t(8452);var a=t(2115),o=t(2761),c=t(2139),l=t(6167),d=t(908),h=t(2626),x=t.n(h);function j(){return(0,a.useEffect)(()=>{r().highlightAll()},[]),(0,n.jsxs)("div",{className:x().container,children:[(0,n.jsx)(o.A,{text:"Day 3: Can You Spot the Bug in This JavaScript Function?"}),(0,n.jsx)(l.A,{href:"https://medium.com/javascript-in-plain-english/day-3-can-you-spot-the-bug-in-this-javascript-function-f3c95eaf1ccf",prefix:"Medium",text:"Day 3: Can You Spot the Bug in This JavaScript Function?"}),(0,n.jsx)(d.A,{text:"2024.12.31"}),(0,n.jsx)("section",{className:x().paragraph,children:(0,n.jsxs)("div",{children:["원문을 읽고 요약한 글입니다. 당연히, ",(0,n.jsx)("strong",{children:"번역, 주석 등에 오류가 있을 확률 59,000%."})]})}),(0,n.jsx)(d.A,{}),(0,n.jsx)(c.A,{text:"도전문제"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"function createCounters() {\n  let counters = [];\n  for (var i = 0; i < 3; i++) {\n    counters.push(function() {\n      return i;\n    });\n  }\n  return counters;\n}\n\nconst counters = createCounters();\nconsole.log(counters[0]());\nconsole.log(counters[1]());\nconsole.log(counters[2]());\n"})}),(0,n.jsx)("br",{}),(0,n.jsx)(c.A,{text:"질문"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"어떻게 동작 할까요?"}),(0,n.jsx)("div",{children:"어떻게 하면 해결 할 수 있을까요?"})]}),(0,n.jsx)("br",{}),(0,n.jsx)(c.A,{text:"해설"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"반복문에서 변수 i에 var를 사용하고 있습니다."}),(0,n.jsx)("div",{children:"JavaScript에서 var는 함수 스코프를 가지므로, 반복문의 모든 반복이 동일한 변수를 공유합니다."}),(0,n.jsx)("div",{children:"해결하려면, 각 반복문에서 별도의 스코프를 생성하면 됩니다."})]}),(0,n.jsx)("br",{}),(0,n.jsx)(c.A,{text:"고치려면"}),(0,n.jsx)("section",{children:(0,n.jsx)("div",{children:"반복문에서 루프별로 스코프를 다르게 만드는 것입니다."})}),(0,n.jsx)("br",{}),(0,n.jsx)(c.A,{text:"1. let을 사용."}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"\nfunction createCounters() {\n  let counters = [];\n  for (let i = 0; i < 3; i++) {\n    counters.push(function() {\n      return i;\n    });\n  }\n  return counters;\n}\n"})}),(0,n.jsx)("br",{}),(0,n.jsx)(c.A,{text:"2. 즉시실행 함수 사용. IIFE(Immediately Invoked Function Expression)"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"\nfunction createCounters() {\n  let counters = [];\n  for (var i = 0; i < 3; i++) {\n    (function(i) {\n      counters.push(function() {\n        return i;\n      });\n    })(i);\n  }\n  return counters;\n}\n"})}),(0,n.jsx)(d.A,{}),(0,n.jsx)(c.A,{text:"이 문제의 의미?"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"var와 let의, 차이점. 그리고 클로저가 변수와 상호작용하는 방식을 상기시켜주는 좋은 예시입니다."}),(0,n.jsx)("div",{children:"스코핑의 동작을 이해하는 것은 반복문이나 비동기 코드를 작성할 때, 버그를 피할 수 있습니다."})]})]})}},1485:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>h});var n=t(5155),i=t(2761),r=t(2139),a=t(2101),o=t(9969),c=t(908),l=t(2626),d=t.n(l);function h(){return(0,n.jsxs)("div",{className:d().container,children:[(0,n.jsx)(i.A,{text:"Content Security Policy, CSP"}),(0,n.jsx)(c.A,{text:"2025.1.31"}),(0,n.jsxs)("section",{className:d().paragraph,children:[(0,n.jsx)(r.A,{text:"브라우저 환경에서 window와 Object.prototype 조작을 방지하는 방법"}),(0,n.jsx)("div",{children:"- chatGpt에게 prototype에 대해 묻다, 문득 브라우저에서 너무 쉽게 prototype 조작이 가능한게 아닌가했다. 대화가 삼천포로 갔지만, 정리해두는게 좋을것 같다."}),(0,n.jsxs)("ul",{className:"list-decimal ml-5 mt-5",children:[(0,n.jsx)("li",{children:"Strict Mode"}),(0,n.jsx)("li",{children:"Object.defineProperty() : use strict와 상충된다."}),(0,n.jsx)("li",{children:"Object.freeze(), Object.seal()"}),(0,n.jsx)("li",{className:"font-bold",children:"CSP(Content Security Policy) 설정: script-src 'self'."}),(0,n.jsx)("li",{children:"React/Vue에서 쓸 수 있는 빠른 훅 - useLayoutEffect()/beforeCreate()"})]})]}),(0,n.jsx)(c.A,{}),(0,n.jsx)(r.A,{text:"1. Strict Mode"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:'단순하다, js 파일 상단에 "use strict"를 추가한다. 효과는 아래와 같다. 1번이 이번 주제 관련이다.'}),(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{className:"font-bold",children:"읽기 전용 속성 변경 방지- 근데, 이러면 Object.defineProperty를 이용해 writable을 false로 바꿀 수 없다."}),(0,n.jsx)("li",{children:"암묵적 전역변수 방지 - x = 10; 과 같이, 대뜸 선언도 없이 쓸 수 없게 된다."}),(0,n.jsxs)("li",{children:["객체의 속성 중복 선언 방지 - ","{namn: 'Jone', name: 'Doe'}"," 이런거 안된다."]}),(0,n.jsx)("li",{children:"this 제한 - this가 undefined 혹은 null일 때 자동으로 글로벌 this(window)를 참조하지 않고 undefined가 된다."}),(0,n.jsx)("li",{children:"delete 제한 강화 - 변수, 함수의 delete 사용이 금지된다."}),(0,n.jsx)("li",{children:"예약어 사용 제한 - implements, interface, let, package, private, protected, public, static, yield 등을 변수나 함수명으로 못쓴다."})]}),(0,n.jsx)(o.A,{addClass:"mt-2",text:"use strict는 조금 느슨하지만 전체적으로 일괄적인 제한을 하는데   유용하고, Object.defineProperty는 특정 속성을 매우 정교하게 제어할 수   있는 차이가 있겠다."})]}),(0,n.jsx)("br",{}),(0,n.jsx)(r.A,{text:"2. Object.defineProperty()"}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:'const config = {};\n\nObject.defineProperty(config, "API_KEY", {\n    value: "1234-5678-ABCD",\n    writable: false,\n    configurable: false\n});\n\nconfig.API_KEY = "HACKED"; // ❌ 변경 불가능\nconsole.log(config.API_KEY); // "1234-5678-ABCD"\n'}),(0,n.jsx)("br",{}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:'const originalAlert = window.alert;\n\nObject.defineProperty(window, "alert", {\n    get: function () {\n        return originalAlert;\n    },\n    set: function () {\n        console.warn("\uD83D\uDEA8 alert 함수 변경이 차단되었습니다!");\n    },\n    configurable: false\n});\n\n'}),(0,n.jsx)("div",{children:"이런 식으로, 특정 프로토타입 값을 변경하지 못하게 만들어 버리는 것. 유저가 핸들링 하는것 보다 먼저 걸어 두어야 하므로, 빠른 훅이 필요하다."}),(0,n.jsx)("br",{}),(0,n.jsx)(r.A,{text:"3. Object.feeze(), Object.seal()"}),(0,n.jsx)("section",{children:(0,n.jsx)("div",{children:"Object.freeze(window)를 하게되면, window 객채의 오버라이드 등 window의 모든 기존 속성을 수정하지 못한다. Object.seal(window)는 기존 속성은 변경 가능하지만, 새로운 속성 추가는 불가능해진다."})}),(0,n.jsx)("br",{}),(0,n.jsx)(r.A,{text:"4. CSP(Content Security Policy) 설정"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"현재 페이지와 동일한 출처(origin)에서 실행되는 스크립트만 허용한다. 상당히 좋다."}),(0,n.jsx)(a.A,{codeType:"language-html",codeBlock:'<!DOCTYPE html>\n<html lang="ko">\n<head>\n    <meta charset="UTF-8">\n    <meta http-equiv="Content-Security-Policy" content="script-src \'self\'">\n    <title>CSP 적용 예제</title>\n</head>\n<body>\n    <script>\n        console.log("✅ 안전한 스크립트 실행!");\n    <\/script>\n    \n    \x3c!-- 외부 스크립트 주입 시도 --\x3e\n    <script src="https://evil-hacker.com/hack.js"><\/script> \n</body>\n</html>\n',initOpen:!1}),(0,n.jsx)("div",{className:"mt-5",children:"하지만, 이러면, CDN으로 jqeury등을 가져와도 실행되지 않는다. 아래와 같이 허용하려는 사이트를 적어서 우회는 가능하다. 복수의 사이트도 적을 수 있다."}),(0,n.jsx)(a.A,{codeType:"language-html",codeBlock:'<meta http-equiv="Content-Security-Policy" content="script-src \'self\' https://code.jquery.com https://www.googletagmanager.com;">'})]}),(0,n.jsxs)("section",{className:"mt-5",children:["nonce(난수) 기반 실행 - 각 페이지 로드 시 난수(nonce) 값을 생성하여 특정 스크립트 허용.",(0,n.jsx)("div",{children:" 1단계. CSP 설정"}),(0,n.jsx)(a.A,{codeType:"language-html",codeBlock:"<meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self' 'nonce-random123'\">\n"}),(0,n.jsx)("div",{children:" 2단계. 실행 스크립트"}),(0,n.jsx)(a.A,{codeType:"language-html",codeBlock:'<script nonce="random123"> alert("이 특정 인라인 스크립트는 허용됨!"); <\/script>'})]}),(0,n.jsxs)("section",{className:"mt-5",children:[(0,n.jsx)("div",{children:"HTTP 응답 헤더를 통해 서버에서 설정할 수도있다."}),(0,n.jsx)(a.A,{codeType:"language-text",codeBlock:"// Apach 서버\n  Header set Content-Security-Policy \"script-src 'self'\"\n  "}),(0,n.jsx)(a.A,{codeType:"language-text",codeBlock:"// Nginx 서버\n  add_header Content-Security-Policy \"script-src 'self'\";"}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:"// Node.js (Express, helmet)\nconst express = require('express');\nconst helmet = require('helmet');\n\nconst app = express();\n\n// Content Security Policy 적용\napp.use(\n    helmet.contentSecurityPolicy({\n        directives: {\n            defaultSrc: [\"'self'\"],\n            scriptSrc: [\"'self'\"]\n        }\n    })\n);\n\napp.get(\"/\", (req, res) => {\n    res.send(\"<script>alert('✅ 안전한 페이지!');<\/script>\");\n});\n\napp.listen(3000, () => {\n    console.log(\"\uD83D\uDE80 서버 실행: http://localhost:3000\");\n});\n  ",initOpen:!1,tail:" - Node.js"})]})]})}},619:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>p});var n=t(5155),i=t(910),r=t.n(i);t(8452);var a=t(2115),o=t(2761),c=t(6529),l=t(6167),d=t(908),h=t(9969),x=t(2626),j=t.n(x);function p(){return(0,a.useEffect)(()=>{r().highlightAll()},[]),(0,n.jsxs)("div",{className:j().container,children:[(0,n.jsx)(o.A,{text:"JavaScript에서 ev.currentTarget과 ev.target의 Event Handling을 이해하기"}),(0,n.jsx)(l.A,{href:"https://jagathishsaravanan.medium.com/understanding-ev-currenttarget-and-ev-target-in-javascript-event-handling-5f6bdc2c0e2a",prefix:"Medium",text:"https://jagathishsaravanan.medium.com/understanding-ev-currenttarget-and-ev-target-in-javascript-event-handling-5f6bdc2c0e2a"}),(0,n.jsx)(d.A,{text:"2025.1.21"}),(0,n.jsx)("section",{children:(0,n.jsx)("div",{children:"이벤트 커런트타겟(ev.currentTarget)과 이벤트 타겟(ev.target)의 차이에 대해 이해해보자."})}),(0,n.jsx)(d.A,{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"ev.currentTarget과 ev.target에 대해 알아보기 전에, 자바스크립트가 이벤트를 어떻게 처리하는지 보자."}),(0,n.jsx)("div",{children:"버튼을 클릭하거나 마우스를 올리거나 등, 이벤트가 발생하면 오브젝트가 생성됩니다."}),(0,n.jsx)("div",{children:"이 오브젝트는 이벤트 정보들을 담고 있습니다. 어떤 엘리먼트에서 발동했는지, 어떤 이벤트였는지 등등의 정보죠."}),(0,n.jsx)("div",{children:"이벤트리스너들은, 특정한 이벤트가 일어났을때 발동하도록 되어있는 함수입니다."}),(0,n.jsx)("div",{children:"아래는 이벤트 리스너의 예입니다."})]}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"document.querySelector('button').addEventListener('click', function(ev) {\n    console.log(ev.target);\n  })"})}),(0,n.jsx)(c.A,{text:"What is ev.target?"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"ev.target property는 이벤트가 트리거된 엘리먼트를 참조합니다."}),(0,n.jsx)("div",{children:"이것은, 이벤트가 시작된 DOM의 가장 구체적인 element를 가리킵니다."}),(0,n.jsx)("div",{children:"정확히 어떤 element와 상호작용했는지를 알고싶을때 특히, 유용합니다."})]}),(0,n.jsx)(h.A,{text:"여기서 '구체적인 element'는 DOM트리의 부모, 자식, 형제 등 여러 엘리먼트 중에 실제 이벤트가 트리거된 엘리먼트를 강조한다 이해했습니다."}),(0,n.jsx)(c.A,{text:"What is ev.currentTarget?"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"한편, ev.currentTarget property는 이벤트 핸들러가 연결된 엘리먼트를 참조합니다."}),(0,n.jsx)("div",{children:"이것은, 어떤 엘리먼트에서 이벤트가 기원 했는지와 상관없이 이벤트 리스너가 연결된 엘리먼트를 가리킵니다."}),(0,n.jsx)("div",{children:"다음을 보시죠."})]}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"document.getElementById('parent').addEventListener('click', function(ev) {\n    console.log('ev.currentTarget:', ev.currentTarget);\n});"})}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"#child 버튼이 클릭되더라도 ev.currentTarget은 #parent div를 참조할겁니다. 왜냐하면, 리스너가 거기에 붙어있기 때문이죠."}),(0,n.jsx)("div",{children:"즉, 아래와 같이 나올겁니다."})]}),(0,n.jsx)("pre",{className:"language-html",children:(0,n.jsx)("code",{children:'ev.currentTarget: <div id="parent">...</div>'})}),(0,n.jsx)(c.A,{text:"Key Differences Between ev.target and ev.currentTarget"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"이벤트의 기원 - ev.target은 실제 이벤트가 시작된 엘리먼트를, ev.currentTarget은 이벤트 핸들러가 연결된 엘리먼트를 가리킵니다."}),(0,n.jsx)("li",{children:"Event Propagation(전파) - 만약 DOM에서 이벤트가 bubbles up(위로 올라감. 버블링.)하면, ev.target은 이벤트가 발생한 원래의 엘리먼트에 남아있습니다. 반면, ev.currentTarget은 엘리먼트의 이벤트 리스너가 실행 되었는지에 따라 달라질 수 있습니다."}),(0,n.jsx)("li",{children:"활용 - ev.target은 이벤트가 발생한 구체적인 엘리먼트를 알고싶을때. ev.currentTarget은 이벤트 리스너가 연결된 엘리먼트를 확인하는게 더 중요할 때."})]})}),(0,n.jsx)(h.A,{text:"Event Propagation - 이벤트 전파, 그러니까 버블링(bubbling)과 캡처링(capturing) 모두를 의미."}),(0,n.jsx)(h.A,{text:"이벤트 단계간 순위 - 1.캡처링, 2.타깃 단계, 3.버블링 순서로 실행됩니다."}),(0,n.jsx)(h.A,{text:"Capturing Phase- 이벤트 루트에서 타겟으로 내려감."}),(0,n.jsx)(h.A,{text:"Target Phase - 타겟 일레먼트에서 실행되는 단계."}),(0,n.jsx)(h.A,{text:"Bubbling Phase- 이벤트가 타겟에서 루트를 향해 올라감."}),(0,n.jsx)(d.A,{text:"잠시 번역을 멈추고, 여기서 저의 의문과 실험입니다."}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"만약, 어떤 엘리먼트의 리스너가 루트와 클릭된 엘리먼트 중간에 있다면 currentTarget은 캡처링과 버블링 이 두번에 걸쳐 실행될 것인가?"}),(0,n.jsx)("pre",{className:"language-html",children:(0,n.jsx)("code",{children:'<div id="root">\n  <div id="middle">\n    <button id="target">Click me</button>\n  </div>\n</div>'})}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:'const root = document.getElementById("root");\nconst middle = document.getElementById("middle");\nconst target = document.getElementById("target");\n\nfunction logEvent(ev) {\n  console.log(\n    `Phase: ${ev.eventPhase}, currentTarget: ${ev.currentTarget.id}, target: ${ev.target.id}`\n  );\n}\nmiddle.addEventListener("click", logEvent, true); // 캡처링 - 3번째 인자를 true로 함.\nmiddle.addEventListener("click", logEvent); // 버블링 - 3번째 인자는 default가 false, 버블링에서 실행함. 항상 써오던게 사실은 버블링만 실행.'})}),(0,n.jsx)("div",{children:"네, meddle 엘리먼트 리스너는 두번 실행 됩니다."}),(0,n.jsx)("div",{children:"실험을 하고보니 멍청한 의문 같습니다."}),(0,n.jsx)("div",{children:"중간 뿐 아니라 타겟도 캡처링과 버블링 두단계에 걸쳐 리스너가 실행 될 수 있습니다."}),(0,n.jsx)("div",{children:"엄밀하게 말하면 두개의 리스너를 붙여놓는 것이지요. 세번째 인자에 true, false 두 종류로요."}),(0,n.jsx)("br",{}),(0,n.jsxs)("div",{children:[(0,n.jsx)("p",{children:"* 여기서 추가 정리."}),(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"stopPropagation - 이벤트 전파를 멈춤. 캡처링에서 멈춘다면 버블링 단계로 넘어가지 않음. 특히, 다른 리스너는 실행됨."}),(0,n.jsx)("li",{children:"stopImmediatePropagation - 완전 멈춤. 같은 엘리먼트에 등록된 다른 리스너도 실행되지 않음."}),(0,n.jsx)("li",{children:"preventDefault - 이벤트 기본동작을 멈춤. 기본동작은 이벤트가 자동 수행되도록 되어있는 동작을 의미. 예로 a태그는 링크로의 이동, button은 폼 전송과 같은 것. 브라우저가 특별히 정의한 기본 동작이 없다면, 아무런 효과가 없음."})]})]}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:'document.addEventListener("contextmenu", (event) => {\n    event.preventDefault(); // 오른쪽 클릭 메뉴 막기\n    console.log("컨텍스트 메뉴를 막았습니다.");\n});'})})]}),(0,n.jsx)(d.A,{text:"나루호도, 다시 본문 번역을 이어갑니다."}),(0,n.jsx)(c.A,{text:"이벤트 핸들링의 위임"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"이벤트 위임은, 부모에게 하나의 이벤트 리스너를 연결해서 여러 자손 엘리먼트의 이벤트를 핸들링하는 일반적인 패턴입니다. 이때, ev.target은 어떤 자손이 트리거 되었는지 알고자 할 때, 유용할 겁니다."}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"document.getElementById('parent').addEventListener('click', function(ev) {\n    if (ev.target.tagName === 'BUTTON') {\n        console.log('Button clicked:', ev.target.id);\n    }\n});"})}),(0,n.jsx)("div",{children:"위에서 우리는 부모에게 이벤트 리스너를 붙였습니다. 클릭 이벤트 리스너가 target element가 button인지 체크합니다. 상황에 따라 이벤트를 핸들링 하면 되겠죠."})]}),(0,n.jsx)(h.A,{text:"이벤트 Delegated(위임)을 하는 이유 - 성능 최적화, 코드 간소화, 동적으로 생성되는 엘리먼트의 처리."})]})}},1811:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>x});var n=t(5155),i=t(910),r=t.n(i);t(8452);var a=t(2115),o=t(2761),c=t(2139),l=t(908),d=t(2626),h=t.n(d);function x(){return(0,a.useEffect)(()=>{r().highlightAll()},[]),(0,n.jsxs)("div",{className:h().container,children:[(0,n.jsx)(o.A,{text:"HTTP/1.1과 HTTP/2의 차이"}),(0,n.jsx)(l.A,{text:"2024.01.26"}),(0,n.jsx)(c.A,{text:"프로토콜 차이:"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"HTTP/1.1 : 요청 - 응답 기반. 하나의 연결에 하나의 요청만 처리."}),(0,n.jsxs)("li",{children:["HTTP/2: 하나의 요청에서 여러 요청을 병렬로 처리. 예, 하나의 연결상태에서 독립적인 스트림을 여러개 만듬. HTML, CSS, JS스트림 등."," "]})]})}),(0,n.jsx)(c.A,{text:"헤더 압축:"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"HTTP/1.1 : 요청마다 헤더 전체를 반복해서 전송."}),(0,n.jsx)("li",{children:"HTTP/2: 이전에 전송한 헤더와 차이점만 전송. 헤더를 압축 전송량 줄임."})]})}),(0,n.jsx)(c.A,{text:"서버 푸시:"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"HTTP/1.1 : 클라이언트가 요청한 자원만 응답."}),(0,n.jsx)("li",{children:"HTTP/2: 클라이언트가 필요로 할 자원을 미리 전송 가능. 예, HTML을 요청하면 관련 CSS와 JS를 푸시할 수 있음. 서버 개발자가 해당 요청에 대해 별도 코딩 필요."})]})}),(0,n.jsx)(c.A,{text:"연결유지:"}),(0,n.jsx)("section",{children:(0,n.jsx)("ul",{className:"list-decimal ml-5",children:(0,n.jsx)("li",{children:"HTTP/2: 1보다 리소스를 절약."})})}),(0,n.jsx)(c.A,{text:"Node.js와 HTTP/2:"}),(0,n.jsx)("section",{children:"http2 모듈을 지원하며, Node.js 18부터는 Fetch API도 기본 내장되어 있음."}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"const http2 = require('http2');\n\nconst server = http2.createServer((req, res) => {\n  res.end('Hello, HTTP/2!');\n});\n\nserver.listen(3000);"})}),(0,n.jsx)(c.A,{text:"Deno와 Bun:"}),(0,n.jsx)("section",{children:"Deno는 Fetch API 기본 지원, Bun은 아직 Fetch 지원하지 않음."}),(0,n.jsx)(c.A,{text:"Node.js HTTP/2 서버푸시 스캐폴딩:"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"const http2 = require('http2');\nconst fs = require('fs');\n\nconst server = http2.createSecureServer({\n  // http2에서는 https가 권장.\n  key: fs.readFileSync('server-key.pem'),\n  cert: fs.readFileSync('server-cert.pem')\n});\n\n// http2에서 클라이어트 요청을 받을 때마다, stream 이벤트가 발생함. 매 요청의 고유 stream.\nserver.on('stream', (stream, headers) => { // stream, headers 객체를 인자로 받음.\n  const path = headers[':path']; // 요청경로. http1.1에서 GET /index.html과 같이 받던 것이 http2에서는 :path에 저장됨. (:method, :path, :scheme, :authority 등)\n\n  // HTML 요청\n  if (path === '/index.html') {\n\n    // 서버 푸시로 CSS 전송\n    stream.pushStream({ ':path': '/style.css' }, (err, pushStream) => {\n      if (!err) {\n        pushStream.respondWithFile('style.css', { 'content-type': 'text/css' });\n      }\n    });\n\n    // 서버 푸시로 JS 전송\n    stream.pushStream({ ':path': '/script.js' }, (err, pushStream) => {\n      if (!err) {\n        pushStream.respondWithFile('script.js', { 'content-type': 'application/javascript' });\n      }\n    });\n\n    // ** 푸시된 리소스(CSS, JS)가 클라이언트의 캐시에 이미 존재하면 네트워크 자원이 낭비될 수 있습니다. **\n\n    // respondWithFile - 클라이언트가 명시적으로 요청한 리소스에 대한 응답.\n    stream.respondWithFile('index.html', { 'content-type': 'text/html' });\n  }\n\n  // CSS 요청 처리\n  else if (path === '/style.css') {\n    stream.respondWithFile('style.css', { 'content-type': 'text/css' });\n  }\n\n  // JS 요청 처리\n  else if (path === '/script.js') {\n    stream.respondWithFile('script.js', { 'content-type': 'application/javascript' });\n  }\n\n  // 기타 요청 처리\n  else {\n    stream.respond({ ':status': 404 });\n  }\n});\n\n// 서버 시작\nserver.listen(3000, () => {\n  console.log('HTTP/2 Server is ready on port 3000.');\n});"})})]})}},7474:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>p});var n=t(5155),i=t(910),r=t.n(i);t(8452);var a=t(2115),o=t(2761),c=t(6529),l=t(2139),d=t(6167),h=t(908),x=t(2626),j=t.n(x);function p(){return(0,a.useEffect)(()=>{r().highlightAll()},[]),(0,n.jsxs)("div",{className:j().container,children:[(0,n.jsx)(o.A,{text:"Debouncing in JavaScript: How to delay a function execution"}),(0,n.jsx)(d.A,{href:"https://codedamn.com/news/javascript/debouncing-in-javascript",prefix:"codedamn",text:"Debouncing in JavaScript: How to delay a function execution"}),(0,n.jsx)(h.A,{text:"2024.12.31"}),(0,n.jsxs)("section",{className:j().paragraph,children:[(0,n.jsxs)("div",{children:["원문을 읽고 요약한 글입니다."," ",(0,n.jsx)("strong",{children:"번역, 주석 등에 오류가 있을 확률은 57,328%"})," 입니다."]}),(0,n.jsx)("div",{children:"디바운싱(Debouncing)은 이벤트가 짧은 간격으로 여러 번 실행되지 않도록 일정 시간 후에 실행되도록 하고, 브라우저나 서버의 부하를 줄이려는 의도로 사용. 주로 검색창."}),(0,n.jsx)("div",{children:"반면, 스로틀링(Throttling)은 일정시간 간격으로 일어나게 하여, 스크롤에 적합함."})]}),(0,n.jsx)(h.A,{}),(0,n.jsx)(c.A,{text:"JavaScript에서 디바운싱(Debouncing)이란 무엇인가?"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"웹사이트에서 버튼을 클릭했을때 콘텐츠가 조금 느리게 로딩된다고 느낀 적이 있나요?"}),(0,n.jsx)("div",{children:"검색 필드에 입력한 후 결과가 표시되기까지 약간의 지연이 있을 때는요?"}),(0,n.jsx)("div",{children:"개발자들은, 디바운스를 사용하여 이런 딜레이를 만들고 서버에 불필요한 요청을 보내지 않도록 합니다."})]}),(0,n.jsx)(c.A,{text:"디바운싱(Debouncing)은 어떻게 동작하나?"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"디바운싱은 코드를 실행하기 전에 지연 타이머를 시작합니다."}),(0,n.jsx)("div",{children:"어떤 이유로 동작이 반복되면, 큐에 두번째 이벤트를 쌓는 대신 이전 프로세스를 중단시키고 현재 이벤트에만 집중하게 합니다."})]}),(0,n.jsx)(c.A,{text:"JavaScript 디바운싱(Debouncing) 함수"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"function debounce(callback, timer) {\n  let timeoutId;\n\n  return (...args) => {\n    // save the current context (this)\n    const context = this;\n\n    // clear the existing timeout\n    clearTimeout(timeoutId);\n\n    // create a new timeout\n    timeoutId = setTimeout(() => {\n      callback.apply(context, args);\n    }, timer);\n  };\n}\n"})}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"다음과 같이 동작합니다."}),(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"기존 타이머 초기화"}),(0,n.jsx)("li",{children:"새 타이머 설정"}),(0,n.jsx)("li",{children:"apply()를 통해 콜백 실행. 해당 함수의 매개변수(args)와 컨텍스트(this)를 전달 합니다."})]}),(0,n.jsx)("div",{children:"타이머는 생성된 특정 타임아웃에 대한 참조 ID를 반환합니다."}),(0,n.jsx)("div",{children:"이 아이디를 통해 기존 타임아웃을 취소시킵니다."}),(0,n.jsx)("div",{children:"타이머 스케쥴링과 취소의 비용은 매우 적은 편이기 때문에 비용에 대해 크게 걱정하지 않아도 됩니다."})]}),(0,n.jsx)(c.A,{text:"사용례"}),(0,n.jsx)(l.A,{text:"검색창"}),(0,n.jsx)("pre",{className:"language-html",children:(0,n.jsx)("code",{children:'<input type="text" id="input">'})}),(0,n.jsx)("br",{}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"const input = document.getElementById('input');\n\ninput.addEventListener('input', callAPI);\n\nfunction callAPI() {\n    // Time consuming API call\n    console.log('API called!');\n}\n"})}),(0,n.jsx)("section",{children:(0,n.jsx)("div",{children:"위 코드는 API called가 입력이 들어올 때마다 계속 발생합니다. 반면 아래는 다릅니다."})}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"const debouncedCallAPI = debounce(callAPI, 500);\n\ninput.addEventListener('input', debouncedCallAPI);\n"})}),(0,n.jsx)(l.A,{text:"마우스 이벤트"}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"window.addEventListener('mousemove', mouseMove);\n\nfunction mouseMove(e) {\n    let x = e.clientX;\n    let y = e.clientY;\n    console.log('Mouse moved to: ', x, y);\n}\n"})}),(0,n.jsx)("br",{}),(0,n.jsx)("pre",{className:"language-javascript",children:(0,n.jsx)("code",{children:"const debouncedMouseMove = debounce(mouseMove, 500);\n\nwindow.addEventListener('mousemove', debouncedMouseMove);\n"})}),(0,n.jsx)("br",{}),(0,n.jsx)("section",{children:(0,n.jsx)("div",{children:"마찬가지로 디바운스를 사용하면 더 효율적입니다."})})]})}},5735:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>m});var n=t(5155),i=t(910),r=t.n(i);t(8452);var a=t(2115),o=t(2761),c=t(6529);t(2139);var l=t(6167),d=t(908),h=t(8173),x=t.n(h),j=t(2626),p=t.n(j);function m(){return(0,a.useEffect)(()=>{r().highlightAll()},[]),(0,n.jsxs)("div",{className:p().container,children:[(0,n.jsx)(o.A,{text:"2024 JavaScript Rising Stars"}),(0,n.jsx)(l.A,{href:"https://risingstars.js.org/2024/en#section-framework",prefix:"risingstars",text:"https://risingstars.js.org/2024/en#section-framework"}),(0,n.jsx)(d.A,{text:"2025.1.13"}),(0,n.jsx)("section",{className:p().paragraph,children:"상기 링크가 그래프로 표시되어 있어 훨씬 보기 좋습니다."}),(0,n.jsx)(d.A,{}),(0,n.jsx)(c.A,{text:"Front-end Frameworks"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsxs)("li",{children:["htmx +16.8k :",(0,n.jsx)(x(),{href:"https://htmx.org/essays/is-htmx-another-javascript-framework/",className:"text-blue-600 hover:underline",children:"https://htmx.org/essays/is-htmx-another-javascript-framework/"})]}),(0,n.jsx)("li",{children:"React +14.2k"}),(0,n.jsx)("li",{children:"Svelte +6.1k"}),(0,n.jsx)("li",{children:"Vue +5.9k"}),(0,n.jsx)("li",{children:"Angular +3.5k"})]})}),(0,n.jsx)(c.A,{text:"React Ecosystem"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsxs)("li",{children:["shadcn/ui +38.0k :",(0,n.jsx)(x(),{href:"https://ui.shadcn.com/",className:"text-blue-600 hover:underline",children:"https://ui.shadcn.com/"})]}),(0,n.jsx)("li",{children:"Excalidraw +27.0k"}),(0,n.jsx)("li",{children:"Magic UI +13.2k"}),(0,n.jsx)("li",{children:"Next.js +12.1k"}),(0,n.jsx)("li",{children:"Refine +11.7k"})]})}),(0,n.jsx)(c.A,{text:"Vue Ecosystem"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"Nuxt +6.2k"}),(0,n.jsx)("li",{children:"PrimeVue +5.4k"}),(0,n.jsx)("li",{children:"Slidev +4.7k"}),(0,n.jsx)("li",{children:"shadcn-vue +4.1k"}),(0,n.jsx)("li",{children:"VitePress +3.7k"})]})}),(0,n.jsx)(c.A,{text:"Back-end/Full-stack"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"Next.js +12.1k"}),(0,n.jsx)("li",{children:"Hono +11.5k"}),(0,n.jsx)("li",{children:"Astro +9.8k"}),(0,n.jsx)("li",{children:"Nest +6.8k"}),(0,n.jsx)("li",{children:"Strapi +6.3k"})]})}),(0,n.jsx)(c.A,{text:"Styling / CSS in JS"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"Tailwind CSS +9.4k"}),(0,n.jsx)("li",{children:"DaisyUI +6.6k"}),(0,n.jsx)("li",{children:"Bootstrap +4.8k"}),(0,n.jsx)("li",{children:"Pico.css +3.1k"}),(0,n.jsx)("li",{children:"Tamagui +3.0k"})]})}),(0,n.jsx)(c.A,{text:"Component Libraries"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsx)("li",{children:"shadcn/ui +38.0k"}),(0,n.jsx)("li",{children:"Magic UI +13.2k"}),(0,n.jsx)("li",{children:"PrimeVue +5.4k"}),(0,n.jsx)("li",{children:"NextUI +4.9k"}),(0,n.jsx)("li",{children:"Mantine +4.5k"})]})}),(0,n.jsx)(c.A,{text:"Testing"}),(0,n.jsx)("section",{children:(0,n.jsxs)("ul",{className:"list-decimal ml-5",children:[(0,n.jsxs)("li",{children:["Playwright +10.4k :",(0,n.jsx)(x(),{href:"https://playwright.dev/",className:"text-blue-600 hover:underline",children:"https://playwright.dev/"})]}),(0,n.jsx)("li",{children:"Puppeteer +3.8k"}),(0,n.jsx)("li",{children:"Storybook +3.7k"}),(0,n.jsx)("li",{children:"Micro Agent +3.1k"}),(0,n.jsx)("li",{children:"Stagehand +2.8k"})]})})]})}},382:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>x});var n=t(5155),i=t(2761),r=t(2139),a=t(2101),o=t(9969),c=t(908),l=t(2626),d=t.n(l),h=t(6167);function x(){return(0,n.jsxs)("div",{className:d().container,children:[(0,n.jsx)(i.A,{text:"The JS Bifrost — JavaScript의 상속 — Prototype 과 class 상속"}),(0,n.jsx)(h.A,{href:"https://medium.com/globant/the-js-bifrost-inheritance-in-js-prototype-and-class-inheritance-84ec4c60b1a2",prefix:"Medium",text:"https://medium.com/globant/the-js-bifrost-inheritance-in-js-prototype-and-class-inheritance-84ec4c60b1a2"}),(0,n.jsx)(c.A,{text:"2025.2.7"}),(0,n.jsx)("section",{className:d().paragraph,children:"번역에 오류가 있을 겁니다. 개인적으로 이해한 부분을 추가 하였는데, 이 역시 잘못된 부분이 있을 수 있습니다."}),(0,n.jsx)(c.A,{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"Welcome to The JS Bifrost, your pathway to a rock-solid foundation for God-level JavaScript. This is the next article in the series, which talks about Inheritance in JavaScript."}),(0,n.jsx)("div",{children:"갓 레벨 자바스크립트를 향한 단단한 길, JS 비프로스트에 온 걸 환영합니다. 이 글은 시리즈의 다음글 입니다, 자바스크립트의 상속에 대해 이야기하겠습니다."}),(0,n.jsx)(o.A,{text:'Inheritance - 라틴어 "hereditare" (상속받다)에서 유래했고, 이는 "heres" (상속인, 상속자)에서 파생된 단어.\n          "in-" (안으로) + "herit" (상속) + "-ance" (명사형) → "물려받음"\n          프로그래밍에서는 부모의 속성과 메소드를 물려받지만, 사실상 기존 객체의 기능을 확장하면서 계승/발전하는 의미도 있음.\n          '})]}),(0,n.jsxs)("section",{className:"mt-2",children:[(0,n.jsx)("div",{children:"Unlike all other object-oriented programming languages, JavaScript chose prototypes for its way of handling inheritance, but with the release of ES2015, classes were introduced to the language’s syntax."}),(0,n.jsx)("div",{children:"OOP 언어들과 달리, JavaScript는 프로토타입을 상속을 위한 도구로 선택했습니다, 하지만 ES2015에서, class가 문법으로 추가되었습니다."})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{className:"mt-2",children:[(0,n.jsx)("div",{children:"Let me put light on thought:"}),(0,n.jsx)("div",{children:"한번 생각해보죠 :"})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{className:"font-bold",children:[(0,n.jsx)("div",{children:"Classes are just syntactic sugar, JavaScript remains prototype based."}),(0,n.jsx)("div",{children:"Class는 그냥 문법적 설탕(편의적 기능)일 뿐, JavaScript는 여전히 프로토타입에 기반하고 있습니다."}),(0,n.jsx)("div",{children:"They are not a new object-oriented inheritance model."}),(0,n.jsx)("div",{children:"이 Class(JavaScript가 도입한 클래스)는 새로운 객체지향적 상속 모델이 아닙니다."})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{className:"mt-2",children:[(0,n.jsx)("div",{children:"Let’s understand the Prototype first !!!!"}),(0,n.jsx)("div",{children:"프로토타입을 이해해 봅시다!!!!"})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"In general, a prototype is nothing but a first or preliminary version of a device or vehicle from which other forms are developed. In Javascript also, it follows the prototype mechanism to inherit properties and methods."}),(0,n.jsx)("div",{children:"일반적으로, 프로토타입이란 최초 혹은 이미 개발된 장비나 장치에서 비롯된 예비 버전 같은 겁니다. JavaScript에서도, 속성과 메소드를 상속하기 위해서 프로토타입의 메카니즘을 따라 했습니다."})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:["All objects in Javascript have a ",(0,n.jsx)("strong",{children:"prototype property, "})]}),(0,n.jsx)("div",{className:"mb-2",children:"Javascript에서 모든 객체는 프로토타입 속성을 가집니다."}),(0,n.jsx)("div",{children:"which acts as a model that inherits methods and properties from another object."}),(0,n.jsx)("div",{className:"mb-2",children:"오브젝트 속 프로토타입 속성은 다른 오브젝트의 메소드와 속성을 상속한 모델 역할을 합니다."}),(0,n.jsx)("div",{children:"It’s an object that stands on its own and we could use it by itself if we wanted to."}),(0,n.jsx)("div",{className:"mb-2",children:"프로토타입은 독립적이며 우리가 원한다면 그대로 사용 할 수도 있습니다."}),(0,n.jsxs)("div",{children:["The object property that we called",(0,n.jsx)("strong",{children:" proto "}),"that’s its prototype."]}),(0,n.jsxs)("div",{className:"mb-2",children:["객체(object)에서 우리가 proto라고 부르는 속성이 바로 그 객체의 프로토타입입니다.",(0,n.jsx)("br",{}),"(proto가 prototype 자체는 아니고 참조임. 아래에 이어짐.)"]}),(0,n.jsx)("div",{children:"That’s the object that is going to grab and will be able to get its properties and methods as well."}),(0,n.jsx)("div",{children:"이 속성(__proto__)을 통해 객체는 속성과 메소드들을 가져오고 또 사용할 수 있습니다."})]}),(0,n.jsx)(c.A,{text:"번역을 잠시 멈추고 개인적으로 정리해 봅니다. 엄밀히 말하면, 원문이 조금 이상하게 이야기를 한 것 같습니다."}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"일반 객체에는 prototype 속성이 없습니다."}),(0,n.jsx)("div",{className:"mb-2",children:"함수를 만들면 prototype 속성이 존재함."}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:"var Foo = {}\nconsole.dir(Foo);\nconsole.dir(Foo.__proto__)\n\nfunction Bar() {}\nconsole.dir(Bar);\n"}),(0,n.jsxs)("div",{children:["객체는 생성될 때, JavaScript가 글로벌 Object의 prototype속성",(0,n.jsx)("strong",{children:" Object.prototype"}),"을 프로토타입으로써 참조하도록 하고, 객체용 새 그릇(저장공간)을 만듭니다. 앞서 말했듯 .prototype 속성은 객체에는 있지도 않고, 함수에만 있습니다."]}),(0,n.jsx)("div",{className:"mt-5 font-bold",children:"말하고자 하는, 프로토타입은 다른 객체가 참조하고 있는 실체를 의미합니다."}),(0,n.jsx)("div",{className:"mb-5 font-bold",children:"이제부터는 참조되어야 할 실체적 객체를 [[Prototype]]이라고 하겠습니다."}),(0,n.jsxs)("div",{children:["만일 어떤 객체를 최초로 만든다면, JavaScript는",(0,n.jsx)("strong",{children:" Object.prototype"}),"을 [[Prototype]]으로써 참조할 수 있게 하고, 새 객체를 위한 공간을 만듭니다."]}),(0,n.jsxs)("div",{className:"mb-2",children:["JavaScript에서 글로벌 Object는 함수(생성자함수)입니다. 앞서 말했듯, 함수이므로 ",(0,n.jsx)("strong",{children:".prototype "}),"속성을 가지고 있습니다."]}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:"console.dir(Object); // JavaScript Object는 함수 입니다."}),(0,n.jsxs)("div",{children:[(0,n.jsx)("div",{children:"Foo.name을 하게되면,"}),(0,n.jsxs)("ul",{className:"list-decimal ml-10 mb-2",children:[(0,n.jsx)("li",{children:"Foo라는 그릇에서 찾고"}),(0,n.jsxs)("li",{children:["Foo의 [[Prototype]]에서 찾습니다. 여기서는 함수인 Object의 속성, Object.prototype입니다.",(0,n.jsx)("strong",{children:"(**생성자 함수 Object의 [[Prototype]]은 Function.prototype이며 이 함수의 속성인 Object.prototype과 다릅니다.**)"})]}),(0,n.jsx)("li",{children:"Object.prototype에서 찾습니다. 찾지 못하면,"}),(0,n.jsx)("li",{children:"Object.prototype의 [[Prototype]]에서 찾습니다. 이건 null 입니다."})]}),(0,n.jsx)("div",{className:"mb-2",children:"객체를 상속하여 새 객체를 만들어도 기본적으로 흐름은 같습니다."}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:'const parent = { name: "parent" };\nconst child = Object.create(parent);\n\nconsole.log(child.name);  // "parent" (프로토타입에서 상속됨)\nconsole.log(child.__proto__ === parent);  // true',tail:" - 객체의 상속. Extends 따위 필요 없습니다."})]}),(0,n.jsx)("div",{children:"여기서, __proto__를 짚고가 봅니다."}),(0,n.jsx)("div",{className:"font-bold",children:"Foo.__proto__를 호출하면 __proto__속성을 찾기위해 프로토타입체인이 일어날 것 같지만,"}),(0,n.jsx)("div",{children:"Foo 객체의 [[Prototype]]인 Object.prototype을 직접 반환합니다."}),(0,n.jsx)("div",{className:"mb-2",children:"Object.prototype객체에 있는 __proto__를 만나서, 그 값인 null을 반환하지 않습니다."}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:"var Foo = {}\nconsole.dir(Object.prototype)\nconsole.dir(Foo);\nconsole.log(Foo.__proto__);  // ✅ Object.prototype\nconsole.log(Object.getPrototypeOf(Foo));  // ✅ Object.prototype\n",tail:"- __proto__를 찾아서."}),(0,n.jsxs)("div",{children:[(0,n.jsx)("strong",{children:"Foo는 일반 객체"}),"를 만든 것이고, 객체를 만들때 글로벌 생성자",(0,n.jsx)("strong",{children:' "함수"인 "Object"'}),"의",(0,n.jsx)("strong",{children:" Object.prototype을 [[Prototype]]"}),"으로 했을 겁니다."]}),(0,n.jsx)("div",{children:"그리고 프로토타입체인은 자기 그릇에서 찾지 못하면 참조중인 [[Prototype]]을 찾아서 계속 이동하겠죠."}),(0,n.jsx)("br",{}),(0,n.jsxs)("div",{children:["그러니 Foo.__proto__도",(0,n.jsx)("strong",{children:" 이 메커니즘을 따른다면,"}),(0,n.jsx)("br",{}),"1. Foo에서 못찾음",(0,n.jsx)("br",{}),"2. [[Prototype]]인 Object.prototype에서 __proto__를 만나",(0,n.jsx)("strong",{children:" null을 줘야 할 것 같지만 "}),(0,n.jsx)("br",{}),"__proto__는 JavaScript가 [[Prototype]]을 주기로 한 약속으로써 Foo의 [[Prototype]]인 Object.prototype 객체를 줘버립니다."]}),(0,n.jsxs)("div",{className:"font-bold mt-5 mb-5",children:[(0,n.jsx)("div",{children:"단순하게 얘기해서, __proto__는 JavaScript엔진이 직접 제공하는 기능으로,"}),(0,n.jsx)("div",{children:"JavaScript가 객체의 [[Prototype]]을 반환하도록 되어있는 접근자(getter/setter) 입니다."})]}),(0,n.jsxs)("div",{children:[(0,n.jsx)("div",{className:"mb-5",children:"젠장, 그럼 Object.prototype.__proto__는 왜 있는 걸까요?"}),(0,n.jsx)("div",{children:"__proto__는 JavaScript 초창기 비표준 기능입니다."}),(0,n.jsx)("div",{children:"이것은 레거시코드 호환을 위해 존치되었고, 지금은 [[Prototype]]을 반환하는 동작을 하도록 되어있습니다."}),(0,n.jsx)("div",{children:"ECMAScript 표준화 과정에서 기존의 __proto__를 대신하여 [[Prototype]] 개념을 도입했고,"}),(0,n.jsx)("div",{children:"기존 코드와의 호환성을 유지하기 위해 __proto__를 남겨두었으나 결국 [[Prototype]]을 참조하는 형태입니다."}),(0,n.jsx)("div",{className:"mb-2",children:"최신 코드에서는 __proto__ 대신 Object.getPrototypeOf()를 사용하는 것이 권장됩니다."}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:"const obj = {};\nconsole.log(Object.getPrototypeOf(obj));  // Object.prototype\nconsole.log(obj.__proto__);  // 같은 값이지만 레거시 기능\n"})]})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{alt:"함수 [[ProtoType]]",children:[(0,n.jsx)("div",{children:"이제 함수입니다."}),(0,n.jsx)("div",{children:"앞서, 글로벌 Object는 함수였습니다."}),(0,n.jsx)("div",{children:"함수는 생성될 때, JavaScript가 [[Prototype]]으로 Function.prototype을 참조하게 하고 새 함수의 그릇을 만듭니다."}),(0,n.jsx)("div",{className:"mb-2",children:"그리고 Function.Prototype 객체는 [[Prototype]]으로 Object.prototype을 참조하고 있습니다."}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:"function Bar() {}\nconsole.dir(Bar);\nconsole.dir(Bar.name);"}),(0,n.jsx)("div",{children:"위와 같이, 함수인 Bar의 name을 찾게 되면,"}),(0,n.jsxs)("ul",{className:"list-decimal ml-10 mb-2",children:[(0,n.jsx)("li",{children:"Bar라는 그릇에서 name을 찾습니다."}),(0,n.jsxs)("li",{children:["Bar의 [[Prototype]]인",(0,n.jsx)("strong",{children:" Function.prototype"}),"에서 찾습니다."]}),(0,n.jsxs)("li",{children:["Function.prototype의 [[Prototype]]인 글로벌 Object의",(0,n.jsx)("strong",{children:" Object.prototype"}),"에서 찾습니다."]}),(0,n.jsxs)("li",{children:["생성자함수 Object.prototype의",(0,n.jsx)("strong",{children:" [[Prototype]]"}),"에서 찾습니다. null 입니다."]})]}),(0,n.jsxs)("div",{children:[(0,n.jsx)("div",{className:"font-bold",children:"최초 언급했듯 함수에는 prototype 속성이 있습니다."}),(0,n.jsxs)("div",{children:["** Bar.prototype.name을 하게되면, 함수가 생성되면서 만들어진",(0,n.jsx)("strong",{className:"pl-2",children:"Bar의 prototype 속성이 가리키는 객체에 name이 추가될 것입니다."})]}),(0,n.jsx)("div",{className:"font-bold mt-5 mb-5",children:"이것은, Function.prototype과 구별되어야 합니다."}),(0,n.jsx)("div",{className:"",children:"반면 객체인 Foo에 Foo.prototype.name을 한다면,"}),(0,n.jsx)("div",{children:"Foo 자체에 prototype이라는 속성이 없고 프로토타입체인으로 [[Prototype]]을 따라가 보아도 Object.prototype 내부에도 .prototype이 없기 때문에 오류가 날겁니다."})]})]}),(0,n.jsx)(c.A,{text:"다시 번역으로 돌아갑니다."}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"Here, we have an object as obj and it has a property called prop1. We can access this property by simply writing obj.prop1. As we know every object has a property called prototype(__proto__)is also an object. Say we have another property associated with proto as prop2. To access this property we don’t have to write obj.__proto__.prop2, we can simply say obj.prop2, and the JavaScript engine does the work of searching the prototype chain for those properties. Similarly for obj.prop3. This mechanism is nothing but the prototype chain."}),(0,n.jsx)("div",{className:"mt-2 mb-2",children:"객체 obj에 속성으로 prop1이 있습니다. 우리는 그냥 obj.prop1을 하면 접근이 됩니다. 모든 객체는 __proto__라고 불리는 속성을 가지며, 이 역시 객체입니다. __proto__에 prop2라는 다른 속성이 추가되어 있다고 해 봅시다. 이 속성에 접근하려고 obj.__proto__.prop2처럼 쓸 필요가 없습니다. 그냥 obj.prop2 하면 되죠. 자바스크립트 엔진은 프로토타입 체인을 통해 그렇게 동작합니다. obj.prop3도 마찬가지이며, 이 메커니즘을 프로토타입체인이라고 합니다."}),(0,n.jsx)(o.A,{text:"원문에는 여기서 이쁜 그림도 있습니다. 원하시면 상단의 링크를 따라가시면 됩니다."})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"When we call the property or method of an object, the browser checks to see if the actual object has the method on it, if not it checks if the method is available to it through its prototype object."}),(0,n.jsx)("div",{className:"mt-2",children:"객체의 속성이나 메소드를 호출 할 때, 브라우저는 해당 객체를 그것들을 가지고 있는지 확인합니다. 없으면 프로토타입 객체에서 할 수 있는지 체크합니다."})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{className:"mb-2",children:[(0,n.jsx)("div",{children:"If the method’s not defined on the prototype object, the browser checks up another level to see if the current prototype object has the method available on its prototype object. The browser will do this all the way up until it reaches the object at the top with null as its prototype."}),(0,n.jsx)("div",{className:"mt-2",children:"프로토타입에도 없다면, 브라우저는 한 단계 위의 프로토타입에 찾아갑니다. 브라우저는 최상위 레벨의 프로토타입까지 찾아가 null을 발견할때 까지 갈겁니다."})]}),(0,n.jsx)("br",{}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:"function Car(brandName, topSpeed, color) {\n  this.brandName = brandName,\n  this.topSpeed = topSpeed,\n  this.color = color\n}\n\nconst sportsCar = new Car('BMW', 330, 'black');\nCar.prototype.gearType = 'automatic';\nsportsCar.brandName\nsportsCar.color\nsportsCar.gearType\nsportsCar.hasOwnProperty('gearType') // false\nCar.hasOwnProperty('gearType') // false\nCar.prototype.hasOwnProperty('gearType') // true\n  "}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"In the above example, we have created a constructor called Car, which defines a brand new car."}),(0,n.jsx)("div",{className:"mt-2",children:"샘플을 보면, Car라는 생성자를 만들고 새 차를 생성 했습니다."})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"We create sportsCar and provide properties of brandName, topSpeed, and color. Then we added a property called gearType to the Car prototype object and assigned the value ‘automatic’ to it."}),(0,n.jsx)("div",{className:"mt-2",children:"sportsCar 객체를 만들고 brandName, topSpeed, and color 속성을 설정했습니다. 그 후, Car.prototype 에 gearType이라는 속성을 추가하고 value로 'automatic'을 할당 했습니다."})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:["When we call any defined object property, ",(0,n.jsx)("br",{}),"it will give you the value because it is available in the object itself, ",(0,n.jsx)("br",{}),"and when we call gearType it will also give you the value but, ",(0,n.jsx)("br",{}),"the only difference is it is available in the objects constructor prototype."]}),(0,n.jsxs)("div",{className:"mt-2",children:["객체의 속성을 호출하면, ",(0,n.jsx)("br",{}),"객체 자체에 값이 존재하면 줍니다. ",(0,n.jsx)("br",{}),"그리고 gearType을 호출하면 또한 값을 줍니다 하지만, ",(0,n.jsx)("br",{}),"다른점은 객체의 생성자 prototype에 있었다는 겁니다."]})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:["But if we check if either sportsCar. ",(0,n.jsx)("br",{}),"hasOwnProperty(‘gearType’) and Car.hasOwnProperty(‘gearType’) of ‘gearType’ and both return false, ",(0,n.jsx)("br",{}),"but Car.prototype.hasOwnProperty(‘gearType’) return true. ",(0,n.jsx)("br",{}),"That is a Javascript prototype-based inheritance."]}),(0,n.jsxs)("div",{className:"mt-2",children:["스포츠카를 확인하면, ",(0,n.jsx)("br",{}),"hasOwnProperty(‘gearType’)나 Car.hasOwnProperty(‘gearType’)에는 gearType 속성이 없습니다. ",(0,n.jsx)("br",{}),"대신 Car.prototype에 있습니다. ",(0,n.jsx)("br",{}),"이게 Javascript의 prototype 기반 상속입니다."]})]}),(0,n.jsx)("div",{className:"text-center font-bold m-5",children:"*\xa0\xa0\xa0 *\xa0\xa0\xa0 *"}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:"Now let’s get on with ES6 class."}),(0,n.jsx)("div",{className:"mt-2",children:"ES6 class를 보죠."})]}),(0,n.jsxs)("section",{children:[(0,n.jsx)(r.A,{text:"Class Inheritance"}),(0,n.jsx)("div",{className:"",children:"클래스 상속"})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:["A class is like a classification of the object to be created and in classical inheritance, ",(0,n.jsx)("br",{})," methods from the base class get copied into the derived class."]}),(0,n.jsxs)("div",{className:"mt-2",children:["클래스는 생성될 객체의 하나의 분류(설계도)와 같으며, 전통적인 상속"," ","방식에서는,",(0,n.jsx)("br",{}),"기본 클래스의 메서드가 파생 클래스로 복사됩니다."]})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:["In class inheritance, ",(0,n.jsx)("br",{}),"it creates sub-class relationships by inheriting objects or methods from base class to derived class. ",(0,n.jsx)("br",{}),"The way we use the instance in Javascript, ",(0,n.jsx)("br",{}),"you can’t similarly make use of classes. ",(0,n.jsx)("br",{}),"To invoke methods, ",(0,n.jsx)("br",{}),"you must first instantiate an object of the class and then invoke."]}),(0,n.jsxs)("div",{className:"mt-2",children:["(전형적인) 클래스의 상속은, ",(0,n.jsx)("br",{}),"기본 클래스에서 파생 클래스로 객체와 메서드를 상속함으로써 서브 클래스 관계를 형성합니다. ",(0,n.jsx)("br",{}),"자바스크립트에서 구현체를 사용하는 방식은, ",(0,n.jsx)("br",{}),"클래스를 만드는것과 다릅니다. ",(0,n.jsx)("br",{}),"메소드를 호출하면, ",(0,n.jsx)("br",{}),"먼저 클래스의 구현체를 생성하고, 그 instantiate에서 호출 되어야 합니다.."]})]}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:["Let’s understand it through example… ",(0,n.jsx)("br",{}),"Consider we have a class User as defined below"]}),(0,n.jsx)("div",{className:"mt-2",children:"예제를 보겠습니다. class User를 정의합니다."})]}),(0,n.jsx)("br",{}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:"class User {\n  constructor(name) {\n    this.username = name;\n  }\n\n  register() {\n    console.log(this.username)\n  }\n}\n\nlet john = new User('John');\njohn.register();\n  "}),(0,n.jsx)("br",{}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{className:"font-bold",children:"Note: Since ES6, Class inheritance may or may not use the class keyword. Constructor functions are used, instead."}),(0,n.jsx)("div",{className:"mt-2",children:"노트: ES6이후, 클래스 상속시 class 키워드를 써도 되고 안써도 됩니다. 대신, 생성자 함수가 사용됩니다."}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"…and we would like to create another class as Member based on User class:"}),(0,n.jsx)("div",{className:"mt-2",children:"그리고 다른 클래스 Member를 User를 기본으로 해서 만들어 보겠습니다."}),(0,n.jsx)("br",{}),(0,n.jsx)(a.A,{codeType:"language-javascript",codeBlock:"class Member extends User {\n  constructor(name, email) {\n    super(name);\n    this.email = email;\n  }\n\n  getEmail() {\n    console.log(this.email)\n  }\n}\n\nlet anny = new Member('Anny', 'anny@gmail.com');\nanny.register();\nanny.getEmail();"}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"So, here in the above example, anny objects can have access to both User methods and Member methods."}),(0,n.jsx)("div",{className:"mt-2",children:"anny 객체는 User의 메소드와 Member의 method 모두에 접근이 됩니다."}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"Let’s understand how this works, internally extends keyword works using the prototype mechanism."}),(0,n.jsx)("div",{className:"mt-2",children:"이제, 그걸 이해해 보죠. extends 키워드는 내부적으로 프로토타입 메카니즘을 사용합니다."}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{className:"font-bold",children:"class Child extends Parent this will get converted into the prototype object i.e. Child.prototype.__proto__ will be Parent.prototype"}),(0,n.jsx)("div",{className:"mt-2 mb-2",children:"Child가 Parent를 extends하면, 프로토타입 객체로 변환 됩니다. 즉, Child.prototype.__proto__ 가 Parent.prototype를 가리킵니다."}),(0,n.jsx)(o.A,{text:"Child.prototype이 있다는건 함수라는 의미가 됩니다.\n글쓴이가 말하는 Child.prototype.__proto__ 에서,\n__proto__는 레거시 형식이지만 어쨓건 Child 함수가 가진 prototype 속성의 [[Prototype]]을 의미할 겁니다.\n원래는 Object.prototype가 되어야 하지만, Parent.prototype을 참조하도록 대체한다는 의미가 되겠네요.\n          "}),(0,n.jsx)("br",{}),(0,n.jsxs)("div",{children:["In our case: Member.prototype.__proto__ = User.prototype ",(0,n.jsx)("br",{}),"So if the method is not found in Member class, Javascript takes it from the User class. ",(0,n.jsx)("br",{}),"This is the basic idea of how class inheritance works on top of prototypal inheritance."]}),(0,n.jsxs)("div",{className:"mb-2",children:["이번 경우: Member.prototype.__proto__ = User.prototype ",(0,n.jsx)("br",{}),"따라서 Member의 클래스에 메소드를 찾지 못하면, 자바스크립트는 User 클래스를 찾습니다. ",(0,n.jsx)("br",{}),"이것이, 프로토타입 상속에 기반한 클래스 상속이 동작하는 기본 원리입니다."]}),(0,n.jsx)(o.A,{text:"메소드를 찾지 못하면,\nMember.prototype이 참조하고 있는 [[Prototype]]을 뒤져보려 할텐데, 애초에 Object.prototype이어야 할 것을,\nUser.prototype으로 되어있을테니 거기로 갔다는 거죠."}),(0,n.jsx)("br",{}),(0,n.jsx)("div",{children:"Well done for making it to the end of this article…!!!"}),(0,n.jsx)("div",{children:"수고하셨습니다."}),(0,n.jsx)("br",{})]}),(0,n.jsxs)("section",{children:[(0,n.jsx)(r.A,{text:"Conclusion"}),(0,n.jsx)("div",{children:"꽁꿀루숑"}),(0,n.jsx)("br",{}),(0,n.jsxs)("div",{children:["Classes from other languages like Java that don’t technically exist in Javascript but Classes are just syntactic sugar. ",(0,n.jsx)("br",{}),"It follows a prototype mechanism to achieve inheritance."]}),(0,n.jsxs)("div",{className:"mt-2",children:["Java 같은 다른 언어의 Class는 JavaScript에 기술적으로 존재하지 않습니다. ",(0,n.jsx)("br",{}),"JavaScript에서 Class는 단지 문법적 편의일 뿐입니다. ",(0,n.jsx)("br",{}),"JavaScript는 상속을 프로토타입 메카니즘을 통해 구현합니다."]}),(0,n.jsx)("br",{}),(0,n.jsxs)("div",{children:["Whether or not you agree with the inclusion of classes to the JS language, ",(0,n.jsx)("br",{}),"Prototypal Inheritance stands on its own as an elegant inheritance mechanism. ",(0,n.jsx)("br",{}),"Javascript is prototype-based only, in class inheritance also, it works in prototype mechanism."]}),(0,n.jsxs)("div",{className:"mt-2",children:["당신이 JavaScript의 Class에 동의하든 하지 않든, ",(0,n.jsx)("br",{}),"프로토타입 상속은 그 자체로 우아한 방식입니다. ",(0,n.jsx)("br",{}),"자바스크립트는 철저히 프로토타입 기반의 언어입니다. 상속도 마찬가지이며, 결국 프로토타입 메카니즘으로 작동합니다."]})]})]})}},7475:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>d});var n=t(5155),i=t(2761);t(2139);var r=t(9969),a=t(908),o=t(2626),c=t.n(o),l=t(6167);function d(){return(0,n.jsxs)("div",{className:c().container,children:[(0,n.jsx)(i.A,{text:"Move on to ESM-only"}),(0,n.jsx)(l.A,{href:"https://antfu.me/posts/move-on-to-esm-only",prefix:"https://antfu.me/",text:"https://antfu.me/posts/move-on-to-esm-only"}),(0,n.jsx)(a.A,{text:"2025.2.7"}),(0,n.jsxs)("section",{className:c().paragraph,children:[(0,n.jsxs)("p",{children:[(0,n.jsx)(l.A,{href:"https://javascriptweekly.com/issues/723",text:"https://javascriptweekly.com/issues/723"}),"에 실린 링크를 통해 읽은 글입니다."]}),(0,n.jsxs)("p",{children:["최근 Fastify로 프로젝트를 만들면서, ESM으로 작성했습니다.",(0,n.jsx)(l.A,{href:"https://github.com/dezcao/fastify-kubernetes-basic",prefix:"개인 리포지토리 - Fastify 프로젝트",text:"https://github.com/dezcao/fastify-kubernetes-basic"})]}),(0,n.jsx)("p",{children:"하지만, TypeScript를 스키마에만 적용하는데에도, 짜증나는 점이 많았습니다."}),(0,n.jsx)("p",{children:"설정에 노가다가 들어가는 부분도 그렇지만, 특히나 타입스크립트를 위한 번들링이 된 뒤에 import문이 찾고있는 파일에 대해서 확장자가 .ts로 남아 프로그램이 올바르게 실행되지 않았습니다."}),(0,n.jsx)("p",{children:"설정으로 해결하는 방법도 있는듯 하지만, 제 입장에서 가장 손쉽게 해결한건 .ts파일을 import 구문에서 .js로 입력하는 거였습니다."}),(0,n.jsx)("p",{children:"작동은 하지만, 실제 파일은 .ts이면서 import에서 .js로 적는 이질감은 상당했습니다."}),(0,n.jsx)("p",{children:"마침, ESM-only에 대한 글이 있어서 읽어봤습니다. 생태계와 잇점을 생각하고 한일은 아니었지만, 어쨓든 ESM으로 하기를 잘한것 같다는 생각이 들었습니다."}),(0,n.jsx)("p",{children:"저는 vue에서 쓰던것과 같이, 일관된 문법으로 도배를 하고 싶어서 억지로 붙였던 것인데. 아래 글에서 나오지만, 트리셰이킹으로 미세하나마 번들 크기도 줄어들 테니까요."})]}),(0,n.jsx)(a.A,{}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:[(0,n.jsx)("p",{children:"Three years ago, I wrote a post about shipping ESM & CJS in a single package,"}),(0,n.jsx)("p",{children:"advocating for dual CJS/ESM formats to ease user migration and trying to make the best of both worlds."})]}),(0,n.jsxs)("div",{children:[(0,n.jsx)("p",{children:"3년전, ESM과 CJS 두가지 포맷을 단일 패키지로 배포하는 글을 쓴적이 있습니다."}),(0,n.jsx)("p",{children:"두 포맷을 사용자가 쉽게 마이그레이션 하도록 돕고 두 방식의 장점을 살리려 노력했습니다. (마이그 - CJS에서 ESM으로 전환. ESM이 최신 권장)"})]})]}),(0,n.jsx)(r.A,{text:"shipping - 배포하다. 출시하다. 배송하다."}),(0,n.jsx)(a.A,{text:"글에서 말하는, 각 방식의 장점을 정리해 봅니다."}),(0,n.jsxs)("ul",{className:"list-disc ml-5",children:[(0,n.jsx)("li",{children:"브라우저에서 호환이 됨."}),(0,n.jsx)("li",{children:"비동기 로딩 가능 (await import)"}),(0,n.jsxs)("li",{children:["Tree shaking : 번들 크기 최적화 가능. 필요한 모듈만 가져올 수 있음 (import ",somthing," from 'some-library')"]}),(0,n.jsx)("li",{children:"미래의 표준 : React, Vue, Vite등 ESM 기반으로 설계됨."})]}),(0,n.jsxs)("ul",{className:"list-disc ml-5",children:[(0,n.jsx)("li",{children:"동기적 로딩 : require()가 순차적으로 실행됨."}),(0,n.jsx)("li",{children:"__dirname, __filename 사용 가능. 파일 경로 다루기 편함. ESM은 import.meta.url 을 써야함."}),(0,n.jsx)("li",{children:'특별한 설정 없이 바로 require를 사용. ESM은 package.json에서 type: "module" 추가 필요.'})]}),(0,n.jsx)(a.A,{}),(0,n.jsxs)("section",{children:[(0,n.jsxs)("div",{children:[(0,n.jsx)("p",{children:"As of 2025, a decade has passed since ESM was first introduced in 2015."}),(0,n.jsx)("p",{children:"Modern tools and libraries have increasingly adopted ESM as the primary module format."}),(0,n.jsx)("p",{children:"According to WOOORM’s script, the packages that ships ESM on npm in 2021 was 7.8%,"}),(0,n.jsx)("p",{children:"and by the end of 2024, it had reached 25.8%."}),(0,n.jsx)("p",{children:"Although a significant portion of packages still use CJS, the trend clearly shows a good shift towards ESM."})]}),(0,n.jsxs)("div",{children:[(0,n.jsx)("p",{children:"2025년으로, 2015년 ESM이 소개된지 10년이 되었다."}),(0,n.jsx)("p",{children:"최근 개발 도구와 라이브러리들은 점차 ESM을 우선으로 채택하고 있다."}),(0,n.jsx)("p",{children:"WOOORM’s script에 따르면, 2021년 npm에서 ESM으로 배포된 패키지는 7.8% 였고,"}),(0,n.jsx)("p",{children:"2024년 말에 25.8%가 되었다."}),(0,n.jsx)("p",{children:"상당한 패키지들이 여전히 CJS를 쓰지만, ESM으로의 바람직한 전환이 뚜렷한 추세를 보였다. [원문에서는 여기에 이미지가 있습니다. 궁금하시면 상단에 공유된 원문 링크로.]"})]})]}),(0,n.jsxs)("section",{children:[(0,n.jsx)("p",{children:"Here in this post, I’d like to share my thoughts on the current state of the ecosystem and why I believe it’s time to move on to ESM-only."}),(0,n.jsx)("p",{children:"이번 글에서, 현제의 생태계 상황과 ESM-only로 해야할 때라는 나의 생각을 공유해 보겠다."})]}),(0,n.jsxs)("section",{children:[(0,n.jsx)("div",{children:(0,n.jsx)("p",{children:"도구가 준비 되었다."})}),(0,n.jsxs)("div",{children:[(0,n.jsx)("p",{children:"With the rise of Vite as a popular modern frontend build tool,"}),(0,n.jsx)("p",{children:"many meta-frameworks like Nuxt, SvelteKit, Astro, SolidStart, Remix, Storybook, Redwood, and many others"}),(0,n.jsx)("p",{children:"are all built on top of Vite nowadays, that treating ESM as a first-class citizen."})]}),(0,n.jsxs)("div",{children:[(0,n.jsx)("p",{children:"비트(Vite)가 인기있는 최근 프론트 빌드 도구로 떠오르면서,"}),(0,n.jsx)("p",{children:"많은 meta-frameworks(Nuxt, SvelteKit etc)들이 비트를 기반으로 구축되었고, ESM을 최우선으로 지원한다."}),(0,n.jsx)(r.A,{text:"Meta-framework - 기존 프레임워크 위에서 동작하는 프레임워크. ex, Next(React 기반)/Nuxt(Vue 기반)"})]})]})]})}},7556:(e,s,t)=>{"use strict";t.r(s),t.d(s,{default:()=>j});var n=t(698),i=t(5155),r=t(2761),a=t(2139),o=t(9969),c=t(908),l=t(2626),d=t.n(l),h=t(6167);function x(){let e=(0,n._)(["import { something } from 'some-library';"]);return x=function(){return e},e}function j(){return(0,i.jsxs)("div",{className:d().container,children:[(0,i.jsx)(r.A,{text:"Move on to ESM-only"}),(0,i.jsx)(h.A,{href:"https://antfu.me/posts/move-on-to-esm-only",prefix:"https://antfu.me/",text:"https://antfu.me/posts/move-on-to-esm-only"}),(0,i.jsx)(c.A,{text:"2025.2.17"}),(0,i.jsxs)("section",{className:d().paragraph,children:[(0,i.jsxs)("p",{children:[(0,i.jsx)("a",{href:"https://javascriptweekly.com/issues/723",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://javascriptweekly.com/issues/723"}),(0,i.jsx)("span",{children:"에 실린 링크를 통해 읽은 글입니다. 본문 해석에 오류가 있을 수 있어, 가능한 한 본문을 함께 실었습니다."})]}),(0,i.jsxs)("div",{className:"pt-2 pb-2",children:["최근 Fastify로 프로젝트를 만들면서, ESM으로 작성했습니다.",(0,i.jsxs)("p",{children:["하지만, TypeScript를 스키마에만 적용하는데에도, 짜증나는 점이 많았습니다. ",(0,i.jsx)("br",{}),"아래는 초기버전으로 CI/CD, Sql 파싱과 캐싱등 추가 작업을 하면, 별도 레파지토리로 만들 계획입니다."]}),(0,i.jsx)(h.A,{href:"https://github.com/dezcao/fastify-kubernetes-basic",title:"개인 프로젝트",prefix:"Fastify Basic 프로젝트",text:"https://github.com/dezcao/fastify-kubernetes-basic"})]}),(0,i.jsx)("p",{children:"설정에 노가다가 들어가는 부분도 그렇지만,"}),(0,i.jsx)("p",{children:"특히나 타입스크립트를 위한 번들링이 된 뒤에 import문이 찾고있는 파일에 대해서"}),(0,i.jsx)("p",{children:"확장자가 .ts로 남아있으면서 프로그램이 올바르게 실행되지 않았습니다."}),(0,i.jsx)("p",{className:"pt-2",children:"설정으로 해결하는 방법도 있는듯 하지만, 제 입장에서 가장 손쉽게 해결한건 .ts파일을 import 구문에서 .js로 입력하는 거였습니다."}),(0,i.jsx)("p",{children:"작동은 하지만, 실제 파일은 .ts이면서 import에서 .js로 적는 이질감은 상당했습니다."}),(0,i.jsx)("p",{className:"pt-2",children:"마침, ESM-only에 대한 글이 있어서 읽어봤습니다."}),(0,i.jsx)("p",{children:"생태계와 잇점을 생각하고 한일은 아니었지만, 어쨓든 ESM으로 하기를 잘한것 같다는 생각이 들었습니다."}),(0,i.jsx)("p",{children:"저는 vue에서 쓰던것과 같이, 일관된 문법으로 도배를 하고 싶어서 억지로 붙였던 것인데."}),(0,i.jsx)("p",{children:"아래 글에서 나오지만, 트리셰이킹으로 미세하나마 번들 크기도 줄어들 테니까요."})]}),(0,i.jsx)(c.A,{}),(0,i.jsx)(r.A,{text:"ESM-only로 이동하기"}),(0,i.jsxs)("section",{className:"mb-2",children:[(0,i.jsxs)("div",{children:[(0,i.jsx)("p",{children:"Three years ago, I wrote a post about shipping ESM & CJS in a single package,"}),(0,i.jsx)("p",{children:"advocating for dual CJS/ESM formats to ease user migration and trying to make the best of both worlds."})]}),(0,i.jsxs)("div",{className:"mt-2",children:[(0,i.jsx)("p",{children:"3년전, ESM과 CJS 두가지 포맷을 단일 패키지로 배포하는 글을 쓴적이 있습니다."}),(0,i.jsx)("p",{children:"두 포맷을 사용자가 쉽게 마이그레이션 하도록 돕고 두 방식의 장점을 살리려 노력했습니다. (마이그 - CJS에서 ESM으로 전환. ESM이 최신 권장)"})]})]}),(0,i.jsx)(o.A,{text:"shipping - 배포하다. 출시하다. 배송하다."}),(0,i.jsx)(c.A,{text:"잠시, 위에서 말하는 각 방식의 장점을 정리해 봅니다."}),(0,i.jsx)(a.A,{text:"ESM (ECMAScript Module)"}),(0,i.jsxs)("ul",{className:"list-disc ml-5",children:[(0,i.jsx)("li",{children:"브라우저에서 호환이 됨."}),(0,i.jsx)("li",{children:"비동기 로딩 가능 (await import)"}),(0,i.jsxs)("li",{children:["Tree shaking : 번들 크기 최적화 가능. 필요한 모듈만 가져올 수 있음 (\xa0",String.raw(x())," )"]}),(0,i.jsx)("li",{children:"미래의 표준 : React, Vue, Vite등 ESM 기반으로 설계됨."})]}),(0,i.jsx)(a.A,{text:"CJS (CommonJS)"}),(0,i.jsxs)("ul",{className:"list-disc ml-5",children:[(0,i.jsx)("li",{children:"동기적 로딩 : require()가 순차적으로 실행됨."}),(0,i.jsx)("li",{children:"__dirname, __filename 사용 가능. 파일 경로 다루기 편함. ESM은 import.meta.url 을 써야함."}),(0,i.jsx)("li",{children:'특별한 설정 없이 바로 require를 사용. ESM은 package.json에서 type: "module" 추가 필요.'})]}),(0,i.jsx)(c.A,{}),(0,i.jsxs)("section",{className:"mb-2",children:[(0,i.jsxs)("div",{className:"mb-2",children:[(0,i.jsx)("p",{children:"As of 2025, a decade has passed since ESM was first introduced in 2015."}),(0,i.jsx)("p",{children:"Modern tools and libraries have increasingly adopted ESM as the primary module format."}),(0,i.jsx)("p",{children:"According to WOOORM’s script, the packages that ships ESM on npm in 2021 was 7.8%,"}),(0,i.jsx)("p",{children:"and by the end of 2024, it had reached 25.8%."}),(0,i.jsx)("p",{children:"Although a significant portion of packages still use CJS, the trend clearly shows a good shift towards ESM."})]}),(0,i.jsxs)("div",{children:[(0,i.jsx)("p",{children:"2025년으로, 2015년 ESM이 소개된지 10년이 되었다."}),(0,i.jsx)("p",{children:"최근 개발 도구와 라이브러리들은 점차 ESM을 우선으로 채택하고 있다."}),(0,i.jsx)("p",{children:"WOOORM’s script에 따르면, 2021년 npm에서 ESM으로 배포된 패키지는 7.8% 였고,"}),(0,i.jsx)("p",{children:"2024년 말에 25.8%가 되었다."}),(0,i.jsx)("p",{children:"상당한 패키지들이 여전히 CJS를 쓰지만, ESM으로의 바람직한 전환이 뚜렷한 추세를 보였다. [원문에서는 여기에 이미지가 있습니다. 궁금하시면 상단에 공유된 원문 링크로.]"})]})]}),(0,i.jsxs)("section",{className:"mb-2",children:[(0,i.jsx)("p",{children:"Here in this post, I’d like to share my thoughts on the current state of the ecosystem and why I believe it’s time to move on to ESM-only."}),(0,i.jsx)("p",{children:"이번 글에서, 현제의 생태계 상황과 ESM-only로 해야할 때라는 나의 생각을 공유해 보겠다."})]}),(0,i.jsxs)("section",{children:[(0,i.jsxs)("div",{children:[(0,i.jsx)(a.A,{text:"The Toolings are Ready",type:"h2"}),(0,i.jsx)("p",{children:"도구가 준비 되었다."})]}),(0,i.jsxs)("div",{children:[(0,i.jsx)(a.A,{text:"Morder tools"}),(0,i.jsx)("p",{children:"With the rise of Vite as a popular modern frontend build tool,"}),(0,i.jsx)("p",{children:"many meta-frameworks like Nuxt, SvelteKit, Astro, SolidStart, Remix, Storybook, Redwood, and many others"}),(0,i.jsx)("p",{children:"are all built on top of Vite nowadays, that treating ESM as a first-class citizen."})]}),(0,i.jsxs)("div",{children:[(0,i.jsx)("p",{children:"비트(Vite)가 인기있는 최근 프론트 빌드 도구로 떠오르면서,"}),(0,i.jsx)("p",{className:"mb-2",children:"많은 meta-frameworks(Nuxt, SvelteKit etc)들이 비트를 기반으로 구축되었고, ESM을 최우선으로 지원한다."}),(0,i.jsx)(o.A,{text:"Meta-framework - 기존 프레임워크 위에서 동작하는 프레임워크. ex, Next(React 기반)/Nuxt(Vue 기반)"})]})]}),(0,i.jsxs)("section",{className:"mt-2",children:[(0,i.jsxs)("div",{children:[(0,i.jsx)("p",{children:"As a complement, we have also testing library Vitest,"}),(0,i.jsx)("p",{children:"which was designed for ESM from the day one with powerful module mocking capability and efficient fine-grain caching support."})]}),(0,i.jsxs)("div",{children:[(0,i.jsx)("p",{children:"보충하자면, 테스팅 라이브러리인 Vitetest 같은것은, "}),(0,i.jsx)("p",{className:"mb-2",children:"처음부터 ESM을 기반으로 설계 되었고, 강력한 모듈 모킹과 효과적인 세밀한 캐싱이 지원된다."})]}),(0,i.jsx)(o.A,{text:"from the day one - 처음부터\n          fine-grain - 세밀한"})]}),(0,i.jsxs)("section",{className:"mt-2",children:[(0,i.jsx)("p",{children:"CLI tools like tsx and jiti offer a seamless experience for running TypeScript and ESM code without requiring additional configuration."}),(0,i.jsx)("p",{children:"This simplifies the development process and reduces the overhead associated with setting up a project to use ESM."}),(0,i.jsx)("p",{children:"tsx나 jiti같은 CLI 툴들은 추가적인 설정 없이 타입스크립트와 ESM코드를 원활하게 경험할 수 있도록 지원한다."}),(0,i.jsx)("p",{className:"mb-2",children:"이는 개발 프로세스가 단순해지고 ESM을 세팅하는데 필요한 부담을 줄인다."}),(0,i.jsx)("p",{children:"Other tools, for example, ESLint, in the recent v9.0, introduced a new flat config system that enables native ESM support with eslint.config.mjs, even in CJS projects."}),(0,i.jsx)("p",{children:"예를들어, 최근의 ESLint v9.0에서는 CJS 프로젝트에서도 ESM을 지원하는 설정이 가능해졌다."})]}),(0,i.jsx)("section",{children:(0,i.jsxs)("div",{children:[(0,i.jsx)(a.A,{text:"Top-Down & Bottom-Up"}),(0,i.jsxs)("div",{children:[(0,i.jsx)("p",{children:"Back in 2021, when SINDRESORHUS first started migrating all his packages to ESM-only, for example, find-up and execa, it was a bold move."}),(0,i.jsx)("p",{children:"2021년, SINDRESORHUS가 자신의 모든 패키지를 ESM 전용으로 마이그를 시작했을때, 예를들어 find-up과 execa같은, 그건 대담한 일이었다."}),(0,i.jsx)("p",{children:"I consider this move as a bottom-up approach, as the packages that rather low-level and many their dependents are not ready for ESM yet."}),(0,i.jsx)("p",{children:"나는 이걸 상향식 접근으로 본다. 그 패키지들은 비교적 저수준의 것이고, 그들에 의존하는 많은 것들이 아직 ESM에 대해 준비되지 않았기 때문이다."}),(0,i.jsx)("p",{children:"I was worried that this would force those dependents to stay on the old version of the packages,"}),(0,i.jsx)("p",{children:"난 그 의존하던 것들이 구버전에 머물러 있도록 강요 될까 걱정했다,"}),(0,i.jsx)("p",{children:"which might result in the ecosystem being fragmented."}),(0,i.jsx)("p",{children:"그로인해 생태계가 파편화될까 두려웠다."}),(0,i.jsx)("p",{children:"(As of today, I actually appreciate that move bringing us quite a lot of high-quality ESM packages, regardless that the process wasn’t super smooth)."}),(0,i.jsx)("p",{children:"지금은, 그 움직임이 우리가 꽤 많은 고품질 ESM 패키지로 얻게 했다는걸 인정한다, 비록 과정이 아주 매끄럽진 못했음에도 말이다."}),(0,i.jsx)("p",{className:"mt-2",children:"It’s way easier for an ESM or Dual formats package to depend on CJS packages, but not the other way around."}),(0,i.jsx)("p",{children:"ESM이나 듀얼 포맷이 CJS 패키지에 의존하는 것이 그 반대보다 쉽다."}),(0,i.jsx)("p",{children:"In terms of smooth adoption, I believe the top-down approach is more effective in pushing the ecosystem forward."}),(0,i.jsx)("p",{children:"원활한 도입의 면에서 보면, 하향식이 생태계를 나아가게 하는데 더 효과적이라고 본다."}),(0,i.jsx)("p",{children:"With the support of high-level frameworks and tools from top-down, it’s no longer a significant obstacle to use ESM-only packages."}),(0,i.jsx)("p",{children:"고수준 프레임워크와 도구의 하향식 지원으로, ESM-only 패키지를 하는데 더이상 큰 장애물이 없다."}),(0,i.jsx)("p",{children:"The remaining challenges in terms of ESM adoption primarily lie with package authors needing to migrate and ship their code in ESM format."}),(0,i.jsx)("p",{children:"남은 과제는 (npm)패키지 작성자들이 ESM 형식으로 변환하고 배포하는데 있다."})]})]})}),(0,i.jsxs)("section",{children:[(0,i.jsx)(a.A,{text:"Requiring ESM in Node.js"}),(0,i.jsxs)("div",{className:"mb-2",children:[(0,i.jsxs)("p",{children:["The capability to require() ESM modules in Node.js, initiated by JOYEECHEUNG, marks an incredible milestone.",(0,i.jsx)("br",{})," This feature allows packages to be published as ESM-only while still being consumable by CJS codebases with minimal modifications.",(0,i.jsx)("br",{}),"It helps avoid the async infection (also known as Red Functions) introduced by dynamic import() ESM, which can be pretty hard,",(0,i.jsx)("br",{}),"if not impossible in some cases, to migrate and adapt."]}),(0,i.jsxs)("p",{children:[(0,i.jsx)("span",{children:"Node.js에서 require()로 ESM 모듈을 가능하게는, JOYEECHEUNG에 의해 시적된, 놀라운 이정표가 되었다."}),(0,i.jsx)("br",{}),(0,i.jsx)("span",{children:"이 기능으로 ESM-only 패키지 배포가 CJS기반에서 최소한의 수정으로 사용이 가능하다."}),(0,i.jsx)("br",{}),(0,i.jsx)("span",{children:"이것은 동적 import() 기반의 ESM이 초래하는 async 전염을 막고(Red Functions으로 알려진),"}),(0,i.jsx)("br",{}),(0,i.jsx)("span",{children:"Red Functions은 마이그레이션과 적용을, 경우에 따라 불가능할 정도로, 어렵게 한다."})]}),(0,i.jsxs)("p",{className:"mt-2",children:["( 위에서 말하는 레드 펑션에 대한 링크 :",(0,i.jsx)("a",{href:"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/"}),")"]})]}),(0,i.jsxs)("div",{className:"mb-2",children:[(0,i.jsxs)("p",{children:["This feature was recently unflagged and backported to Node.js v22 (and soon v20), ",(0,i.jsx)("br",{}),"which means it should be available to many developers already."," ",(0,i.jsx)("br",{}),"Consider the top-down or bottom-up metaphor, ",(0,i.jsx)("br",{}),"this feature actually makes it possible to start ESM migration also from middle-out, ",(0,i.jsx)("br",{}),"as it allows import chains like ESM → CJS → ESM → CJS to work seamlessly."]}),(0,i.jsxs)("p",{children:["최근 플래그가 해제되어(정식 기능이 됨) Node.js v22(곧 v20도) 이미 많은 개발자가 사용할 수 있음을 뜻한다. ",(0,i.jsx)("br",{}),"탑다운이나 바텀업 방식의 비유를 볼때, ",(0,i.jsx)("br",{}),"이 기능은 미들아웃(중간부터의) 마이그를 시작할 수 있게 한다. ",(0,i.jsx)("br",{}),"ESM → CJS → ESM → CJS 같은 import 체인을 원활히 할 수 있게 해주기 때문이다."]}),(0,i.jsxs)("p",{className:"mt-2",children:["For more details on the progress and discussions around this feature, keep track on this issue. ",(0,i.jsx)("br",{}),"이 기능의 진행상황과 논의는 이 이슈(링크)를 참조.",(0,i.jsx)("br",{}),(0,i.jsx)("a",{href:"https://github.com/nodejs/node/issues/52697",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://github.com/nodejs/node/issues/52697"})]})]})]}),(0,i.jsx)("section",{children:(0,i.jsxs)("div",{children:[(0,i.jsx)(a.A,{text:"The Troubles with Dual Formats",type:"h2"}),(0,i.jsx)("p",{children:"듀얼 포맷의 문제점"}),(0,i.jsxs)("p",{className:"mt-4",children:["While dual CJS/ESM packages have been a quite helpful transition mechanism, ",(0,i.jsx)("br",{}),"they come with their own set of challenges. ",(0,i.jsx)("br",{}),"Maintaining two separate formats can be cumbersome and error-prone,"," ",(0,i.jsx)("br",{}),"especially when dealing with complex codebases."]}),(0,i.jsxs)("p",{className:"mt-2",children:["듀얼 패키지 포맷은 전환 과정에 유용하지만, ",(0,i.jsx)("br",{}),"자체적인 문제도 가진다. ",(0,i.jsx)("br",{}),"두개를 유지하는것은 번거롭고 오류를 유발하기 쉽다, ",(0,i.jsx)("br",{}),"특히 복잡한 코드에서 더 그렇다."]}),(0,i.jsxs)("p",{className:"mt-2",children:["Here are some of the issues that arise when maintaining dual formats:",(0,i.jsx)("br",{}),"다음은 듀얼포맷의 몇가지 문제들이다."]}),(0,i.jsx)(a.A,{text:"Interop Issues: 호환성 문제"}),(0,i.jsxs)("p",{children:["Fundamentally, CJS and ESM are different module systems with distinct design philosophies. ",(0,i.jsx)("br",{}),"Although Node.js has made it possible to import CJS modules in ESM, dynamically import ESM in CJS, and even require() ESM modules,"," ",(0,i.jsx)("br",{}),"there are still many tricky cases that can lead to interop issues."]}),(0,i.jsxs)("p",{className:"mb-2",children:["근원적으로, CJS와 ESM은 서로 다른 철학으로 설계된 별개의 모듈 시스템이다. ",(0,i.jsx)("br",{}),"비록 Node.js에서 ESM에 CJS 모듈을 import하거나, CJS에서 ESM을 동적으로 import 하거나, 심지어 requrie()로 ESM 모듈을 가능하게 했지만, ",(0,i.jsx)("br",{}),"여전히 호환성 문제를 야기할 수 있는 까다로운 문제들이 많다."]}),(0,i.jsx)(o.A,{text:"Interop - Interoperability. 상호운용성."}),(0,i.jsxs)("p",{className:"mt-5",children:["One key difference is that CJS typically uses a single module.exports object, ",(0,i.jsx)("br",{}),"while ESM supports both default and named exports. ",(0,i.jsx)("br",{}),"When authoring code in ESM and transpiling to CJS, ",(0,i.jsx)("br",{}),"handling exports can be particularly challenging, ",(0,i.jsx)("br",{}),"especially when the exported value is a non-object, ",(0,i.jsx)("br",{}),"such as a function or a class. ",(0,i.jsx)("br",{}),"Additionally, to make the types correct, we also need to introduce further complications with .d.mts and .d.cts declaration files. And so on…"]}),(0,i.jsxs)("p",{className:"mt-2",children:["주요차이점 하나는 CJS가 일반적으로 단일 moudule.exports 객체를 쓸 때, ",(0,i.jsx)("br",{}),"ESM은 default 와 named를 모두 지원한다. ",(0,i.jsx)("br",{}),"ESM에서 작성하고 CJS로 바꿀때, ",(0,i.jsx)("br",{}),"exports는 다루기 어렵게 된다, ",(0,i.jsx)("br",{}),"특히 내보내는 것이 객체가 아니라, 함수나 클래스이면. ",(0,i.jsx)("br",{}),"게다가, 타입을 올바르게 유지하려면, .d.mts와 c.cts를 선언하는 더 복잡한 과정이 필요하다. 등."]}),(0,i.jsxs)("p",{className:"mt-5",children:["As I am trying to explain this problem deeper, ",(0,i.jsx)("br",{}),"I found that I actually wish you didn’t even need to be bothered with this problem at all. ",(0,i.jsx)("br",{}),"It’s frankly too complicated and frustrating. ",(0,i.jsx)("br",{}),"If you are just a user of packages, let alone the package authors to worry about that. ",(0,i.jsx)("br",{}),"This is one of the reasons I advocate for the entire ecosystem to transition to ESM, to leave these problems behind and spare everyone from this unnecessary hassle."]}),(0,i.jsxs)("p",{className:"mt-2 mb-2",children:["더 깊이 설명하려 할 때, ",(0,i.jsx)("br",{}),"당신이 이 문제로 귀찮지 않았으면 좋겠다는 생각이 들었다. ",(0,i.jsx)("br",{}),"솔직히 너무 복잡하고 짜증난다. ",(0,i.jsx)("br",{}),"패키지 작성자는 물론이고, 단지 패키지 사용자로도 그런걸 걱정해야 한다면. ",(0,i.jsx)("br",{}),"이게 내가 ESM으로 생태계를 전환하자는 이유중 하나이다, ",(0,i.jsx)("br",{}),"이 문제를 뒤로하고 불필요한 논쟁에서 벗어나기 위해서다."]}),(0,i.jsx)(o.A,{text:"let alone - 물론\n                   hassle - 격론"}),(0,i.jsx)(a.A,{text:"Dependency Resolution: 의존성 관리리"}),(0,i.jsxs)("p",{className:"mt-5",children:["When a package has both CJS and ESM formats, the resolution of dependencies can become convoluted. ",(0,i.jsx)("br",{}),"For example, if a package depends on another package that only ships ESM, ",(0,i.jsx)("br",{}),"the consumer must ensure that the ESM version is used. ",(0,i.jsx)("br",{}),"This can lead to version conflicts and dependency resolution issues, especially when dealing with transitive dependencies."]}),(0,i.jsxs)("p",{className:"mt-2 mb-2",children:["패키지가 두 형태로 되어있을때, 이존성 해결은 꼬일 수 있다. ",(0,i.jsx)("br",{}),"예를들어, ESM전용으로된 패키지를 의존하는 패키지는, 사용자가 ESM으로만 쓸 수있게 보장된다. ",(0,i.jsx)("br",{}),"이건 버전 충돌과 의존성 이슈를 유발할 수 있다 특히, 전이적 의존성일때."]}),(0,i.jsx)(o.A,{text:"convoluted - 둘둘 말린\n                   transitive dependencies - 전이적 의존. 또 다른 의존성에 의존."}),(0,i.jsxs)("p",{className:"mt-2 mb-2",children:["Also for packages that are designed to used with singleton pattern,"," ",(0,i.jsx)("br",{}),"this might introduce multiple copies of the same package and cause unexpected behaviors. ",(0,i.jsx)("br",{}),"싱글톤 패턴으로 설계된 패키지의 경우, ",(0,i.jsx)("br",{}),"같은 패키지가 여러 개 로드될 수 있고 의도치 않은 동작을 유발 할 수 있다."]}),(0,i.jsx)(a.A,{text:"Package Size: 패키지 크기"}),(0,i.jsxs)("p",{children:["Shipping dual formats essentially doubles the package size, as both CJS and ESM bundles need to be included. ",(0,i.jsx)("br",{}),"While a few extra kilobytes might not seem significant for a single package, ",(0,i.jsx)("br",{}),"the overhead can quickly add up in projects with hundreds of dependencies, leading to the infamous node_modules bloat. ",(0,i.jsx)("br",{}),"Therefore, package authors should keep an eye on their package size."," ",(0,i.jsx)("br",{}),"Moving to ESM-only is a way to optimize it, especially if the package doesn’t have strong requirements on CJS."]}),(0,i.jsxs)("p",{className:"mt-2",children:["듀얼 포맷은 패키지 사이즈를 두배로 만든다, 두 번들이 모두 포함되야 하기 때문이다. ",(0,i.jsx)("br",{}),"단일 패키지에 몇킬로 바이트는 무제가 안될 수 있지만, ",(0,i.jsx)("br",{}),"수백 개의 의존성을 가진 프로젝트에서는 이런 자원소모(overhead)는 엄청난 node_modules 증가를 빠르게 초래한다. ",(0,i.jsx)("br",{}),"따라서, 패키지 제작자는 사이즈에서 눈을 떼면 안된다. ",(0,i.jsx)("br",{}),"ESM전용으로 전환하는것이 최적화하는 방법이다, 특히 CJS가 필수적이지 않다면."]})]})}),(0,i.jsx)("section",{children:(0,i.jsxs)("div",{children:[(0,i.jsx)(a.A,{text:"When Should We Move to ESM-only?",type:"h2"}),(0,i.jsx)("p",{children:"언제 ESM 전용으로 할까."}),(0,i.jsxs)("p",{children:[(0,i.jsx)("br",{}),"This post does not intend to diminish the value of dual-format publishing. ",(0,i.jsx)("br",{}),"Instead, I want to encourage evaluating the current state of the ecosystem and the potential benefits of transitioning to ESM-only."," ",(0,i.jsx)("br",{}),"듀얼포맷을 폄하 하려는게 아니다. ",(0,i.jsx)("br",{}),"대신, 현재 생태계를 평가하고 ESM전용으로 하는 잠재적 이익에 대해 권장하고 싶다. ",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"There are several factors to consider when deciding whether to move to ESM-only: ",(0,i.jsx)("br",{}),"전향하는데 고려할 몇가지 요소가 있다."]}),(0,i.jsx)(a.A,{text:"New Packages"}),(0,i.jsxs)("p",{children:["I strongly recommend that all new packages be released as ESM-only, as there are no legacy dependencies to consider. ",(0,i.jsx)("br",{}),"New adopters are likely already using a modern, ESM-ready stack, there being ESM-only should not affect the adoption. ",(0,i.jsx)("br",{}),"Additionally, maintaining a single module system simplifies development, reduces maintenance overhead, and ensures that your package benefits from future ecosystem advancements. ",(0,i.jsx)("br",{}),"기존 의존성을 고려할 필요가 없는 신규 패키지면 강력이 권한다. ",(0,i.jsx)("br",{}),"신규 사용자는 이미 최신 ESM 지원환경을 사용하고 있을것이고, 전용으로 해도 적용에 문제가 없을 것이다. ",(0,i.jsx)("br",{}),"게다가, 단일한 모듈로 개발하면 단순해지고, 유지보수 비용이 줄고, 향후 생태게 발전의 잇점을 누리기도 쉬워진다."]}),(0,i.jsx)(a.A,{text:"Browser-targeted Packages"}),(0,i.jsxs)("p",{children:["If a package is primarily targeted for the browser, it makes total sense to ship ESM-only. ",(0,i.jsx)("br",{}),"In most cases, browser packages go through a bundler, where ESM provides significant advantages in static analysis and tree-shaking."," ",(0,i.jsx)("br",{}),"This leads to smaller and more optimized bundles, which would also improve loading performance and reduce bandwidth consumption for end users. ",(0,i.jsx)("br",{}),"브라우저를 우선으로 한다면, ESM전용이 가장 좋다. ",(0,i.jsx)("br",{}),"대부분, 브라우저패키지는 번들러를 거치는데, 정적 분석과 트리셰이킹에서 잇점이 있다. ",(0,i.jsx)("br",{}),"이건 더 작고 최적화된 번들과 로딩 성능 개선, 유저의 네트워크 사용을 줄여준다."]}),(0,i.jsx)(a.A,{text:"Standalone CLI"}),(0,i.jsxs)("p",{children:["For a standalone CLI tool, it’s no difference to end users whether it’s ESM or CJS. ",(0,i.jsx)("br",{}),"However, using ESM would enable your dependencies to also be ESM, facilitating the ecosystem’s transition to ESM from a top-down approach. ",(0,i.jsx)("br",{}),"독립실행 툴일때, ESM이든 CJS든 차이는 없다. ",(0,i.jsx)("br",{}),"그러나, ESM을 쓰면 당신 패키지가 의존하는 패키지가 ESM을 사용하게 할 것이고, 탑다운 방식으로 생태계를 촉진할것이다."]}),(0,i.jsx)(o.A,{text:"CLI - Command-Line Interface (ex, git, npm, ESLint).\nCLI가 개발환경을 주도하고 있어서, 소비주체인 CLI가 오히려 의존패키지들에게 영향을 준다는것 같습니다(탑다운). 예를들어, ESLint v9가 ESM-only가 되었음.\n            "}),(0,i.jsx)(a.A,{text:"Node.js Support"}),(0,i.jsxs)("p",{children:["If a package is targeting the evergreen Node.js versions, ",(0,i.jsx)("br",{}),"it’s a good time to consider ESM-only, especially with the recent require(ESM) support. ",(0,i.jsx)("br",{}),"최신 Node.js버전을 대상으로 하면, ESM-only를 고려하기 좋을 때입니다. 특히 최근엔 require(ESM)이 지원되니까요."]}),(0,i.jsx)(a.A,{text:"Know Your Consumers"}),(0,i.jsxs)("p",{children:["If a package already has certain users, it’s essential to understand the dependents’ status and requirements. ",(0,i.jsx)("br",{}),"For example, for an ESLint plugin/utils that requires ESLint v9,"," ",(0,i.jsx)("br",{}),"while ESLint v9’s new config system supports ESM natively even in CJS projects, ",(0,i.jsx)("br",{}),"there is no blocker for it to be ESM-only. ",(0,i.jsx)("br",{}),"이미 패키지에 사용자가 있다면, 의존상태와 요구를 이해해야 한다."," ",(0,i.jsx)("br",{}),"예를들어 ESLint v9를 쓰는 플러그인과 유틸의 경우, ",(0,i.jsx)("br",{}),"린트가 CJS프로젝트에서 ESM을 지원하는 환경을 제공하므로, ",(0,i.jsx)("br",{}),"ESM-only로 이동하는데 장애물이 없을 겁니다. ",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"Definitely, there are different factors to consider for different projects. ",(0,i.jsx)("br",{}),"But in general, I believe the ecosystem is ready for more packages to move to ESM-only, ",(0,i.jsx)("br",{}),"and it’s a good time to evaluate the benefits and potential challenges of transitioning. ",(0,i.jsx)("br",{}),"프로젝트마다 고려할 요소는 다를 수 있다. ",(0,i.jsx)("br",{}),"하지만 대게, 이제 생태계는 준비되었고, ",(0,i.jsx)("br",{}),"전환으로의 이점과 잠재적 과제를 평가할 좋은 시기이다."]})]})}),(0,i.jsx)("section",{children:(0,i.jsxs)("div",{children:[(0,i.jsx)(a.A,{text:"How Far We Are?",type:"h2"}),(0,i.jsx)("p",{children:"얼마나 왔나."}),(0,i.jsx)("br",{}),(0,i.jsxs)("p",{children:["The transition to ESM is a gradual process that requires collaboration and effort from the entire ecosystem. ",(0,i.jsx)("br",{}),"Which I believe we are on a good track moving forward. ",(0,i.jsx)("br",{}),"To improve the transparency and visibility of the ESM adoption,"," ",(0,i.jsx)("br",{}),"I recently built a visualized tool called Node Modules Inspector for analyzing your packages’s dependencies. ",(0,i.jsx)("br",{}),"It provides insights into the ESM adoption status of your dependencies and helps identify potential issues when migrating to ESM. ",(0,i.jsx)("br",{}),"전환은 생태계의 협력과 노력이 필요한 점진적 과정입니다. ",(0,i.jsx)("br",{}),"우리는 잘 가고 있다고 생각합니다. ",(0,i.jsx)("br",{}),"ESM 적용의 투명성과 가시성을 향상시키기 위해, ",(0,i.jsx)("br",{}),"패키지 의존성을 분석하는 Node Modules Inspector라는 시각화 툴을 개발했습니다. ",(0,i.jsx)("br",{}),"의존성의 ESM 적용에 대한 통찰을 제공하고, 전환에 대한 잠재적 문제를 식별하는데 도움을 줄겁니다. ",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"This tool is still in its early stages, ",(0,i.jsx)("br",{}),"but I hope it will be a valuable resource for package authors and maintainers to track the ESM adoption progress of their dependencies and make informed decisions about transitioning to ESM-only. ",(0,i.jsx)("br",{}),"To learn more about how to use it and inspect your projects, check the repository ",(0,i.jsx)("br",{}),"시작단계지만, 패키지 제작자와 유지보수 담당자에게 의존라이브러리의, ESM 적용 상황을 추적하고 ESM-only으로 전향하는데 더나은 결정을 하는데 도움이 되기 바랍니다. ",(0,i.jsx)("br",{}),(0,i.jsx)("a",{href:"https://github.com/antfu/node-modules-inspector",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://github.com/antfu/node-modules-inspector"}),"(본문에는 이미지도 있습니다.)"]})]})}),(0,i.jsx)("section",{children:(0,i.jsxs)("div",{children:[(0,i.jsx)(a.A,{text:"Moving Forward",type:"h2"}),(0,i.jsx)("p",{children:"앞으로"}),(0,i.jsx)("br",{}),(0,i.jsxs)("p",{children:["the dependencies we rely on. ",(0,i.jsx)("br",{}),"We also have plenty of exciting ideas for the Node Modules Inspector, aiming to provide more useful insights and help find the best path forward. ",(0,i.jsx)("br",{}),"I look forward to a more portable, resilient, and optimized JavaScript/TypeScript ecosystem. ",(0,i.jsx)("br",{}),"I hope this post has shed some light on the benefits of moving to ESM-only and the current state of the ecosystem. ",(0,i.jsx)("br",{}),"If you have any thoughts or questions, feel free to reach out using the links below. Thank you for reading! ",(0,i.jsx)("br",{}),"저는 제가 관리하는 패키지들을 점진적으로 ESM-only로 전환하고 의존하는 것들을 살펴볼 것입니다. ",(0,i.jsx)("br",{}),"또, Node Modules Inspector에 아이디어들이 있고, 더 유용한 통찰과 최적의 전환경로를 찾는데 도움이 될 것들을 추가할 예정입니다. ",(0,i.jsx)("br",{}),"더 경량의, 탄력적인, 최적의 JS/TS 환경을 기대합니다. ",(0,i.jsx)("br",{}),"전환에 대한 이점과 상황을 이해하는데 도움이 되었기를 바랍니다."," ",(0,i.jsx)("br",{}),"당신의 생각이나 질문을, 편하게 아래 링크로 연락해 주셔도 됩니다."," ",(0,i.jsx)("br",{}),(0,i.jsx)("a",{href:"https://antfu.me/",target:"_blank",rel:"noopener noreferrer",className:"text-blue-500 underline",children:"https://antfu.me/"}),"(글쓴이는 블로그에서 이메일도 되는것 같습니다. X는 가입을 안해서 저자의 링크를 못땄습니다.)"]})]})}),(0,i.jsx)(c.A,{text:"옮기고 나서"}),"의외로, 저자가 React가 아니라 Vue, Nuxt팀인것을 알게 되었습니다. ",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"요즘 구직환경에서, 점점 React로의 편중을 느끼는 와중에 반갑다 해야할지."," ",(0,i.jsx)("br",{}),"이름에 Fu라고 하는것으로 보아, 중국계인가 봅니다. Vue의 창시자 Evan Yu 처럼요. ",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"글은 긴데 요약하면, 두 줄 같습니다.",(0,i.jsxs)("ul",{className:"list-disc ml-5",children:[(0,i.jsx)("li",{children:"생태계가 ESM으로 가고 있다."}),(0,i.jsx)("li",{children:"당신도 가자.."})]}),(0,i.jsx)("br",{}),"개인적인 생각일 뿐이나, ",(0,i.jsx)("br",{}),"Vue의 입지는 앞으로 더 줄어들것 같습니다. ",(0,i.jsx)("br",{}),"불과 몇 년 사이, 구직시장에서 온도차가 피부로 느껴질 정도로 차갑습니다."," ",(0,i.jsx)("br",{}),"그냥, 내가 안팔리는 건가...",(0,i.jsx)("br",{}),(0,i.jsx)("br",{}),"하지만, 저는 Vue를 더 좋게 생각합니다.",(0,i.jsx)("br",{}),"벌레 수준이지만, 공부를 위해, 이 블로그를 React SSG로 만들면서 React코드가 조금 더 난잡해지기 쉽다는 생각이 들었습니다.",(0,i.jsx)("br",{}),"React가 모든것은 함수이다라는 철학에서 시작했기 때문에, 태그를 함수에 끼웠지만, ",(0,i.jsx)("br",{}),"바로 그것 때문에 시각적으로 난잡하다고 느꼈습니다."]})}},2626:e=>{e.exports={container:"Content_container__YuMwV",paragraph:"Content_paragraph__JAFHy",codeBlock:"Content_codeBlock__DpLTZ",highlight:"Content_highlight__CU7wi"}}},e=>{var s=s=>e(e.s=s);e.O(0,[29,141,173,205,441,517,358],()=>s(9413)),_N_E=e.O()}]);